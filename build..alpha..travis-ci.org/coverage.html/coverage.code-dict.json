{"/home/travis/build/npmtest/node-npmtest-parse-server/test.js":"/* istanbul instrument in package npmtest_parse_server */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-parse-server/lib.npmtest_parse_server.js":"/* istanbul instrument in package npmtest_parse_server */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_parse_server = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_parse_server = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-parse-server/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-parse-server && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_parse_server */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_parse_server\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_parse_server.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_parse_server.rollup.js'] =\n            local.assetsDict['/assets.npmtest_parse_server.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_parse_server.__dirname + '/lib.npmtest_parse_server.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/index.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParseServer = exports.PushWorker = exports.TestUtils = exports.RedisCacheAdapter = exports.NullCacheAdapter = exports.InMemoryCacheAdapter = exports.FileSystemAdapter = exports.GCSAdapter = exports.S3Adapter = undefined;\n\nvar _ParseServer2 = require('./ParseServer');\n\nvar _ParseServer3 = _interopRequireDefault(_ParseServer2);\n\nvar _parseServerS3Adapter = require('parse-server-s3-adapter');\n\nvar _parseServerS3Adapter2 = _interopRequireDefault(_parseServerS3Adapter);\n\nvar _parseServerFsAdapter = require('parse-server-fs-adapter');\n\nvar _parseServerFsAdapter2 = _interopRequireDefault(_parseServerFsAdapter);\n\nvar _InMemoryCacheAdapter = require('./Adapters/Cache/InMemoryCacheAdapter');\n\nvar _InMemoryCacheAdapter2 = _interopRequireDefault(_InMemoryCacheAdapter);\n\nvar _NullCacheAdapter = require('./Adapters/Cache/NullCacheAdapter');\n\nvar _NullCacheAdapter2 = _interopRequireDefault(_NullCacheAdapter);\n\nvar _RedisCacheAdapter = require('./Adapters/Cache/RedisCacheAdapter');\n\nvar _RedisCacheAdapter2 = _interopRequireDefault(_RedisCacheAdapter);\n\nvar _TestUtils = require('./TestUtils');\n\nvar TestUtils = _interopRequireWildcard(_TestUtils);\n\nvar _deprecated = require('./deprecated');\n\nvar _logger = require('./logger');\n\nvar _PushWorker = require('./Push/PushWorker');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Factory function\nvar _ParseServer = function _ParseServer(options) {\n  var server = new _ParseServer3.default(options);\n  return server.app;\n};\n// Mount the create liveQueryServer\n_ParseServer.createLiveQueryServer = _ParseServer3.default.createLiveQueryServer;\n\nvar GCSAdapter = (0, _deprecated.useExternal)('GCSAdapter', 'parse-server-gcs-adapter');\n\nObject.defineProperty(module.exports, 'logger', {\n  get: _logger.getLogger\n});\n\nexports.default = _ParseServer3.default;\nexports.S3Adapter = _parseServerS3Adapter2.default;\nexports.GCSAdapter = GCSAdapter;\nexports.FileSystemAdapter = _parseServerFsAdapter2.default;\nexports.InMemoryCacheAdapter = _InMemoryCacheAdapter2.default;\nexports.NullCacheAdapter = _NullCacheAdapter2.default;\nexports.RedisCacheAdapter = _RedisCacheAdapter2.default;\nexports.TestUtils = TestUtils;\nexports.PushWorker = _PushWorker.PushWorker;\nexports.ParseServer = _ParseServer;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/ParseServer.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _defaults = require('./defaults');\n\nvar _defaults2 = _interopRequireDefault(_defaults);\n\nvar _logger = require('./logger');\n\nvar logging = _interopRequireWildcard(_logger);\n\nvar _cache = require('./cache');\n\nvar _cache2 = _interopRequireDefault(_cache);\n\nvar _Config = require('./Config');\n\nvar _Config2 = _interopRequireDefault(_Config);\n\nvar _PromiseRouter = require('./PromiseRouter');\n\nvar _PromiseRouter2 = _interopRequireDefault(_PromiseRouter);\n\nvar _requiredParameter = require('./requiredParameter');\n\nvar _requiredParameter2 = _interopRequireDefault(_requiredParameter);\n\nvar _AnalyticsRouter = require('./Routers/AnalyticsRouter');\n\nvar _ClassesRouter = require('./Routers/ClassesRouter');\n\nvar _FeaturesRouter = require('./Routers/FeaturesRouter');\n\nvar _InMemoryCacheAdapter = require('./Adapters/Cache/InMemoryCacheAdapter');\n\nvar _AnalyticsController = require('./Controllers/AnalyticsController');\n\nvar _CacheController = require('./Controllers/CacheController');\n\nvar _AnalyticsAdapter = require('./Adapters/Analytics/AnalyticsAdapter');\n\nvar _WinstonLoggerAdapter = require('./Adapters/Logger/WinstonLoggerAdapter');\n\nvar _FilesController = require('./Controllers/FilesController');\n\nvar _FilesRouter = require('./Routers/FilesRouter');\n\nvar _FunctionsRouter = require('./Routers/FunctionsRouter');\n\nvar _GlobalConfigRouter = require('./Routers/GlobalConfigRouter');\n\nvar _GridStoreAdapter = require('./Adapters/Files/GridStoreAdapter');\n\nvar _HooksController = require('./Controllers/HooksController');\n\nvar _HooksRouter = require('./Routers/HooksRouter');\n\nvar _IAPValidationRouter = require('./Routers/IAPValidationRouter');\n\nvar _InstallationsRouter = require('./Routers/InstallationsRouter');\n\nvar _AdapterLoader = require('./Adapters/AdapterLoader');\n\nvar _LiveQueryController = require('./Controllers/LiveQueryController');\n\nvar _LoggerController = require('./Controllers/LoggerController');\n\nvar _LogsRouter = require('./Routers/LogsRouter');\n\nvar _ParseLiveQueryServer = require('./LiveQuery/ParseLiveQueryServer');\n\nvar _PublicAPIRouter = require('./Routers/PublicAPIRouter');\n\nvar _PushController = require('./Controllers/PushController');\n\nvar _PushQueue = require('./Push/PushQueue');\n\nvar _PushWorker = require('./Push/PushWorker');\n\nvar _PushRouter = require('./Routers/PushRouter');\n\nvar _CloudCodeRouter = require('./Routers/CloudCodeRouter');\n\nvar _RolesRouter = require('./Routers/RolesRouter');\n\nvar _SchemasRouter = require('./Routers/SchemasRouter');\n\nvar _SessionsRouter = require('./Routers/SessionsRouter');\n\nvar _UserController = require('./Controllers/UserController');\n\nvar _UsersRouter = require('./Routers/UsersRouter');\n\nvar _PurgeRouter = require('./Routers/PurgeRouter');\n\nvar _DatabaseController = require('./Controllers/DatabaseController');\n\nvar _DatabaseController2 = _interopRequireDefault(_DatabaseController);\n\nvar _SchemaCache = require('./Controllers/SchemaCache');\n\nvar _SchemaCache2 = _interopRequireDefault(_SchemaCache);\n\nvar _parseServerPushAdapter = require('parse-server-push-adapter');\n\nvar _parseServerPushAdapter2 = _interopRequireDefault(_parseServerPushAdapter);\n\nvar _MongoStorageAdapter = require('./Adapters/Storage/Mongo/MongoStorageAdapter');\n\nvar _MongoStorageAdapter2 = _interopRequireDefault(_MongoStorageAdapter);\n\nvar _PostgresStorageAdapter = require('./Adapters/Storage/Postgres/PostgresStorageAdapter');\n\nvar _PostgresStorageAdapter2 = _interopRequireDefault(_PostgresStorageAdapter);\n\nvar _ParseServerRESTController = require('./ParseServerRESTController');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// ParseServer - open-source compatible API Server for Parse apps\n\nvar batch = require('./batch'),\n    bodyParser = require('body-parser'),\n    express = require('express'),\n    middlewares = require('./middlewares'),\n    Parse = require('parse/node').Parse,\n    path = require('path'),\n    url = require('url'),\n    authDataManager = require('./Adapters/Auth');\n\n// Mutate the Parse object to add the Cloud Code handlers\naddParseCloud();\n\n// ParseServer works like a constructor of an express app.\n// The args that we understand are:\n// \"analyticsAdapter\": an adapter class for analytics\n// \"filesAdapter\": a class like GridStoreAdapter providing create, get,\n//                 and delete\n// \"loggerAdapter\": a class like WinstonLoggerAdapter providing info, error,\n//                 and query\n// \"jsonLogs\": log as structured JSON objects\n// \"databaseURI\": a uri like mongodb://localhost:27017/dbname to tell us\n//          what database this Parse API connects to.\n// \"cloud\": relative location to cloud code to require, or a function\n//          that is given an instance of Parse as a parameter.  Use this instance of Parse\n//          to register your cloud code hooks and functions.\n// \"appId\": the application id to host\n// \"masterKey\": the master key for requests to this app\n// \"collectionPrefix\": optional prefix for database collection names\n// \"fileKey\": optional key from Parse dashboard for supporting older files\n//            hosted by Parse\n// \"clientKey\": optional key from Parse dashboard\n// \"dotNetKey\": optional key from Parse dashboard\n// \"restAPIKey\": optional key from Parse dashboard\n// \"webhookKey\": optional key from Parse dashboard\n// \"javascriptKey\": optional key from Parse dashboard\n// \"push\": optional key from configure push\n// \"sessionLength\": optional length in seconds for how long Sessions should be valid for\n\nvar ParseServer = function () {\n  function ParseServer(_ref) {\n    var _ref$appId = _ref.appId,\n        appId = _ref$appId === undefined ? (0, _requiredParameter2.default)('You must provide an appId!') : _ref$appId,\n        _ref$masterKey = _ref.masterKey,\n        masterKey = _ref$masterKey === undefined ? (0, _requiredParameter2.default)('You must provide a masterKey!') : _ref$masterKey,\n        appName = _ref.appName,\n        analyticsAdapter = _ref.analyticsAdapter,\n        filesAdapter = _ref.filesAdapter,\n        push = _ref.push,\n        loggerAdapter = _ref.loggerAdapter,\n        _ref$jsonLogs = _ref.jsonLogs,\n        jsonLogs = _ref$jsonLogs === undefined ? _defaults2.default.jsonLogs : _ref$jsonLogs,\n        _ref$logsFolder = _ref.logsFolder,\n        logsFolder = _ref$logsFolder === undefined ? _defaults2.default.logsFolder : _ref$logsFolder,\n        _ref$verbose = _ref.verbose,\n        verbose = _ref$verbose === undefined ? _defaults2.default.verbose : _ref$verbose,\n        _ref$logLevel = _ref.logLevel,\n        logLevel = _ref$logLevel === undefined ? _defaults2.default.level : _ref$logLevel,\n        _ref$silent = _ref.silent,\n        silent = _ref$silent === undefined ? _defaults2.default.silent : _ref$silent,\n        _ref$databaseURI = _ref.databaseURI,\n        databaseURI = _ref$databaseURI === undefined ? _defaults2.default.DefaultMongoURI : _ref$databaseURI,\n        databaseOptions = _ref.databaseOptions,\n        databaseAdapter = _ref.databaseAdapter,\n        cloud = _ref.cloud,\n        _ref$collectionPrefix = _ref.collectionPrefix,\n        collectionPrefix = _ref$collectionPrefix === undefined ? '' : _ref$collectionPrefix,\n        clientKey = _ref.clientKey,\n        javascriptKey = _ref.javascriptKey,\n        dotNetKey = _ref.dotNetKey,\n        restAPIKey = _ref.restAPIKey,\n        webhookKey = _ref.webhookKey,\n        fileKey = _ref.fileKey,\n        _ref$userSensitiveFie = _ref.userSensitiveFields,\n        userSensitiveFields = _ref$userSensitiveFie === undefined ? [] : _ref$userSensitiveFie,\n        _ref$enableAnonymousU = _ref.enableAnonymousUsers,\n        enableAnonymousUsers = _ref$enableAnonymousU === undefined ? _defaults2.default.enableAnonymousUsers : _ref$enableAnonymousU,\n        _ref$allowClientClass = _ref.allowClientClassCreation,\n        allowClientClassCreation = _ref$allowClientClass === undefined ? _defaults2.default.allowClientClassCreation : _ref$allowClientClass,\n        _ref$oauth = _ref.oauth,\n        oauth = _ref$oauth === undefined ? {} : _ref$oauth,\n        _ref$auth = _ref.auth,\n        auth = _ref$auth === undefined ? {} : _ref$auth,\n        _ref$serverURL = _ref.serverURL,\n        serverURL = _ref$serverURL === undefined ? (0, _requiredParameter2.default)('You must provide a serverURL!') : _ref$serverURL,\n        _ref$maxUploadSize = _ref.maxUploadSize,\n        maxUploadSize = _ref$maxUploadSize === undefined ? _defaults2.default.maxUploadSize : _ref$maxUploadSize,\n        _ref$verifyUserEmails = _ref.verifyUserEmails,\n        verifyUserEmails = _ref$verifyUserEmails === undefined ? _defaults2.default.verifyUserEmails : _ref$verifyUserEmails,\n        _ref$preventLoginWith = _ref.preventLoginWithUnverifiedEmail,\n        preventLoginWithUnverifiedEmail = _ref$preventLoginWith === undefined ? _defaults2.default.preventLoginWithUnverifiedEmail : _ref$preventLoginWith,\n        emailVerifyTokenValidityDuration = _ref.emailVerifyTokenValidityDuration,\n        accountLockout = _ref.accountLockout,\n        passwordPolicy = _ref.passwordPolicy,\n        cacheAdapter = _ref.cacheAdapter,\n        emailAdapter = _ref.emailAdapter,\n        publicServerURL = _ref.publicServerURL,\n        _ref$customPages = _ref.customPages,\n        customPages = _ref$customPages === undefined ? {\n      invalidLink: undefined,\n      verifyEmailSuccess: undefined,\n      choosePassword: undefined,\n      passwordResetSuccess: undefined\n    } : _ref$customPages,\n        _ref$liveQuery = _ref.liveQuery,\n        liveQuery = _ref$liveQuery === undefined ? {} : _ref$liveQuery,\n        _ref$sessionLength = _ref.sessionLength,\n        sessionLength = _ref$sessionLength === undefined ? _defaults2.default.sessionLength : _ref$sessionLength,\n        _ref$expireInactiveSe = _ref.expireInactiveSessions,\n        expireInactiveSessions = _ref$expireInactiveSe === undefined ? _defaults2.default.expireInactiveSessions : _ref$expireInactiveSe,\n        _ref$revokeSessionOnP = _ref.revokeSessionOnPasswordReset,\n        revokeSessionOnPasswordReset = _ref$revokeSessionOnP === undefined ? _defaults2.default.revokeSessionOnPasswordReset : _ref$revokeSessionOnP,\n        _ref$schemaCacheTTL = _ref.schemaCacheTTL,\n        schemaCacheTTL = _ref$schemaCacheTTL === undefined ? _defaults2.default.schemaCacheTTL : _ref$schemaCacheTTL,\n        _ref$enableSingleSche = _ref.enableSingleSchemaCache,\n        enableSingleSchemaCache = _ref$enableSingleSche === undefined ? false : _ref$enableSingleSche,\n        _ref$__indexBuildComp = _ref.__indexBuildCompletionCallbackForTests,\n        __indexBuildCompletionCallbackForTests = _ref$__indexBuildComp === undefined ? function () {} : _ref$__indexBuildComp;\n\n    _classCallCheck(this, ParseServer);\n\n    // Initialize the node client SDK automatically\n    Parse.initialize(appId, javascriptKey || 'unused', masterKey);\n    Parse.serverURL = serverURL;\n    if ((databaseOptions || databaseURI && databaseURI != _defaults2.default.DefaultMongoURI || collectionPrefix !== '') && databaseAdapter) {\n      throw 'You cannot specify both a databaseAdapter and a databaseURI/databaseOptions/collectionPrefix.';\n    } else if (!databaseAdapter) {\n      databaseAdapter = this.getDatabaseAdapter(databaseURI, collectionPrefix, databaseOptions);\n    } else {\n      databaseAdapter = (0, _AdapterLoader.loadAdapter)(databaseAdapter);\n    }\n\n    if (!filesAdapter && !databaseURI) {\n      throw 'When using an explicit database adapter, you must also use an explicit filesAdapter.';\n    }\n\n    userSensitiveFields = Array.from(new Set(userSensitiveFields.concat(_defaults2.default.userSensitiveFields, userSensitiveFields)));\n\n    var loggerControllerAdapter = (0, _AdapterLoader.loadAdapter)(loggerAdapter, _WinstonLoggerAdapter.WinstonLoggerAdapter, { jsonLogs: jsonLogs, logsFolder: logsFolder, verbose: verbose, logLevel: logLevel, silent: silent });\n    var loggerController = new _LoggerController.LoggerController(loggerControllerAdapter, appId);\n    logging.setLogger(loggerController);\n\n    var filesControllerAdapter = (0, _AdapterLoader.loadAdapter)(filesAdapter, function () {\n      return new _GridStoreAdapter.GridStoreAdapter(databaseURI);\n    });\n    var filesController = new _FilesController.FilesController(filesControllerAdapter, appId);\n\n    var pushOptions = Object.assign({}, push);\n    var pushQueueOptions = pushOptions.queueOptions || {};\n    if (pushOptions.queueOptions) {\n      delete pushOptions.queueOptions;\n    }\n    // Pass the push options too as it works with the default\n    var pushAdapter = (0, _AdapterLoader.loadAdapter)(pushOptions && pushOptions.adapter, _parseServerPushAdapter2.default, pushOptions);\n    // We pass the options and the base class for the adatper,\n    // Note that passing an instance would work too\n    var pushController = new _PushController.PushController();\n\n    var hasPushSupport = pushAdapter && push;\n\n    var disablePushWorker = pushQueueOptions.disablePushWorker;\n\n\n    var pushControllerQueue = new _PushQueue.PushQueue(pushQueueOptions);\n    var pushWorker = void 0;\n    if (!disablePushWorker) {\n      pushWorker = new _PushWorker.PushWorker(pushAdapter, pushQueueOptions);\n    }\n\n    var emailControllerAdapter = (0, _AdapterLoader.loadAdapter)(emailAdapter);\n    var userController = new _UserController.UserController(emailControllerAdapter, appId, { verifyUserEmails: verifyUserEmails });\n\n    var cacheControllerAdapter = (0, _AdapterLoader.loadAdapter)(cacheAdapter, _InMemoryCacheAdapter.InMemoryCacheAdapter, { appId: appId });\n    var cacheController = new _CacheController.CacheController(cacheControllerAdapter, appId);\n\n    var analyticsControllerAdapter = (0, _AdapterLoader.loadAdapter)(analyticsAdapter, _AnalyticsAdapter.AnalyticsAdapter);\n    var analyticsController = new _AnalyticsController.AnalyticsController(analyticsControllerAdapter);\n\n    var liveQueryController = new _LiveQueryController.LiveQueryController(liveQuery);\n    var databaseController = new _DatabaseController2.default(databaseAdapter, new _SchemaCache2.default(cacheController, schemaCacheTTL, enableSingleSchemaCache));\n    var hooksController = new _HooksController.HooksController(appId, databaseController, webhookKey);\n\n    var dbInitPromise = databaseController.performInitialization();\n\n    if (Object.keys(oauth).length > 0) {\n      /* eslint-disable no-console */\n      console.warn('oauth option is deprecated and will be removed in a future release, please use auth option instead');\n      if (Object.keys(auth).length > 0) {\n        console.warn('You should use only the auth option.');\n      }\n      /* eslint-enable */\n    }\n\n    auth = Object.assign({}, oauth, auth);\n\n    _cache2.default.put(appId, {\n      appId: appId,\n      masterKey: masterKey,\n      serverURL: serverURL,\n      collectionPrefix: collectionPrefix,\n      clientKey: clientKey,\n      javascriptKey: javascriptKey,\n      dotNetKey: dotNetKey,\n      restAPIKey: restAPIKey,\n      webhookKey: webhookKey,\n      fileKey: fileKey,\n      analyticsController: analyticsController,\n      cacheController: cacheController,\n      filesController: filesController,\n      pushController: pushController,\n      loggerController: loggerController,\n      hooksController: hooksController,\n      userController: userController,\n      verifyUserEmails: verifyUserEmails,\n      preventLoginWithUnverifiedEmail: preventLoginWithUnverifiedEmail,\n      emailVerifyTokenValidityDuration: emailVerifyTokenValidityDuration,\n      accountLockout: accountLockout,\n      passwordPolicy: passwordPolicy,\n      allowClientClassCreation: allowClientClassCreation,\n      authDataManager: authDataManager(auth, enableAnonymousUsers),\n      appName: appName,\n      publicServerURL: publicServerURL,\n      customPages: customPages,\n      maxUploadSize: maxUploadSize,\n      liveQueryController: liveQueryController,\n      sessionLength: Number(sessionLength),\n      expireInactiveSessions: expireInactiveSessions,\n      jsonLogs: jsonLogs,\n      revokeSessionOnPasswordReset: revokeSessionOnPasswordReset,\n      databaseController: databaseController,\n      schemaCacheTTL: schemaCacheTTL,\n      enableSingleSchemaCache: enableSingleSchemaCache,\n      userSensitiveFields: userSensitiveFields,\n      pushWorker: pushWorker,\n      pushControllerQueue: pushControllerQueue,\n      hasPushSupport: hasPushSupport\n    });\n\n    _Config2.default.validate(_cache2.default.get(appId));\n    this.config = _cache2.default.get(appId);\n    _Config2.default.setupPasswordValidator(this.config.passwordPolicy);\n    hooksController.load();\n\n    // Note: Tests will start to fail if any validation happens after this is called.\n    if (process.env.TESTING) {\n      __indexBuildCompletionCallbackForTests(dbInitPromise);\n    }\n\n    if (cloud) {\n      addParseCloud();\n      if (typeof cloud === 'function') {\n        cloud(Parse);\n      } else if (typeof cloud === 'string') {\n        require(path.resolve(process.cwd(), cloud));\n      } else {\n        throw \"argument 'cloud' must either be a string or a function\";\n      }\n    }\n  }\n\n  _createClass(ParseServer, [{\n    key: 'getDatabaseAdapter',\n    value: function getDatabaseAdapter(databaseURI, collectionPrefix, databaseOptions) {\n      var protocol = void 0;\n      try {\n        var parsedURI = url.parse(databaseURI);\n        protocol = parsedURI.protocol ? parsedURI.protocol.toLowerCase() : null;\n      } catch (e) {/* */}\n      switch (protocol) {\n        case 'postgres:':\n          return new _PostgresStorageAdapter2.default({\n            uri: databaseURI,\n            collectionPrefix: collectionPrefix,\n            databaseOptions: databaseOptions\n          });\n        default:\n          return new _MongoStorageAdapter2.default({\n            uri: databaseURI,\n            collectionPrefix: collectionPrefix,\n            mongoOptions: databaseOptions\n          });\n      }\n    }\n  }, {\n    key: 'app',\n    get: function get() {\n      return ParseServer.app(this.config);\n    }\n  }], [{\n    key: 'app',\n    value: function app(_ref2) {\n      var _ref2$maxUploadSize = _ref2.maxUploadSize,\n          maxUploadSize = _ref2$maxUploadSize === undefined ? '20mb' : _ref2$maxUploadSize,\n          appId = _ref2.appId;\n\n      // This app serves the Parse API directly.\n      // It's the equivalent of https://api.parse.com/1 in the hosted Parse API.\n      var api = express();\n      //api.use(\"/apps\", express.static(__dirname + \"/public\"));\n      // File handling needs to be before default middlewares are applied\n      api.use('/', middlewares.allowCrossDomain, new _FilesRouter.FilesRouter().expressRouter({\n        maxUploadSize: maxUploadSize\n      }));\n\n      api.use('/health', function (req, res) {\n        return res.sendStatus(200);\n      });\n\n      api.use('/', bodyParser.urlencoded({ extended: false }), new _PublicAPIRouter.PublicAPIRouter().expressRouter());\n\n      api.use(bodyParser.json({ 'type': '*/*', limit: maxUploadSize }));\n      api.use(middlewares.allowCrossDomain);\n      api.use(middlewares.allowMethodOverride);\n      api.use(middlewares.handleParseHeaders);\n\n      var appRouter = ParseServer.promiseRouter({ appId: appId });\n      api.use(appRouter.expressRouter());\n\n      api.use(middlewares.handleParseErrors);\n\n      //This causes tests to spew some useless warnings, so disable in test\n      if (!process.env.TESTING) {\n        process.on('uncaughtException', function (err) {\n          if (err.code === \"EADDRINUSE\") {\n            // user-friendly message for this common error\n            /* eslint-disable no-console */\n            console.error('Unable to listen on port ' + err.port + '. The port is already in use.');\n            /* eslint-enable no-console */\n            process.exit(0);\n          } else {\n            throw err;\n          }\n        });\n      }\n      if (process.env.PARSE_SERVER_ENABLE_EXPERIMENTAL_DIRECT_ACCESS === '1') {\n        Parse.CoreManager.setRESTController((0, _ParseServerRESTController.ParseServerRESTController)(appId, appRouter));\n      }\n      return api;\n    }\n  }, {\n    key: 'promiseRouter',\n    value: function promiseRouter(_ref3) {\n      var appId = _ref3.appId;\n\n      var routers = [new _ClassesRouter.ClassesRouter(), new _UsersRouter.UsersRouter(), new _SessionsRouter.SessionsRouter(), new _RolesRouter.RolesRouter(), new _AnalyticsRouter.AnalyticsRouter(), new _InstallationsRouter.InstallationsRouter(), new _FunctionsRouter.FunctionsRouter(), new _SchemasRouter.SchemasRouter(), new _PushRouter.PushRouter(), new _LogsRouter.LogsRouter(), new _IAPValidationRouter.IAPValidationRouter(), new _FeaturesRouter.FeaturesRouter(), new _GlobalConfigRouter.GlobalConfigRouter(), new _PurgeRouter.PurgeRouter(), new _HooksRouter.HooksRouter(), new _CloudCodeRouter.CloudCodeRouter()];\n\n      var routes = routers.reduce(function (memo, router) {\n        return memo.concat(router.routes);\n      }, []);\n\n      var appRouter = new _PromiseRouter2.default(routes, appId);\n\n      batch.mountOnto(appRouter);\n      return appRouter;\n    }\n  }, {\n    key: 'createLiveQueryServer',\n    value: function createLiveQueryServer(httpServer, config) {\n      return new _ParseLiveQueryServer.ParseLiveQueryServer(httpServer, config);\n    }\n  }]);\n\n  return ParseServer;\n}();\n\nfunction addParseCloud() {\n  var ParseCloud = require(\"./cloud-code/Parse.Cloud\");\n  Object.assign(Parse.Cloud, ParseCloud);\n  global.Parse = Parse;\n}\n\nexports.default = ParseServer;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/defaults.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _parsers = require('./cli/utils/parsers');\n\nvar logsFolder = function () {\n  var folder = './logs/';\n  if (typeof process !== 'undefined' && process.env.NODE_ENV === 'test') {\n    folder = './test_logs/';\n  }\n  if (process.env.PARSE_SERVER_LOGS_FOLDER) {\n    folder = (0, _parsers.nullParser)(process.env.PARSE_SERVER_LOGS_FOLDER);\n  }\n  return folder;\n}();\n\nvar _ref = function () {\n  var verbose = process.env.VERBOSE ? true : false;\n  return { verbose: verbose, level: verbose ? 'verbose' : undefined };\n}(),\n    verbose = _ref.verbose,\n    level = _ref.level;\n\nexports.default = {\n  DefaultMongoURI: 'mongodb://localhost:27017/parse',\n  jsonLogs: process.env.JSON_LOGS || false,\n  logsFolder: logsFolder,\n  verbose: verbose,\n  level: level,\n  silent: false,\n  enableAnonymousUsers: true,\n  allowClientClassCreation: true,\n  maxUploadSize: '20mb',\n  verifyUserEmails: false,\n  preventLoginWithUnverifiedEmail: false,\n  sessionLength: 31536000,\n  expireInactiveSessions: true,\n  revokeSessionOnPasswordReset: true,\n  schemaCacheTTL: 5000, // in ms\n  userSensitiveFields: ['email']\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/cli/utils/parsers.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.numberParser = numberParser;\nexports.numberOrBoolParser = numberOrBoolParser;\nexports.objectParser = objectParser;\nexports.arrayParser = arrayParser;\nexports.moduleOrObjectParser = moduleOrObjectParser;\nexports.booleanParser = booleanParser;\nexports.nullParser = nullParser;\nfunction numberParser(key) {\n  return function (opt) {\n    var intOpt = parseInt(opt);\n    if (!Number.isInteger(intOpt)) {\n      throw new Error('Key ' + key + ' has invalid value ' + opt);\n    }\n    return intOpt;\n  };\n}\n\nfunction numberOrBoolParser(key) {\n  return function (opt) {\n    if (typeof opt === 'boolean') {\n      return opt;\n    }\n    if (opt === 'true') {\n      return true;\n    }\n    if (opt === 'false') {\n      return false;\n    }\n    return numberParser(key)(opt);\n  };\n}\n\nfunction objectParser(opt) {\n  if ((typeof opt === 'undefined' ? 'undefined' : _typeof(opt)) == 'object') {\n    return opt;\n  }\n  return JSON.parse(opt);\n}\n\nfunction arrayParser(opt) {\n  if (Array.isArray(opt)) {\n    return opt;\n  } else if (typeof opt === 'string') {\n    return opt.split(',');\n  } else {\n    throw new Error(opt + ' should be a comma separated string or an array');\n  }\n}\n\nfunction moduleOrObjectParser(opt) {\n  if ((typeof opt === 'undefined' ? 'undefined' : _typeof(opt)) == 'object') {\n    return opt;\n  }\n  try {\n    return JSON.parse(opt);\n  } catch (e) {/* */}\n  return opt;\n}\n\nfunction booleanParser(opt) {\n  if (opt == true || opt == 'true' || opt == '1') {\n    return true;\n  }\n  return false;\n}\n\nfunction nullParser(opt) {\n  if (opt == 'null') {\n    return null;\n  }\n  return opt;\n}","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/logger.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setLogger = setLogger;\nexports.getLogger = getLogger;\n\nvar _defaults = require('./defaults');\n\nvar _defaults2 = _interopRequireDefault(_defaults);\n\nvar _WinstonLoggerAdapter = require('./Adapters/Logger/WinstonLoggerAdapter');\n\nvar _LoggerController = require('./Controllers/LoggerController');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction defaultLogger() {\n  var adapter = new _WinstonLoggerAdapter.WinstonLoggerAdapter({\n    logsFolder: _defaults2.default.logsFolder,\n    jsonLogs: _defaults2.default.jsonLogs,\n    verbose: _defaults2.default.verbose,\n    silent: _defaults2.default.silent });\n  return new _LoggerController.LoggerController(adapter);\n}\n\nvar logger = defaultLogger();\n\nfunction setLogger(aLogger) {\n  logger = aLogger;\n}\n\nfunction getLogger() {\n  return logger;\n}\n\n// for: `import logger from './logger'`\nObject.defineProperty(module.exports, 'default', {\n  get: getLogger\n});\n\n// for: `import { logger } from './logger'`\nObject.defineProperty(module.exports, 'logger', {\n  get: getLogger\n});","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Logger/WinstonLoggerAdapter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WinstonLoggerAdapter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _LoggerAdapter2 = require('./LoggerAdapter');\n\nvar _WinstonLogger = require('./WinstonLogger');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar MILLISECONDS_IN_A_DAY = 24 * 60 * 60 * 1000;\n\nvar WinstonLoggerAdapter = exports.WinstonLoggerAdapter = function (_LoggerAdapter) {\n  _inherits(WinstonLoggerAdapter, _LoggerAdapter);\n\n  function WinstonLoggerAdapter(options) {\n    _classCallCheck(this, WinstonLoggerAdapter);\n\n    var _this = _possibleConstructorReturn(this, (WinstonLoggerAdapter.__proto__ || Object.getPrototypeOf(WinstonLoggerAdapter)).call(this));\n\n    if (options) {\n      (0, _WinstonLogger.configureLogger)(options);\n    }\n    return _this;\n  }\n\n  _createClass(WinstonLoggerAdapter, [{\n    key: 'log',\n    value: function log() {\n      return _WinstonLogger.logger.log.apply(_WinstonLogger.logger, arguments);\n    }\n  }, {\n    key: 'addTransport',\n    value: function addTransport(transport) {\n      // Note that this is calling addTransport\n      // from logger.  See import - confusing.\n      // but this is not recursive.\n      (0, _WinstonLogger.addTransport)(transport);\n    }\n\n    // custom query as winston is currently limited\n\n  }, {\n    key: 'query',\n    value: function query(options) {\n      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\n      if (!options) {\n        options = {};\n      }\n      // defaults to 7 days prior\n      var from = options.from || new Date(Date.now() - 7 * MILLISECONDS_IN_A_DAY);\n      var until = options.until || new Date();\n      var limit = options.size || 10;\n      var order = options.order || 'desc';\n      var level = options.level || 'info';\n\n      var queryOptions = {\n        from: from,\n        until: until,\n        limit: limit,\n        order: order\n      };\n\n      return new Promise(function (resolve, reject) {\n        _WinstonLogger.logger.query(queryOptions, function (err, res) {\n          if (err) {\n            callback(err);\n            return reject(err);\n          }\n          if (level == 'error') {\n            callback(res['parse-server-error']);\n            resolve(res['parse-server-error']);\n          } else {\n            callback(res['parse-server']);\n            resolve(res['parse-server']);\n          }\n        });\n      });\n    }\n  }]);\n\n  return WinstonLoggerAdapter;\n}(_LoggerAdapter2.LoggerAdapter);\n\nexports.default = WinstonLoggerAdapter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Logger/LoggerAdapter.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*eslint no-unused-vars: \"off\"*/\n// Logger Adapter\n//\n// Allows you to change the logger mechanism\n//\n// Adapter classes must implement the following functions:\n// * log() {}\n// * query(options, callback) /* optional */\n// Default is WinstonLoggerAdapter.js\n\nvar LoggerAdapter = exports.LoggerAdapter = function () {\n  function LoggerAdapter(options) {\n    _classCallCheck(this, LoggerAdapter);\n  }\n\n  _createClass(LoggerAdapter, [{\n    key: \"log\",\n    value: function log(level, message) /* meta */{}\n  }]);\n\n  return LoggerAdapter;\n}();\n\nexports.default = LoggerAdapter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Logger/WinstonLogger.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.logger = undefined;\nexports.configureLogger = configureLogger;\nexports.addTransport = addTransport;\nexports.removeTransport = removeTransport;\n\nvar _winston = require('winston');\n\nvar _winston2 = _interopRequireDefault(_winston);\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _winstonDailyRotateFile = require('winston-daily-rotate-file');\n\nvar _winstonDailyRotateFile2 = _interopRequireDefault(_winstonDailyRotateFile);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _defaults = require('../../defaults');\n\nvar _defaults2 = _interopRequireDefault(_defaults);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar logger = new _winston2.default.Logger();\nvar additionalTransports = [];\n\nfunction updateTransports(options) {\n  var transports = Object.assign({}, logger.transports);\n  if (options) {\n    var silent = options.silent;\n    delete options.silent;\n    if (_lodash2.default.isNull(options.dirname)) {\n      delete transports['parse-server'];\n      delete transports['parse-server-error'];\n    } else if (!_lodash2.default.isUndefined(options.dirname)) {\n      transports['parse-server'] = new _winstonDailyRotateFile2.default(Object.assign({}, {\n        filename: 'parse-server.info',\n        name: 'parse-server'\n      }, options, { timestamp: true }));\n      transports['parse-server-error'] = new _winstonDailyRotateFile2.default(Object.assign({}, {\n        filename: 'parse-server.err',\n        name: 'parse-server-error'\n      }, options, { level: 'error', timestamp: true }));\n    }\n\n    transports.console = new _winston2.default.transports.Console(Object.assign({\n      colorize: true,\n      name: 'console',\n      silent: silent\n    }, options));\n  }\n  // Mount the additional transports\n  additionalTransports.forEach(function (transport) {\n    transports[transport.name] = transport;\n  });\n  logger.configure({\n    transports: _lodash2.default.values(transports)\n  });\n}\n\nfunction configureLogger() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$logsFolder = _ref.logsFolder,\n      logsFolder = _ref$logsFolder === undefined ? _defaults2.default.logsFolder : _ref$logsFolder,\n      _ref$jsonLogs = _ref.jsonLogs,\n      jsonLogs = _ref$jsonLogs === undefined ? _defaults2.default.jsonLogs : _ref$jsonLogs,\n      _ref$logLevel = _ref.logLevel,\n      logLevel = _ref$logLevel === undefined ? _winston2.default.level : _ref$logLevel,\n      _ref$verbose = _ref.verbose,\n      verbose = _ref$verbose === undefined ? _defaults2.default.verbose : _ref$verbose,\n      _ref$silent = _ref.silent,\n      silent = _ref$silent === undefined ? _defaults2.default.silent : _ref$silent;\n\n  if (verbose) {\n    logLevel = 'verbose';\n  }\n\n  _winston2.default.level = logLevel;\n  var options = {};\n\n  if (logsFolder) {\n    if (!_path2.default.isAbsolute(logsFolder)) {\n      logsFolder = _path2.default.resolve(process.cwd(), logsFolder);\n    }\n    try {\n      _fs2.default.mkdirSync(logsFolder);\n    } catch (e) {/* */}\n  }\n  options.dirname = logsFolder;\n  options.level = logLevel;\n  options.silent = silent;\n\n  if (jsonLogs) {\n    options.json = true;\n    options.stringify = true;\n  }\n  updateTransports(options);\n}\n\nfunction addTransport(transport) {\n  additionalTransports.push(transport);\n  updateTransports();\n}\n\nfunction removeTransport(transport) {\n  var transportName = typeof transport == 'string' ? transport : transport.name;\n  var transports = Object.assign({}, logger.transports);\n  delete transports[transportName];\n  logger.configure({\n    transports: _lodash2.default.values(transports)\n  });\n  _lodash2.default.remove(additionalTransports, function (transport) {\n    return transport.name === transportName;\n  });\n}\n\nexports.logger = logger;\nexports.default = logger;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Controllers/LoggerController.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LoggerController = exports.LogOrder = exports.LogLevel = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _node = require('parse/node');\n\nvar _AdaptableController2 = require('./AdaptableController');\n\nvar _AdaptableController3 = _interopRequireDefault(_AdaptableController2);\n\nvar _LoggerAdapter = require('../Adapters/Logger/LoggerAdapter');\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar MILLISECONDS_IN_A_DAY = 24 * 60 * 60 * 1000;\nvar LOG_STRING_TRUNCATE_LENGTH = 1000;\nvar truncationMarker = '... (truncated)';\n\nvar LogLevel = exports.LogLevel = {\n  INFO: 'info',\n  ERROR: 'error'\n};\n\nvar LogOrder = exports.LogOrder = {\n  DESCENDING: 'desc',\n  ASCENDING: 'asc'\n};\n\nvar LoggerController = exports.LoggerController = function (_AdaptableController) {\n  _inherits(LoggerController, _AdaptableController);\n\n  function LoggerController() {\n    _classCallCheck(this, LoggerController);\n\n    return _possibleConstructorReturn(this, (LoggerController.__proto__ || Object.getPrototypeOf(LoggerController)).apply(this, arguments));\n  }\n\n  _createClass(LoggerController, [{\n    key: 'maskSensitiveUrl',\n    value: function maskSensitiveUrl(urlString) {\n      var password = _url2.default.parse(urlString, true).query.password;\n\n      if (password) {\n        urlString = urlString.replace('password=' + password, 'password=********');\n      }\n      return urlString;\n    }\n  }, {\n    key: 'maskSensitive',\n    value: function maskSensitive(argArray) {\n      var _this2 = this;\n\n      return argArray.map(function (e) {\n        if (!e) {\n          return e;\n        }\n\n        if (typeof e === 'string') {\n          return e.replace(/(password\".?:.?\")[^\"]*\"/g, '$1********\"');\n        }\n        // else it is an object...\n\n        // check the url\n        if (e.url) {\n          // for strings\n          if (typeof e.url === 'string') {\n            e.url = _this2.maskSensitiveUrl(e.url);\n          } else if (Array.isArray(e.url)) {\n            // for strings in array\n            e.url = e.url.map(function (item) {\n              if (typeof item === 'string') {\n                return _this2.maskSensitiveUrl(item);\n              }\n\n              return item;\n            });\n          }\n        }\n\n        if (e.body) {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = Object.keys(e.body)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var key = _step.value;\n\n              if (key === 'password') {\n                e.body[key] = '********';\n                break;\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n\n        return e;\n      });\n    }\n  }, {\n    key: 'log',\n    value: function log(level, args) {\n      // make the passed in arguments object an array with the spread operator\n      args = this.maskSensitive([].concat(_toConsumableArray(args)));\n      args = [].concat(level, args);\n      this.adapter.log.apply(this.adapter, args);\n    }\n  }, {\n    key: 'info',\n    value: function info() {\n      return this.log('info', arguments);\n    }\n  }, {\n    key: 'error',\n    value: function error() {\n      return this.log('error', arguments);\n    }\n  }, {\n    key: 'warn',\n    value: function warn() {\n      return this.log('warn', arguments);\n    }\n  }, {\n    key: 'verbose',\n    value: function verbose() {\n      return this.log('verbose', arguments);\n    }\n  }, {\n    key: 'debug',\n    value: function debug() {\n      return this.log('debug', arguments);\n    }\n  }, {\n    key: 'silly',\n    value: function silly() {\n      return this.log('silly', arguments);\n    }\n    // check that date input is valid\n\n  }, {\n    key: 'truncateLogMessage',\n    value: function truncateLogMessage(string) {\n      if (string && string.length > LOG_STRING_TRUNCATE_LENGTH) {\n        var truncated = string.substring(0, LOG_STRING_TRUNCATE_LENGTH) + truncationMarker;\n        return truncated;\n      }\n\n      return string;\n    }\n  }, {\n    key: 'getLogs',\n\n\n    // Returns a promise for a {response} object.\n    // query params:\n    // level (optional) Level of logging you want to query for (info || error)\n    // from (optional) Start time for the search. Defaults to 1 week ago.\n    // until (optional) End time for the search. Defaults to current time.\n    // order (optional) Direction of results returned, either asc or desc. Defaults to desc.\n    // size (optional) Number of rows returned by search. Defaults to 10\n    value: function getLogs() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this.adapter) {\n        throw new _node.Parse.Error(_node.Parse.Error.PUSH_MISCONFIGURED, 'Logger adapter is not available');\n      }\n      if (typeof this.adapter.query !== 'function') {\n        throw new _node.Parse.Error(_node.Parse.Error.PUSH_MISCONFIGURED, 'Querying logs is not supported with this adapter');\n      }\n      options = LoggerController.parseOptions(options);\n      return this.adapter.query(options);\n    }\n  }, {\n    key: 'expectedAdapterType',\n    value: function expectedAdapterType() {\n      return _LoggerAdapter.LoggerAdapter;\n    }\n  }], [{\n    key: 'validDateTime',\n    value: function validDateTime(date) {\n      if (!date) {\n        return null;\n      }\n      date = new Date(date);\n\n      if (!isNaN(date.getTime())) {\n        return date;\n      }\n\n      return null;\n    }\n  }, {\n    key: 'parseOptions',\n    value: function parseOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var from = LoggerController.validDateTime(options.from) || new Date(Date.now() - 7 * MILLISECONDS_IN_A_DAY);\n      var until = LoggerController.validDateTime(options.until) || new Date();\n      var size = Number(options.size) || 10;\n      var order = options.order || LogOrder.DESCENDING;\n      var level = options.level || LogLevel.INFO;\n\n      return {\n        from: from,\n        until: until,\n        size: size,\n        order: order,\n        level: level\n      };\n    }\n  }]);\n\n  return LoggerController;\n}(_AdaptableController3.default);\n\nexports.default = LoggerController;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Controllers/AdaptableController.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AdaptableController = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Config = require(\"../Config\");\n\nvar _Config2 = _interopRequireDefault(_Config);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\nAdaptableController.js\n\nAdaptableController is the base class for all controllers\nthat support adapter,\nThe super class takes care of creating the right instance for the adapter\nbased on the parameters passed\n\n */\n\n// _adapter is private, use Symbol\nvar _adapter = Symbol();\n\nvar AdaptableController = exports.AdaptableController = function () {\n  function AdaptableController(adapter, appId, options) {\n    _classCallCheck(this, AdaptableController);\n\n    this.options = options;\n    this.appId = appId;\n    this.adapter = adapter;\n  }\n\n  _createClass(AdaptableController, [{\n    key: \"expectedAdapterType\",\n    value: function expectedAdapterType() {\n      throw new Error(\"Subclasses should implement expectedAdapterType()\");\n    }\n  }, {\n    key: \"validateAdapter\",\n    value: function validateAdapter(adapter) {\n      AdaptableController.validateAdapter(adapter, this);\n    }\n  }, {\n    key: \"adapter\",\n    set: function set(adapter) {\n      this.validateAdapter(adapter);\n      this[_adapter] = adapter;\n    },\n    get: function get() {\n      return this[_adapter];\n    }\n  }, {\n    key: \"config\",\n    get: function get() {\n      return new _Config2.default(this.appId);\n    }\n  }], [{\n    key: \"validateAdapter\",\n    value: function validateAdapter(adapter, self, ExpectedType) {\n      if (!adapter) {\n        throw new Error(this.constructor.name + \" requires an adapter\");\n      }\n\n      var Type = ExpectedType || self.expectedAdapterType();\n      // Allow skipping for testing\n      if (!Type) {\n        return;\n      }\n\n      // Makes sure the prototype matches\n      var mismatches = Object.getOwnPropertyNames(Type.prototype).reduce(function (obj, key) {\n        var adapterType = _typeof(adapter[key]);\n        var expectedType = _typeof(Type.prototype[key]);\n        if (adapterType !== expectedType) {\n          obj[key] = {\n            expected: expectedType,\n            actual: adapterType\n          };\n        }\n        return obj;\n      }, {});\n\n      if (Object.keys(mismatches).length > 0) {\n        throw new Error(\"Adapter prototype don't match expected prototype\", adapter, mismatches);\n      }\n    }\n  }]);\n\n  return AdaptableController;\n}();\n\nexports.default = AdaptableController;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Config.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Config = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // A Config object provides information about how a specific app is\n// configured.\n// mount is the URL for the root of the API; includes http, domain, etc.\n\nvar _cache = require('./cache');\n\nvar _cache2 = _interopRequireDefault(_cache);\n\nvar _SchemaCache = require('./Controllers/SchemaCache');\n\nvar _SchemaCache2 = _interopRequireDefault(_SchemaCache);\n\nvar _DatabaseController = require('./Controllers/DatabaseController');\n\nvar _DatabaseController2 = _interopRequireDefault(_DatabaseController);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction removeTrailingSlash(str) {\n  if (!str) {\n    return str;\n  }\n  if (str.endsWith(\"/\")) {\n    str = str.substr(0, str.length - 1);\n  }\n  return str;\n}\n\nvar Config = exports.Config = function () {\n  function Config(applicationId, mount) {\n    _classCallCheck(this, Config);\n\n    var cacheInfo = _cache2.default.get(applicationId);\n    if (!cacheInfo) {\n      return;\n    }\n\n    this.applicationId = applicationId;\n    this.jsonLogs = cacheInfo.jsonLogs;\n    this.masterKey = cacheInfo.masterKey;\n    this.clientKey = cacheInfo.clientKey;\n    this.javascriptKey = cacheInfo.javascriptKey;\n    this.dotNetKey = cacheInfo.dotNetKey;\n    this.restAPIKey = cacheInfo.restAPIKey;\n    this.webhookKey = cacheInfo.webhookKey;\n    this.fileKey = cacheInfo.fileKey;\n    this.allowClientClassCreation = cacheInfo.allowClientClassCreation;\n    this.userSensitiveFields = cacheInfo.userSensitiveFields;\n\n    // Create a new DatabaseController per request\n    if (cacheInfo.databaseController) {\n      var schemaCache = new _SchemaCache2.default(cacheInfo.cacheController, cacheInfo.schemaCacheTTL, cacheInfo.enableSingleSchemaCache);\n      this.database = new _DatabaseController2.default(cacheInfo.databaseController.adapter, schemaCache);\n    }\n\n    this.schemaCacheTTL = cacheInfo.schemaCacheTTL;\n    this.enableSingleSchemaCache = cacheInfo.enableSingleSchemaCache;\n\n    this.serverURL = cacheInfo.serverURL;\n    this.publicServerURL = removeTrailingSlash(cacheInfo.publicServerURL);\n    this.verifyUserEmails = cacheInfo.verifyUserEmails;\n    this.preventLoginWithUnverifiedEmail = cacheInfo.preventLoginWithUnverifiedEmail;\n    this.emailVerifyTokenValidityDuration = cacheInfo.emailVerifyTokenValidityDuration;\n    this.accountLockout = cacheInfo.accountLockout;\n    this.passwordPolicy = cacheInfo.passwordPolicy;\n    this.appName = cacheInfo.appName;\n\n    this.analyticsController = cacheInfo.analyticsController;\n    this.cacheController = cacheInfo.cacheController;\n    this.hooksController = cacheInfo.hooksController;\n    this.filesController = cacheInfo.filesController;\n    this.pushController = cacheInfo.pushController;\n    this.pushControllerQueue = cacheInfo.pushControllerQueue;\n    this.pushWorker = cacheInfo.pushWorker;\n    this.hasPushSupport = cacheInfo.hasPushSupport;\n    this.loggerController = cacheInfo.loggerController;\n    this.userController = cacheInfo.userController;\n    this.authDataManager = cacheInfo.authDataManager;\n    this.customPages = cacheInfo.customPages || {};\n    this.mount = removeTrailingSlash(mount);\n    this.liveQueryController = cacheInfo.liveQueryController;\n    this.sessionLength = cacheInfo.sessionLength;\n    this.expireInactiveSessions = cacheInfo.expireInactiveSessions;\n    this.generateSessionExpiresAt = this.generateSessionExpiresAt.bind(this);\n    this.generateEmailVerifyTokenExpiresAt = this.generateEmailVerifyTokenExpiresAt.bind(this);\n    this.revokeSessionOnPasswordReset = cacheInfo.revokeSessionOnPasswordReset;\n  }\n\n  _createClass(Config, [{\n    key: 'generateEmailVerifyTokenExpiresAt',\n    value: function generateEmailVerifyTokenExpiresAt() {\n      if (!this.verifyUserEmails || !this.emailVerifyTokenValidityDuration) {\n        return undefined;\n      }\n      var now = new Date();\n      return new Date(now.getTime() + this.emailVerifyTokenValidityDuration * 1000);\n    }\n  }, {\n    key: 'generatePasswordResetTokenExpiresAt',\n    value: function generatePasswordResetTokenExpiresAt() {\n      if (!this.passwordPolicy || !this.passwordPolicy.resetTokenValidityDuration) {\n        return undefined;\n      }\n      var now = new Date();\n      return new Date(now.getTime() + this.passwordPolicy.resetTokenValidityDuration * 1000);\n    }\n  }, {\n    key: 'generateSessionExpiresAt',\n    value: function generateSessionExpiresAt() {\n      if (!this.expireInactiveSessions) {\n        return undefined;\n      }\n      var now = new Date();\n      return new Date(now.getTime() + this.sessionLength * 1000);\n    }\n  }, {\n    key: 'mount',\n    get: function get() {\n      var mount = this._mount;\n      if (this.publicServerURL) {\n        mount = this.publicServerURL;\n      }\n      return mount;\n    },\n    set: function set(newValue) {\n      this._mount = newValue;\n    }\n  }, {\n    key: 'invalidLinkURL',\n    get: function get() {\n      return this.customPages.invalidLink || this.publicServerURL + '/apps/invalid_link.html';\n    }\n  }, {\n    key: 'verifyEmailSuccessURL',\n    get: function get() {\n      return this.customPages.verifyEmailSuccess || this.publicServerURL + '/apps/verify_email_success.html';\n    }\n  }, {\n    key: 'choosePasswordURL',\n    get: function get() {\n      return this.customPages.choosePassword || this.publicServerURL + '/apps/choose_password';\n    }\n  }, {\n    key: 'requestResetPasswordURL',\n    get: function get() {\n      return this.publicServerURL + '/apps/' + this.applicationId + '/request_password_reset';\n    }\n  }, {\n    key: 'passwordResetSuccessURL',\n    get: function get() {\n      return this.customPages.passwordResetSuccess || this.publicServerURL + '/apps/password_reset_success.html';\n    }\n  }, {\n    key: 'parseFrameURL',\n    get: function get() {\n      return this.customPages.parseFrameURL;\n    }\n  }, {\n    key: 'verifyEmailURL',\n    get: function get() {\n      return this.publicServerURL + '/apps/' + this.applicationId + '/verify_email';\n    }\n  }], [{\n    key: 'validate',\n    value: function validate(_ref) {\n      var verifyUserEmails = _ref.verifyUserEmails,\n          userController = _ref.userController,\n          appName = _ref.appName,\n          publicServerURL = _ref.publicServerURL,\n          revokeSessionOnPasswordReset = _ref.revokeSessionOnPasswordReset,\n          expireInactiveSessions = _ref.expireInactiveSessions,\n          sessionLength = _ref.sessionLength,\n          emailVerifyTokenValidityDuration = _ref.emailVerifyTokenValidityDuration,\n          accountLockout = _ref.accountLockout,\n          passwordPolicy = _ref.passwordPolicy;\n\n      var emailAdapter = userController.adapter;\n      if (verifyUserEmails) {\n        this.validateEmailConfiguration({ emailAdapter: emailAdapter, appName: appName, publicServerURL: publicServerURL, emailVerifyTokenValidityDuration: emailVerifyTokenValidityDuration });\n      }\n\n      this.validateAccountLockoutPolicy(accountLockout);\n\n      this.validatePasswordPolicy(passwordPolicy);\n\n      if (typeof revokeSessionOnPasswordReset !== 'boolean') {\n        throw 'revokeSessionOnPasswordReset must be a boolean value';\n      }\n\n      if (publicServerURL) {\n        if (!publicServerURL.startsWith(\"http://\") && !publicServerURL.startsWith(\"https://\")) {\n          throw \"publicServerURL should be a valid HTTPS URL starting with https://\";\n        }\n      }\n\n      this.validateSessionConfiguration(sessionLength, expireInactiveSessions);\n    }\n  }, {\n    key: 'validateAccountLockoutPolicy',\n    value: function validateAccountLockoutPolicy(accountLockout) {\n      if (accountLockout) {\n        if (typeof accountLockout.duration !== 'number' || accountLockout.duration <= 0 || accountLockout.duration > 99999) {\n          throw 'Account lockout duration should be greater than 0 and less than 100000';\n        }\n\n        if (!Number.isInteger(accountLockout.threshold) || accountLockout.threshold < 1 || accountLockout.threshold > 999) {\n          throw 'Account lockout threshold should be an integer greater than 0 and less than 1000';\n        }\n      }\n    }\n  }, {\n    key: 'validatePasswordPolicy',\n    value: function validatePasswordPolicy(passwordPolicy) {\n      if (passwordPolicy) {\n        if (passwordPolicy.maxPasswordAge !== undefined && (typeof passwordPolicy.maxPasswordAge !== 'number' || passwordPolicy.maxPasswordAge < 0)) {\n          throw 'passwordPolicy.maxPasswordAge must be a positive number';\n        }\n\n        if (passwordPolicy.resetTokenValidityDuration !== undefined && (typeof passwordPolicy.resetTokenValidityDuration !== 'number' || passwordPolicy.resetTokenValidityDuration <= 0)) {\n          throw 'passwordPolicy.resetTokenValidityDuration must be a positive number';\n        }\n\n        if (passwordPolicy.validatorPattern) {\n          if (typeof passwordPolicy.validatorPattern === 'string') {\n            passwordPolicy.validatorPattern = new RegExp(passwordPolicy.validatorPattern);\n          } else if (!(passwordPolicy.validatorPattern instanceof RegExp)) {\n            throw 'passwordPolicy.validatorPattern must be a regex string or RegExp object.';\n          }\n        }\n\n        if (passwordPolicy.validatorCallback && typeof passwordPolicy.validatorCallback !== 'function') {\n          throw 'passwordPolicy.validatorCallback must be a function.';\n        }\n\n        if (passwordPolicy.doNotAllowUsername && typeof passwordPolicy.doNotAllowUsername !== 'boolean') {\n          throw 'passwordPolicy.doNotAllowUsername must be a boolean value.';\n        }\n\n        if (passwordPolicy.maxPasswordHistory && (!Number.isInteger(passwordPolicy.maxPasswordHistory) || passwordPolicy.maxPasswordHistory <= 0 || passwordPolicy.maxPasswordHistory > 20)) {\n          throw 'passwordPolicy.maxPasswordHistory must be an integer ranging 0 - 20';\n        }\n      }\n    }\n\n    // if the passwordPolicy.validatorPattern is configured then setup a callback to process the pattern\n\n  }, {\n    key: 'setupPasswordValidator',\n    value: function setupPasswordValidator(passwordPolicy) {\n      if (passwordPolicy && passwordPolicy.validatorPattern) {\n        passwordPolicy.patternValidator = function (value) {\n          return passwordPolicy.validatorPattern.test(value);\n        };\n      }\n    }\n  }, {\n    key: 'validateEmailConfiguration',\n    value: function validateEmailConfiguration(_ref2) {\n      var emailAdapter = _ref2.emailAdapter,\n          appName = _ref2.appName,\n          publicServerURL = _ref2.publicServerURL,\n          emailVerifyTokenValidityDuration = _ref2.emailVerifyTokenValidityDuration;\n\n      if (!emailAdapter) {\n        throw 'An emailAdapter is required for e-mail verification and password resets.';\n      }\n      if (typeof appName !== 'string') {\n        throw 'An app name is required for e-mail verification and password resets.';\n      }\n      if (typeof publicServerURL !== 'string') {\n        throw 'A public server url is required for e-mail verification and password resets.';\n      }\n      if (emailVerifyTokenValidityDuration) {\n        if (isNaN(emailVerifyTokenValidityDuration)) {\n          throw 'Email verify token validity duration must be a valid number.';\n        } else if (emailVerifyTokenValidityDuration <= 0) {\n          throw 'Email verify token validity duration must be a value greater than 0.';\n        }\n      }\n    }\n  }, {\n    key: 'validateSessionConfiguration',\n    value: function validateSessionConfiguration(sessionLength, expireInactiveSessions) {\n      if (expireInactiveSessions) {\n        if (isNaN(sessionLength)) {\n          throw 'Session length must be a valid number.';\n        } else if (sessionLength <= 0) {\n          throw 'Session length must be a value greater than 0.';\n        }\n      }\n    }\n  }]);\n\n  return Config;\n}();\n\nexports.default = Config;\n\nmodule.exports = Config;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/cache.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AppCache = undefined;\n\nvar _InMemoryCache = require('./Adapters/Cache/InMemoryCache');\n\nvar AppCache = exports.AppCache = new _InMemoryCache.InMemoryCache({ ttl: NaN });\nexports.default = AppCache;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Cache/InMemoryCache.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DEFAULT_CACHE_TTL = 5 * 1000;\n\nvar InMemoryCache = exports.InMemoryCache = function () {\n  function InMemoryCache(_ref) {\n    var _ref$ttl = _ref.ttl,\n        ttl = _ref$ttl === undefined ? DEFAULT_CACHE_TTL : _ref$ttl;\n\n    _classCallCheck(this, InMemoryCache);\n\n    this.ttl = ttl;\n    this.cache = Object.create(null);\n  }\n\n  _createClass(InMemoryCache, [{\n    key: \"get\",\n    value: function get(key) {\n      var record = this.cache[key];\n      if (record == null) {\n        return null;\n      }\n\n      // Has Record and isnt expired\n      if (isNaN(record.expire) || record.expire >= Date.now()) {\n        return record.value;\n      }\n\n      // Record has expired\n      delete this.cache[key];\n      return null;\n    }\n  }, {\n    key: \"put\",\n    value: function put(key, value) {\n      var _this = this;\n\n      var ttl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.ttl;\n\n      if (ttl < 0 || isNaN(ttl)) {\n        ttl = NaN;\n      }\n\n      var record = {\n        value: value,\n        expire: ttl + Date.now()\n      };\n\n      if (!isNaN(record.expire)) {\n        record.timeout = setTimeout(function () {\n          _this.del(key);\n        }, ttl);\n      }\n\n      this.cache[key] = record;\n    }\n  }, {\n    key: \"del\",\n    value: function del(key) {\n      var record = this.cache[key];\n      if (record == null) {\n        return;\n      }\n\n      if (record.timeout) {\n        clearTimeout(record.timeout);\n      }\n      delete this.cache[key];\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.cache = Object.create(null);\n    }\n  }]);\n\n  return InMemoryCache;\n}();\n\nexports.default = InMemoryCache;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Controllers/SchemaCache.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _cryptoUtils = require(\"../cryptoUtils\");\n\nvar _defaults = require(\"../defaults\");\n\nvar _defaults2 = _interopRequireDefault(_defaults);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MAIN_SCHEMA = \"__MAIN_SCHEMA\";\nvar SCHEMA_CACHE_PREFIX = \"__SCHEMA\";\nvar ALL_KEYS = \"__ALL_KEYS\";\n\nvar SchemaCache = function () {\n  function SchemaCache(cacheController) {\n    var ttl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaults2.default.schemaCacheTTL;\n    var singleCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    _classCallCheck(this, SchemaCache);\n\n    this.ttl = ttl;\n    if (typeof ttl == 'string') {\n      this.ttl = parseInt(ttl);\n    }\n    this.cache = cacheController;\n    this.prefix = SCHEMA_CACHE_PREFIX;\n    if (!singleCache) {\n      this.prefix += (0, _cryptoUtils.randomString)(20);\n    }\n  }\n\n  _createClass(SchemaCache, [{\n    key: \"put\",\n    value: function put(key, value) {\n      var _this = this;\n\n      return this.cache.get(this.prefix + ALL_KEYS).then(function (allKeys) {\n        allKeys = allKeys || {};\n        allKeys[key] = true;\n        return Promise.all([_this.cache.put(_this.prefix + ALL_KEYS, allKeys, _this.ttl), _this.cache.put(key, value, _this.ttl)]);\n      });\n    }\n  }, {\n    key: \"getAllClasses\",\n    value: function getAllClasses() {\n      if (!this.ttl) {\n        return Promise.resolve(null);\n      }\n      return this.cache.get(this.prefix + MAIN_SCHEMA);\n    }\n  }, {\n    key: \"setAllClasses\",\n    value: function setAllClasses(schema) {\n      if (!this.ttl) {\n        return Promise.resolve(null);\n      }\n      return this.put(this.prefix + MAIN_SCHEMA, schema);\n    }\n  }, {\n    key: \"setOneSchema\",\n    value: function setOneSchema(className, schema) {\n      if (!this.ttl) {\n        return Promise.resolve(null);\n      }\n      return this.put(this.prefix + className, schema);\n    }\n  }, {\n    key: \"getOneSchema\",\n    value: function getOneSchema(className) {\n      var _this2 = this;\n\n      if (!this.ttl) {\n        return Promise.resolve(null);\n      }\n      return this.cache.get(this.prefix + className).then(function (schema) {\n        if (schema) {\n          return Promise.resolve(schema);\n        }\n        return _this2.cache.get(_this2.prefix + MAIN_SCHEMA).then(function (cachedSchemas) {\n          cachedSchemas = cachedSchemas || [];\n          schema = cachedSchemas.find(function (cachedSchema) {\n            return cachedSchema.className === className;\n          });\n          if (schema) {\n            return Promise.resolve(schema);\n          }\n          return Promise.resolve(null);\n        });\n      });\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this3 = this;\n\n      // That clears all caches...\n      return this.cache.get(this.prefix + ALL_KEYS).then(function (allKeys) {\n        if (!allKeys) {\n          return;\n        }\n        var promises = Object.keys(allKeys).map(function (key) {\n          return _this3.cache.del(key);\n        });\n        return Promise.all(promises);\n      });\n    }\n  }]);\n\n  return SchemaCache;\n}();\n\nexports.default = SchemaCache;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/cryptoUtils.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.randomHexString = randomHexString;\nexports.randomString = randomString;\nexports.newObjectId = newObjectId;\nexports.newToken = newToken;\nexports.md5Hash = md5Hash;\n\nvar _crypto = require('crypto');\n\n// Returns a new random hex string of the given even size.\nfunction randomHexString(size) {\n  if (size === 0) {\n    throw new Error('Zero-length randomHexString is useless.');\n  }\n  if (size % 2 !== 0) {\n    throw new Error('randomHexString size must be divisible by 2.');\n  }\n  return (0, _crypto.randomBytes)(size / 2).toString('hex');\n}\n\n// Returns a new random alphanumeric string of the given size.\n//\n// Note: to simplify implementation, the result has slight modulo bias,\n// because chars length of 62 doesn't divide the number of all bytes\n// (256) evenly. Such bias is acceptable for most cases when the output\n// length is long enough and doesn't need to be uniform.\n\n\nfunction randomString(size) {\n  if (size === 0) {\n    throw new Error('Zero-length randomString is useless.');\n  }\n  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789';\n  var objectId = '';\n  var bytes = (0, _crypto.randomBytes)(size);\n  for (var i = 0; i < bytes.length; ++i) {\n    objectId += chars[bytes.readUInt8(i) % chars.length];\n  }\n  return objectId;\n}\n\n// Returns a new random alphanumeric string suitable for object ID.\nfunction newObjectId() {\n  //TODO: increase length to better protect against collisions.\n  return randomString(10);\n}\n\n// Returns a new random hex string suitable for secure tokens.\nfunction newToken() {\n  return randomHexString(32);\n}\n\nfunction md5Hash(string) {\n  return (0, _crypto.createHash)('md5').update(string).digest('hex');\n}","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Controllers/DatabaseController.js":"'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _node = require('parse/node');\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _intersect = require('intersect');\n\nvar _intersect2 = _interopRequireDefault(_intersect);\n\nvar _deepcopy = require('deepcopy');\n\nvar _deepcopy2 = _interopRequireDefault(_deepcopy);\n\nvar _logger = require('../logger');\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nvar _SchemaController = require('./SchemaController');\n\nvar SchemaController = _interopRequireWildcard(_SchemaController);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } // A database adapter that works with data exported from the hosted\n// Parse database.\n\nfunction addWriteACL(query, acl) {\n  var newQuery = _lodash2.default.cloneDeep(query);\n  //Can't be any existing '_wperm' query, we don't allow client queries on that, no need to $and\n  newQuery._wperm = { \"$in\": [null].concat(_toConsumableArray(acl)) };\n  return newQuery;\n}\n\nfunction addReadACL(query, acl) {\n  var newQuery = _lodash2.default.cloneDeep(query);\n  //Can't be any existing '_rperm' query, we don't allow client queries on that, no need to $and\n  newQuery._rperm = { \"$in\": [null, \"*\"].concat(_toConsumableArray(acl)) };\n  return newQuery;\n}\n\n// Transforms a REST API formatted ACL object to our two-field mongo format.\nvar transformObjectACL = function transformObjectACL(_ref) {\n  var ACL = _ref.ACL,\n      result = _objectWithoutProperties(_ref, ['ACL']);\n\n  if (!ACL) {\n    return result;\n  }\n\n  result._wperm = [];\n  result._rperm = [];\n\n  for (var entry in ACL) {\n    if (ACL[entry].read) {\n      result._rperm.push(entry);\n    }\n    if (ACL[entry].write) {\n      result._wperm.push(entry);\n    }\n  }\n  return result;\n};\n\nvar specialQuerykeys = ['$and', '$or', '_rperm', '_wperm', '_perishable_token', '_email_verify_token', '_email_verify_token_expires_at', '_account_lockout_expires_at', '_failed_login_count'];\n\nvar isSpecialQueryKey = function isSpecialQueryKey(key) {\n  return specialQuerykeys.indexOf(key) >= 0;\n};\n\nvar validateQuery = function validateQuery(query) {\n  if (query.ACL) {\n    throw new _node.Parse.Error(_node.Parse.Error.INVALID_QUERY, 'Cannot query on ACL.');\n  }\n\n  if (query.$or) {\n    if (query.$or instanceof Array) {\n      query.$or.forEach(validateQuery);\n\n      /* In MongoDB, $or queries which are not alone at the top level of the\n       * query can not make efficient use of indexes due to a long standing\n       * bug known as SERVER-13732.\n       *\n       * This block restructures queries in which $or is not the sole top\n       * level element by moving all other top-level predicates inside every\n       * subdocument of the $or predicate, allowing MongoDB's query planner\n       * to make full use of the most relevant indexes.\n       *\n       * EG:      {$or: [{a: 1}, {a: 2}], b: 2}\n       * Becomes: {$or: [{a: 1, b: 2}, {a: 2, b: 2}]}\n       *\n       * https://jira.mongodb.org/browse/SERVER-13732\n       */\n      Object.keys(query).forEach(function (key) {\n        var noCollisions = !query.$or.some(function (subq) {\n          return subq.hasOwnProperty(key);\n        });\n        if (key != '$or' && noCollisions) {\n          query.$or.forEach(function (subquery) {\n            subquery[key] = query[key];\n          });\n          delete query[key];\n        }\n      });\n    } else {\n      throw new _node.Parse.Error(_node.Parse.Error.INVALID_QUERY, 'Bad $or format - use an array value.');\n    }\n  }\n\n  if (query.$and) {\n    if (query.$and instanceof Array) {\n      query.$and.forEach(validateQuery);\n    } else {\n      throw new _node.Parse.Error(_node.Parse.Error.INVALID_QUERY, 'Bad $and format - use an array value.');\n    }\n  }\n\n  Object.keys(query).forEach(function (key) {\n    if (query && query[key] && query[key].$regex) {\n      if (typeof query[key].$options === 'string') {\n        if (!query[key].$options.match(/^[imxs]+$/)) {\n          throw new _node.Parse.Error(_node.Parse.Error.INVALID_QUERY, 'Bad $options value for query: ' + query[key].$options);\n        }\n      }\n    }\n    if (!isSpecialQueryKey(key) && !key.match(/^[a-zA-Z][a-zA-Z0-9_\\.]*$/)) {\n      throw new _node.Parse.Error(_node.Parse.Error.INVALID_KEY_NAME, 'Invalid key name: ' + key);\n    }\n  });\n};\n\nfunction DatabaseController(adapter, schemaCache) {\n  this.adapter = adapter;\n  this.schemaCache = schemaCache;\n  // We don't want a mutable this.schema, because then you could have\n  // one request that uses different schemas for different parts of\n  // it. Instead, use loadSchema to get a schema.\n  this.schemaPromise = null;\n}\n\nDatabaseController.prototype.collectionExists = function (className) {\n  return this.adapter.classExists(className);\n};\n\nDatabaseController.prototype.purgeCollection = function (className) {\n  var _this = this;\n\n  return this.loadSchema().then(function (schemaController) {\n    return schemaController.getOneSchema(className);\n  }).then(function (schema) {\n    return _this.adapter.deleteObjectsByQuery(className, schema, {});\n  });\n};\n\nDatabaseController.prototype.validateClassName = function (className) {\n  if (!SchemaController.classNameIsValid(className)) {\n    return Promise.reject(new _node.Parse.Error(_node.Parse.Error.INVALID_CLASS_NAME, 'invalid className: ' + className));\n  }\n  return Promise.resolve();\n};\n\n// Returns a promise for a schemaController.\nDatabaseController.prototype.loadSchema = function () {\n  var _this2 = this;\n\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { clearCache: false };\n\n  if (!this.schemaPromise) {\n    this.schemaPromise = SchemaController.load(this.adapter, this.schemaCache, options);\n    this.schemaPromise.then(function () {\n      return delete _this2.schemaPromise;\n    }, function () {\n      return delete _this2.schemaPromise;\n    });\n  }\n  return this.schemaPromise;\n};\n\n// Returns a promise for the classname that is related to the given\n// classname through the key.\n// TODO: make this not in the DatabaseController interface\nDatabaseController.prototype.redirectClassNameForKey = function (className, key) {\n  return this.loadSchema().then(function (schema) {\n    var t = schema.getExpectedType(className, key);\n    if (t && t.type == 'Relation') {\n      return t.targetClass;\n    } else {\n      return className;\n    }\n  });\n};\n\n// Uses the schema to validate the object (REST API format).\n// Returns a promise that resolves to the new schema.\n// This does not update this.schema, because in a situation like a\n// batch request, that could confuse other users of the schema.\nDatabaseController.prototype.validateObject = function (className, object, query, _ref2) {\n  var _this3 = this;\n\n  var acl = _ref2.acl;\n\n  var schema = void 0;\n  var isMaster = acl === undefined;\n  var aclGroup = acl || [];\n  return this.loadSchema().then(function (s) {\n    schema = s;\n    if (isMaster) {\n      return Promise.resolve();\n    }\n    return _this3.canAddField(schema, className, object, aclGroup);\n  }).then(function () {\n    return schema.validateObject(className, object, query);\n  });\n};\n\n// Filters out any data that shouldn't be on this REST-formatted object.\nvar filterSensitiveData = function filterSensitiveData(isMaster, aclGroup, className, object) {\n  if (className !== '_User') {\n    return object;\n  }\n\n  object.password = object._hashed_password;\n  delete object._hashed_password;\n\n  delete object.sessionToken;\n\n  if (isMaster) {\n    return object;\n  }\n  delete object._email_verify_token;\n  delete object._perishable_token;\n  delete object._perishable_token_expires_at;\n  delete object._tombstone;\n  delete object._email_verify_token_expires_at;\n  delete object._failed_login_count;\n  delete object._account_lockout_expires_at;\n  delete object._password_changed_at;\n\n  if (aclGroup.indexOf(object.objectId) > -1) {\n    return object;\n  }\n  delete object.authData;\n  return object;\n};\n\n// Runs an update on the database.\n// Returns a promise for an object with the new values for field\n// modifications that don't know their results ahead of time, like\n// 'increment'.\n// Options:\n//   acl:  a list of strings. If the object to be updated has an ACL,\n//         one of the provided strings must provide the caller with\n//         write permissions.\nvar specialKeysForUpdate = ['_hashed_password', '_perishable_token', '_email_verify_token', '_email_verify_token_expires_at', '_account_lockout_expires_at', '_failed_login_count', '_perishable_token_expires_at', '_password_changed_at', '_password_history'];\n\nvar isSpecialUpdateKey = function isSpecialUpdateKey(key) {\n  return specialKeysForUpdate.indexOf(key) >= 0;\n};\n\nDatabaseController.prototype.update = function (className, query, update) {\n  var _this4 = this;\n\n  var _ref3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      acl = _ref3.acl,\n      many = _ref3.many,\n      upsert = _ref3.upsert;\n\n  var skipSanitization = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  var originalUpdate = update;\n  // Make a copy of the object, so we don't mutate the incoming data.\n  update = (0, _deepcopy2.default)(update);\n\n  var isMaster = acl === undefined;\n  var aclGroup = acl || [];\n  return this.loadSchema().then(function (schemaController) {\n    return (isMaster ? Promise.resolve() : schemaController.validatePermission(className, aclGroup, 'update')).then(function () {\n      return _this4.handleRelationUpdates(className, query.objectId, update);\n    }).then(function () {\n      if (!isMaster) {\n        query = _this4.addPointerPermissions(schemaController, className, 'update', query, aclGroup);\n      }\n      if (!query) {\n        return Promise.resolve();\n      }\n      if (acl) {\n        query = addWriteACL(query, acl);\n      }\n      validateQuery(query);\n      return schemaController.getOneSchema(className, true).catch(function (error) {\n        // If the schema doesn't exist, pretend it exists with no fields. This behaviour\n        // will likely need revisiting.\n        if (error === undefined) {\n          return { fields: {} };\n        }\n        throw error;\n      }).then(function (schema) {\n        Object.keys(update).forEach(function (fieldName) {\n          if (fieldName.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n            throw new _node.Parse.Error(_node.Parse.Error.INVALID_KEY_NAME, 'Invalid field name for update: ' + fieldName);\n          }\n          fieldName = fieldName.split('.')[0];\n          if (!SchemaController.fieldNameIsValid(fieldName) && !isSpecialUpdateKey(fieldName)) {\n            throw new _node.Parse.Error(_node.Parse.Error.INVALID_KEY_NAME, 'Invalid field name for update: ' + fieldName);\n          }\n        });\n        for (var updateOperation in update) {\n          if (Object.keys(updateOperation).some(function (innerKey) {\n            return innerKey.includes('$') || innerKey.includes('.');\n          })) {\n            throw new _node.Parse.Error(_node.Parse.Error.INVALID_NESTED_KEY, \"Nested keys should not contain the '$' or '.' characters\");\n          }\n        }\n        update = transformObjectACL(update);\n        transformAuthData(className, update, schema);\n        if (many) {\n          return _this4.adapter.updateObjectsByQuery(className, schema, query, update);\n        } else if (upsert) {\n          return _this4.adapter.upsertOneObject(className, schema, query, update);\n        } else {\n          return _this4.adapter.findOneAndUpdate(className, schema, query, update);\n        }\n      });\n    }).then(function (result) {\n      if (!result) {\n        return Promise.reject(new _node.Parse.Error(_node.Parse.Error.OBJECT_NOT_FOUND, 'Object not found.'));\n      }\n      if (skipSanitization) {\n        return Promise.resolve(result);\n      }\n      return sanitizeDatabaseResult(originalUpdate, result);\n    });\n  });\n};\n\nfunction sanitizeDatabaseResult(originalObject, result) {\n  var response = {};\n  if (!result) {\n    return Promise.resolve(response);\n  }\n  Object.keys(originalObject).forEach(function (key) {\n    var keyUpdate = originalObject[key];\n    // determine if that was an op\n    if (keyUpdate && (typeof keyUpdate === 'undefined' ? 'undefined' : _typeof(keyUpdate)) === 'object' && keyUpdate.__op && ['Add', 'AddUnique', 'Remove', 'Increment'].indexOf(keyUpdate.__op) > -1) {\n      // only valid ops that produce an actionable result\n      response[key] = result[key];\n    }\n  });\n  return Promise.resolve(response);\n}\n\n// Processes relation-updating operations from a REST-format update.\n// Returns a promise that resolves successfully when these are\n// processed.\n// This mutates update.\nDatabaseController.prototype.handleRelationUpdates = function (className, objectId, update) {\n  var _this5 = this;\n\n  var pending = [];\n  var deleteMe = [];\n  objectId = update.objectId || objectId;\n\n  var process = function process(op, key) {\n    if (!op) {\n      return;\n    }\n    if (op.__op == 'AddRelation') {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = op.objects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var object = _step.value;\n\n          pending.push(_this5.addRelation(key, className, objectId, object.objectId));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      deleteMe.push(key);\n    }\n\n    if (op.__op == 'RemoveRelation') {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = op.objects[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _object = _step2.value;\n\n          pending.push(_this5.removeRelation(key, className, objectId, _object.objectId));\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      deleteMe.push(key);\n    }\n\n    if (op.__op == 'Batch') {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = op.ops[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var x = _step3.value;\n\n          process(x, key);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  };\n\n  for (var key in update) {\n    process(update[key], key);\n  }\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = deleteMe[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var _key = _step4.value;\n\n      delete update[_key];\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  return Promise.all(pending);\n};\n\n// Adds a relation.\n// Returns a promise that resolves successfully iff the add was successful.\nvar relationSchema = { fields: { relatedId: { type: 'String' }, owningId: { type: 'String' } } };\nDatabaseController.prototype.addRelation = function (key, fromClassName, fromId, toId) {\n  var doc = {\n    relatedId: toId,\n    owningId: fromId\n  };\n  return this.adapter.upsertOneObject('_Join:' + key + ':' + fromClassName, relationSchema, doc, doc);\n};\n\n// Removes a relation.\n// Returns a promise that resolves successfully iff the remove was\n// successful.\nDatabaseController.prototype.removeRelation = function (key, fromClassName, fromId, toId) {\n  var doc = {\n    relatedId: toId,\n    owningId: fromId\n  };\n  return this.adapter.deleteObjectsByQuery('_Join:' + key + ':' + fromClassName, relationSchema, doc).catch(function (error) {\n    // We don't care if they try to delete a non-existent relation.\n    if (error.code == _node.Parse.Error.OBJECT_NOT_FOUND) {\n      return;\n    }\n    throw error;\n  });\n};\n\n// Removes objects matches this query from the database.\n// Returns a promise that resolves successfully iff the object was\n// deleted.\n// Options:\n//   acl:  a list of strings. If the object to be updated has an ACL,\n//         one of the provided strings must provide the caller with\n//         write permissions.\nDatabaseController.prototype.destroy = function (className, query) {\n  var _this6 = this;\n\n  var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      acl = _ref4.acl;\n\n  var isMaster = acl === undefined;\n  var aclGroup = acl || [];\n\n  return this.loadSchema().then(function (schemaController) {\n    return (isMaster ? Promise.resolve() : schemaController.validatePermission(className, aclGroup, 'delete')).then(function () {\n      if (!isMaster) {\n        query = _this6.addPointerPermissions(schemaController, className, 'delete', query, aclGroup);\n        if (!query) {\n          throw new _node.Parse.Error(_node.Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n        }\n      }\n      // delete by query\n      if (acl) {\n        query = addWriteACL(query, acl);\n      }\n      validateQuery(query);\n      return schemaController.getOneSchema(className).catch(function (error) {\n        // If the schema doesn't exist, pretend it exists with no fields. This behaviour\n        // will likely need revisiting.\n        if (error === undefined) {\n          return { fields: {} };\n        }\n        throw error;\n      }).then(function (parseFormatSchema) {\n        return _this6.adapter.deleteObjectsByQuery(className, parseFormatSchema, query);\n      }).catch(function (error) {\n        // When deleting sessions while changing passwords, don't throw an error if they don't have any sessions.\n        if (className === \"_Session\" && error.code === _node.Parse.Error.OBJECT_NOT_FOUND) {\n          return Promise.resolve({});\n        }\n        throw error;\n      });\n    });\n  });\n};\n\nvar flattenUpdateOperatorsForCreate = function flattenUpdateOperatorsForCreate(object) {\n  for (var key in object) {\n    if (object[key] && object[key].__op) {\n      switch (object[key].__op) {\n        case 'Increment':\n          if (typeof object[key].amount !== 'number') {\n            throw new _node.Parse.Error(_node.Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].amount;\n          break;\n        case 'Add':\n          if (!(object[key].objects instanceof Array)) {\n            throw new _node.Parse.Error(_node.Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].objects;\n          break;\n        case 'AddUnique':\n          if (!(object[key].objects instanceof Array)) {\n            throw new _node.Parse.Error(_node.Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].objects;\n          break;\n        case 'Remove':\n          if (!(object[key].objects instanceof Array)) {\n            throw new _node.Parse.Error(_node.Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = [];\n          break;\n        case 'Delete':\n          delete object[key];\n          break;\n        default:\n          throw new _node.Parse.Error(_node.Parse.Error.COMMAND_UNAVAILABLE, 'The ' + object[key].__op + ' operator is not supported yet.');\n      }\n    }\n  }\n};\n\nvar transformAuthData = function transformAuthData(className, object, schema) {\n  if (object.authData && className === '_User') {\n    Object.keys(object.authData).forEach(function (provider) {\n      var providerData = object.authData[provider];\n      var fieldName = '_auth_data_' + provider;\n      if (providerData == null) {\n        object[fieldName] = {\n          __op: 'Delete'\n        };\n      } else {\n        object[fieldName] = providerData;\n        schema.fields[fieldName] = { type: 'Object' };\n      }\n    });\n    delete object.authData;\n  }\n};\n\n// Inserts an object into the database.\n// Returns a promise that resolves successfully iff the object saved.\nDatabaseController.prototype.create = function (className, object) {\n  var _this7 = this;\n\n  var _ref5 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      acl = _ref5.acl;\n\n  // Make a copy of the object, so we don't mutate the incoming data.\n  var originalObject = object;\n  object = transformObjectACL(object);\n\n  object.createdAt = { iso: object.createdAt, __type: 'Date' };\n  object.updatedAt = { iso: object.updatedAt, __type: 'Date' };\n\n  var isMaster = acl === undefined;\n  var aclGroup = acl || [];\n\n  return this.validateClassName(className).then(function () {\n    return _this7.loadSchema();\n  }).then(function (schemaController) {\n    return (isMaster ? Promise.resolve() : schemaController.validatePermission(className, aclGroup, 'create')).then(function () {\n      return _this7.handleRelationUpdates(className, null, object);\n    }).then(function () {\n      return schemaController.enforceClassExists(className);\n    }).then(function () {\n      return schemaController.reloadData();\n    }).then(function () {\n      return schemaController.getOneSchema(className, true);\n    }).then(function (schema) {\n      transformAuthData(className, object, schema);\n      flattenUpdateOperatorsForCreate(object);\n      return _this7.adapter.createObject(className, SchemaController.convertSchemaToAdapterSchema(schema), object);\n    }).then(function (result) {\n      return sanitizeDatabaseResult(originalObject, result.ops[0]);\n    });\n  });\n};\n\nDatabaseController.prototype.canAddField = function (schema, className, object, aclGroup) {\n  var classSchema = schema.data[className];\n  if (!classSchema) {\n    return Promise.resolve();\n  }\n  var fields = Object.keys(object);\n  var schemaFields = Object.keys(classSchema);\n  var newKeys = fields.filter(function (field) {\n    return schemaFields.indexOf(field) < 0;\n  });\n  if (newKeys.length > 0) {\n    return schema.validatePermission(className, aclGroup, 'addField');\n  }\n  return Promise.resolve();\n};\n\n// Won't delete collections in the system namespace\n// Returns a promise.\nDatabaseController.prototype.deleteEverything = function () {\n  this.schemaPromise = null;\n  return Promise.all([this.adapter.deleteAllClasses(), this.schemaCache.clear()]);\n};\n\n// Returns a promise for a list of related ids given an owning id.\n// className here is the owning className.\nDatabaseController.prototype.relatedIds = function (className, key, owningId) {\n  return this.adapter.find(joinTableName(className, key), relationSchema, { owningId: owningId }, {}).then(function (results) {\n    return results.map(function (result) {\n      return result.relatedId;\n    });\n  });\n};\n\n// Returns a promise for a list of owning ids given some related ids.\n// className here is the owning className.\nDatabaseController.prototype.owningIds = function (className, key, relatedIds) {\n  return this.adapter.find(joinTableName(className, key), relationSchema, { relatedId: { '$in': relatedIds } }, {}).then(function (results) {\n    return results.map(function (result) {\n      return result.owningId;\n    });\n  });\n};\n\n// Modifies query so that it no longer has $in on relation fields, or\n// equal-to-pointer constraints on relation fields.\n// Returns a promise that resolves when query is mutated\nDatabaseController.prototype.reduceInRelation = function (className, query, schema) {\n  var _this8 = this;\n\n  // Search for an in-relation or equal-to-relation\n  // Make it sequential for now, not sure of paralleization side effects\n  if (query['$or']) {\n    var ors = query['$or'];\n    return Promise.all(ors.map(function (aQuery, index) {\n      return _this8.reduceInRelation(className, aQuery, schema).then(function (aQuery) {\n        query['$or'][index] = aQuery;\n      });\n    })).then(function () {\n      return Promise.resolve(query);\n    });\n  }\n\n  var promises = Object.keys(query).map(function (key) {\n    if (query[key] && (query[key]['$in'] || query[key]['$ne'] || query[key]['$nin'] || query[key].__type == 'Pointer')) {\n      var t = schema.getExpectedType(className, key);\n      if (!t || t.type !== 'Relation') {\n        return Promise.resolve(query);\n      }\n      // Build the list of queries\n      var queries = Object.keys(query[key]).map(function (constraintKey) {\n        var relatedIds = void 0;\n        var isNegation = false;\n        if (constraintKey === 'objectId') {\n          relatedIds = [query[key].objectId];\n        } else if (constraintKey == '$in') {\n          relatedIds = query[key]['$in'].map(function (r) {\n            return r.objectId;\n          });\n        } else if (constraintKey == '$nin') {\n          isNegation = true;\n          relatedIds = query[key]['$nin'].map(function (r) {\n            return r.objectId;\n          });\n        } else if (constraintKey == '$ne') {\n          isNegation = true;\n          relatedIds = [query[key]['$ne'].objectId];\n        } else {\n          return;\n        }\n        return {\n          isNegation: isNegation,\n          relatedIds: relatedIds\n        };\n      });\n\n      // remove the current queryKey as we don,t need it anymore\n      delete query[key];\n      // execute each query independnently to build the list of\n      // $in / $nin\n      var _promises = queries.map(function (q) {\n        if (!q) {\n          return Promise.resolve();\n        }\n        return _this8.owningIds(className, key, q.relatedIds).then(function (ids) {\n          if (q.isNegation) {\n            _this8.addNotInObjectIdsIds(ids, query);\n          } else {\n            _this8.addInObjectIdsIds(ids, query);\n          }\n          return Promise.resolve();\n        });\n      });\n\n      return Promise.all(_promises).then(function () {\n        return Promise.resolve();\n      });\n    }\n    return Promise.resolve();\n  });\n\n  return Promise.all(promises).then(function () {\n    return Promise.resolve(query);\n  });\n};\n\n// Modifies query so that it no longer has $relatedTo\n// Returns a promise that resolves when query is mutated\nDatabaseController.prototype.reduceRelationKeys = function (className, query) {\n  var _this9 = this;\n\n  if (query['$or']) {\n    return Promise.all(query['$or'].map(function (aQuery) {\n      return _this9.reduceRelationKeys(className, aQuery);\n    }));\n  }\n\n  var relatedTo = query['$relatedTo'];\n  if (relatedTo) {\n    return this.relatedIds(relatedTo.object.className, relatedTo.key, relatedTo.object.objectId).then(function (ids) {\n      delete query['$relatedTo'];\n      _this9.addInObjectIdsIds(ids, query);\n      return _this9.reduceRelationKeys(className, query);\n    });\n  }\n};\n\nDatabaseController.prototype.addInObjectIdsIds = function () {\n  var ids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var query = arguments[1];\n\n  var idsFromString = typeof query.objectId === 'string' ? [query.objectId] : null;\n  var idsFromEq = query.objectId && query.objectId['$eq'] ? [query.objectId['$eq']] : null;\n  var idsFromIn = query.objectId && query.objectId['$in'] ? query.objectId['$in'] : null;\n\n  var allIds = [idsFromString, idsFromEq, idsFromIn, ids].filter(function (list) {\n    return list !== null;\n  });\n  var totalLength = allIds.reduce(function (memo, list) {\n    return memo + list.length;\n  }, 0);\n\n  var idsIntersection = [];\n  if (totalLength > 125) {\n    idsIntersection = _intersect2.default.big(allIds);\n  } else {\n    idsIntersection = (0, _intersect2.default)(allIds);\n  }\n\n  // Need to make sure we don't clobber existing shorthand $eq constraints on objectId.\n  if (!('objectId' in query)) {\n    query.objectId = {};\n  } else if (typeof query.objectId === 'string') {\n    query.objectId = {\n      $eq: query.objectId\n    };\n  }\n  query.objectId['$in'] = idsIntersection;\n\n  return query;\n};\n\nDatabaseController.prototype.addNotInObjectIdsIds = function () {\n  var ids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var query = arguments[1];\n\n  var idsFromNin = query.objectId && query.objectId['$nin'] ? query.objectId['$nin'] : [];\n  var allIds = [].concat(_toConsumableArray(idsFromNin), _toConsumableArray(ids)).filter(function (list) {\n    return list !== null;\n  });\n\n  // make a set and spread to remove duplicates\n  allIds = [].concat(_toConsumableArray(new Set(allIds)));\n\n  // Need to make sure we don't clobber existing shorthand $eq constraints on objectId.\n  if (!('objectId' in query)) {\n    query.objectId = {};\n  } else if (typeof query.objectId === 'string') {\n    query.objectId = {\n      $eq: query.objectId\n    };\n  }\n\n  query.objectId['$nin'] = allIds;\n  return query;\n};\n\n// Runs a query on the database.\n// Returns a promise that resolves to a list of items.\n// Options:\n//   skip    number of results to skip.\n//   limit   limit to this number of results.\n//   sort    an object where keys are the fields to sort by.\n//           the value is +1 for ascending, -1 for descending.\n//   count   run a count instead of returning results.\n//   acl     restrict this operation with an ACL for the provided array\n//           of user objectIds and roles. acl: null means no user.\n//           when this field is not present, don't do anything regarding ACLs.\n// TODO: make userIds not needed here. The db adapter shouldn't know\n// anything about users, ideally. Then, improve the format of the ACL\n// arg to work like the others.\nDatabaseController.prototype.find = function (className, query) {\n  var _this10 = this;\n\n  var _ref6 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      skip = _ref6.skip,\n      limit = _ref6.limit,\n      acl = _ref6.acl,\n      _ref6$sort = _ref6.sort,\n      sort = _ref6$sort === undefined ? {} : _ref6$sort,\n      count = _ref6.count,\n      keys = _ref6.keys,\n      op = _ref6.op;\n\n  var isMaster = acl === undefined;\n  var aclGroup = acl || [];\n  op = op || (typeof query.objectId == 'string' && Object.keys(query).length === 1 ? 'get' : 'find');\n  var classExists = true;\n  return this.loadSchema().then(function (schemaController) {\n    //Allow volatile classes if querying with Master (for _PushStatus)\n    //TODO: Move volatile classes concept into mongo adatper, postgres adapter shouldn't care\n    //that api.parse.com breaks when _PushStatus exists in mongo.\n    return schemaController.getOneSchema(className, isMaster).catch(function (error) {\n      // Behaviour for non-existent classes is kinda weird on Parse.com. Probably doesn't matter too much.\n      // For now, pretend the class exists but has no objects,\n      if (error === undefined) {\n        classExists = false;\n        return { fields: {} };\n      }\n      throw error;\n    }).then(function (schema) {\n      // Parse.com treats queries on _created_at and _updated_at as if they were queries on createdAt and updatedAt,\n      // so duplicate that behaviour here. If both are specified, the corrent behaviour to match Parse.com is to\n      // use the one that appears first in the sort list.\n      if (sort._created_at) {\n        sort.createdAt = sort._created_at;\n        delete sort._created_at;\n      }\n      if (sort._updated_at) {\n        sort.updatedAt = sort._updated_at;\n        delete sort._updated_at;\n      }\n      Object.keys(sort).forEach(function (fieldName) {\n        if (fieldName.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n          throw new _node.Parse.Error(_node.Parse.Error.INVALID_KEY_NAME, 'Cannot sort by ' + fieldName);\n        }\n        if (!SchemaController.fieldNameIsValid(fieldName)) {\n          throw new _node.Parse.Error(_node.Parse.Error.INVALID_KEY_NAME, 'Invalid field name: ' + fieldName + '.');\n        }\n      });\n      return (isMaster ? Promise.resolve() : schemaController.validatePermission(className, aclGroup, op)).then(function () {\n        return _this10.reduceRelationKeys(className, query);\n      }).then(function () {\n        return _this10.reduceInRelation(className, query, schemaController);\n      }).then(function () {\n        if (!isMaster) {\n          query = _this10.addPointerPermissions(schemaController, className, op, query, aclGroup);\n        }\n        if (!query) {\n          if (op == 'get') {\n            throw new _node.Parse.Error(_node.Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          } else {\n            return [];\n          }\n        }\n        if (!isMaster) {\n          query = addReadACL(query, aclGroup);\n        }\n        validateQuery(query);\n        if (count) {\n          if (!classExists) {\n            return 0;\n          } else {\n            return _this10.adapter.count(className, schema, query);\n          }\n        } else {\n          if (!classExists) {\n            return [];\n          } else {\n            return _this10.adapter.find(className, schema, query, { skip: skip, limit: limit, sort: sort, keys: keys }).then(function (objects) {\n              return objects.map(function (object) {\n                object = untransformObjectACL(object);\n                return filterSensitiveData(isMaster, aclGroup, className, object);\n              });\n            });\n          }\n        }\n      });\n    });\n  });\n};\n\n// Transforms a Database format ACL to a REST API format ACL\nvar untransformObjectACL = function untransformObjectACL(_ref7) {\n  var _rperm = _ref7._rperm,\n      _wperm = _ref7._wperm,\n      output = _objectWithoutProperties(_ref7, ['_rperm', '_wperm']);\n\n  if (_rperm || _wperm) {\n    output.ACL = {};\n\n    (_rperm || []).forEach(function (entry) {\n      if (!output.ACL[entry]) {\n        output.ACL[entry] = { read: true };\n      } else {\n        output.ACL[entry]['read'] = true;\n      }\n    });\n\n    (_wperm || []).forEach(function (entry) {\n      if (!output.ACL[entry]) {\n        output.ACL[entry] = { write: true };\n      } else {\n        output.ACL[entry]['write'] = true;\n      }\n    });\n  }\n  return output;\n};\n\nDatabaseController.prototype.deleteSchema = function (className) {\n  var _this11 = this;\n\n  return this.loadSchema(true).then(function (schemaController) {\n    return schemaController.getOneSchema(className, true);\n  }).catch(function (error) {\n    if (error === undefined) {\n      return { fields: {} };\n    } else {\n      throw error;\n    }\n  }).then(function (schema) {\n    return _this11.collectionExists(className).then(function () {\n      return _this11.adapter.count(className, { fields: {} });\n    }).then(function (count) {\n      if (count > 0) {\n        throw new _node.Parse.Error(255, 'Class ' + className + ' is not empty, contains ' + count + ' objects, cannot drop schema.');\n      }\n      return _this11.adapter.deleteClass(className);\n    }).then(function (wasParseCollection) {\n      if (wasParseCollection) {\n        var relationFieldNames = Object.keys(schema.fields).filter(function (fieldName) {\n          return schema.fields[fieldName].type === 'Relation';\n        });\n        return Promise.all(relationFieldNames.map(function (name) {\n          return _this11.adapter.deleteClass(joinTableName(className, name));\n        }));\n      } else {\n        return Promise.resolve();\n      }\n    });\n  });\n};\n\nDatabaseController.prototype.addPointerPermissions = function (schema, className, operation, query) {\n  var aclGroup = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n\n  // Check if class has public permission for operation\n  // If the BaseCLP pass, let go through\n  if (schema.testBaseCLP(className, aclGroup, operation)) {\n    return query;\n  }\n  var perms = schema.perms[className];\n  var field = ['get', 'find'].indexOf(operation) > -1 ? 'readUserFields' : 'writeUserFields';\n  var userACL = aclGroup.filter(function (acl) {\n    return acl.indexOf('role:') != 0 && acl != '*';\n  });\n  // the ACL should have exactly 1 user\n  if (perms && perms[field] && perms[field].length > 0) {\n    // No user set return undefined\n    // If the length is > 1, that means we didn't dedup users correctly\n    if (userACL.length != 1) {\n      return;\n    }\n    var userId = userACL[0];\n    var userPointer = {\n      \"__type\": \"Pointer\",\n      \"className\": \"_User\",\n      \"objectId\": userId\n    };\n\n    var permFields = perms[field];\n    var ors = permFields.map(function (key) {\n      var q = _defineProperty({}, key, userPointer);\n      return { '$and': [q, query] };\n    });\n    if (ors.length > 1) {\n      return { '$or': ors };\n    }\n    return ors[0];\n  } else {\n    return query;\n  }\n};\n\n// TODO: create indexes on first creation of a _User object. Otherwise it's impossible to\n// have a Parse app without it having a _User collection.\nDatabaseController.prototype.performInitialization = function () {\n  var _this12 = this;\n\n  var requiredUserFields = { fields: _extends({}, SchemaController.defaultColumns._Default, SchemaController.defaultColumns._User) };\n  var requiredRoleFields = { fields: _extends({}, SchemaController.defaultColumns._Default, SchemaController.defaultColumns._Role) };\n\n  var userClassPromise = this.loadSchema().then(function (schema) {\n    return schema.enforceClassExists('_User');\n  });\n  var roleClassPromise = this.loadSchema().then(function (schema) {\n    return schema.enforceClassExists('_Role');\n  });\n\n  var usernameUniqueness = userClassPromise.then(function () {\n    return _this12.adapter.ensureUniqueness('_User', requiredUserFields, ['username']);\n  }).catch(function (error) {\n    _logger2.default.warn('Unable to ensure uniqueness for usernames: ', error);\n    throw error;\n  });\n\n  var emailUniqueness = userClassPromise.then(function () {\n    return _this12.adapter.ensureUniqueness('_User', requiredUserFields, ['email']);\n  }).catch(function (error) {\n    _logger2.default.warn('Unable to ensure uniqueness for user email addresses: ', error);\n    throw error;\n  });\n\n  var roleUniqueness = roleClassPromise.then(function () {\n    return _this12.adapter.ensureUniqueness('_Role', requiredRoleFields, ['name']);\n  }).catch(function (error) {\n    _logger2.default.warn('Unable to ensure uniqueness for role name: ', error);\n    throw error;\n  });\n\n  // Create tables for volatile classes\n  var adapterInit = this.adapter.performInitialization({ VolatileClassesSchemas: SchemaController.VolatileClassesSchemas });\n  return Promise.all([usernameUniqueness, emailUniqueness, roleUniqueness, adapterInit]);\n};\n\nfunction joinTableName(className, key) {\n  return '_Join:' + key + ':' + className;\n}\n\n// Expose validateQuery for tests\nDatabaseController._validateQuery = validateQuery;\nmodule.exports = DatabaseController;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Controllers/SchemaController.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\n// This class handles schema validation, persistence, and modification.\n//\n// Each individual Schema object should be immutable. The helpers to\n// do things with the Schema just return a new schema when the schema\n// is changed.\n//\n// The canonical place to store this Schema is in the database itself,\n// in a _SCHEMA collection. This is not the right way to do it for an\n// open source framework, but it's backward compatible, so we're\n// keeping it this way for now.\n//\n// In API-handling code, you should only use the Schema class via the\n// DatabaseController. This will let us replace the schema logic for\n// different databases.\n// TODO: hide all schema logic inside the database adapter.\n\nvar Parse = require('parse/node').Parse;\n\nvar defaultColumns = Object.freeze({\n  // Contain the default columns for every parse object type (except _Join collection)\n  _Default: {\n    \"objectId\": { type: 'String' },\n    \"createdAt\": { type: 'Date' },\n    \"updatedAt\": { type: 'Date' },\n    \"ACL\": { type: 'ACL' }\n  },\n  // The additional default columns for the _User collection (in addition to DefaultCols)\n  _User: {\n    \"username\": { type: 'String' },\n    \"password\": { type: 'String' },\n    \"email\": { type: 'String' },\n    \"emailVerified\": { type: 'Boolean' },\n    \"authData\": { type: 'Object' }\n  },\n  // The additional default columns for the _Installation collection (in addition to DefaultCols)\n  _Installation: {\n    \"installationId\": { type: 'String' },\n    \"deviceToken\": { type: 'String' },\n    \"channels\": { type: 'Array' },\n    \"deviceType\": { type: 'String' },\n    \"pushType\": { type: 'String' },\n    \"GCMSenderId\": { type: 'String' },\n    \"timeZone\": { type: 'String' },\n    \"localeIdentifier\": { type: 'String' },\n    \"badge\": { type: 'Number' },\n    \"appVersion\": { type: 'String' },\n    \"appName\": { type: 'String' },\n    \"appIdentifier\": { type: 'String' },\n    \"parseVersion\": { type: 'String' }\n  },\n  // The additional default columns for the _Role collection (in addition to DefaultCols)\n  _Role: {\n    \"name\": { type: 'String' },\n    \"users\": { type: 'Relation', targetClass: '_User' },\n    \"roles\": { type: 'Relation', targetClass: '_Role' }\n  },\n  // The additional default columns for the _Session collection (in addition to DefaultCols)\n  _Session: {\n    \"restricted\": { type: 'Boolean' },\n    \"user\": { type: 'Pointer', targetClass: '_User' },\n    \"installationId\": { type: 'String' },\n    \"sessionToken\": { type: 'String' },\n    \"expiresAt\": { type: 'Date' },\n    \"createdWith\": { type: 'Object' }\n  },\n  _Product: {\n    \"productIdentifier\": { type: 'String' },\n    \"download\": { type: 'File' },\n    \"downloadName\": { type: 'String' },\n    \"icon\": { type: 'File' },\n    \"order\": { type: 'Number' },\n    \"title\": { type: 'String' },\n    \"subtitle\": { type: 'String' }\n  },\n  _PushStatus: {\n    \"pushTime\": { type: 'String' },\n    \"source\": { type: 'String' }, // rest or webui\n    \"query\": { type: 'String' }, // the stringified JSON query\n    \"payload\": { type: 'String' }, // the stringified JSON payload,\n    \"title\": { type: 'String' },\n    \"expiry\": { type: 'Number' },\n    \"status\": { type: 'String' },\n    \"numSent\": { type: 'Number' },\n    \"numFailed\": { type: 'Number' },\n    \"pushHash\": { type: 'String' },\n    \"errorMessage\": { type: 'Object' },\n    \"sentPerType\": { type: 'Object' },\n    \"failedPerType\": { type: 'Object' },\n    \"count\": { type: 'Number' }\n  },\n  _JobStatus: {\n    \"jobName\": { type: 'String' },\n    \"source\": { type: 'String' },\n    \"status\": { type: 'String' },\n    \"message\": { type: 'String' },\n    \"params\": { type: 'Object' }, // params received when calling the job\n    \"finishedAt\": { type: 'Date' }\n  },\n  _Hooks: {\n    \"functionName\": { type: 'String' },\n    \"className\": { type: 'String' },\n    \"triggerName\": { type: 'String' },\n    \"url\": { type: 'String' }\n  },\n  _GlobalConfig: {\n    \"objectId\": { type: 'String' },\n    \"params\": { type: 'Object' }\n  }\n});\n\nvar requiredColumns = Object.freeze({\n  _Product: [\"productIdentifier\", \"icon\", \"order\", \"title\", \"subtitle\"],\n  _Role: [\"name\", \"ACL\"]\n});\n\nvar systemClasses = Object.freeze(['_User', '_Installation', '_Role', '_Session', '_Product', '_PushStatus', '_JobStatus']);\n\nvar volatileClasses = Object.freeze(['_JobStatus', '_PushStatus', '_Hooks', '_GlobalConfig']);\n\n// 10 alpha numberic chars + uppercase\nvar userIdRegex = /^[a-zA-Z0-9]{10}$/;\n// Anything that start with role\nvar roleRegex = /^role:.*/;\n// * permission\nvar publicRegex = /^\\*$/;\n\nvar requireAuthenticationRegex = /^requiresAuthentication$/;\n\nvar permissionKeyRegex = Object.freeze([userIdRegex, roleRegex, publicRegex, requireAuthenticationRegex]);\n\nfunction verifyPermissionKey(key) {\n  var result = permissionKeyRegex.reduce(function (isGood, regEx) {\n    isGood = isGood || key.match(regEx) != null;\n    return isGood;\n  }, false);\n  if (!result) {\n    throw new Parse.Error(Parse.Error.INVALID_JSON, '\\'' + key + '\\' is not a valid key for class level permissions');\n  }\n}\n\nvar CLPValidKeys = Object.freeze(['find', 'get', 'create', 'update', 'delete', 'addField', 'readUserFields', 'writeUserFields']);\nfunction validateCLP(perms, fields) {\n  if (!perms) {\n    return;\n  }\n  Object.keys(perms).forEach(function (operation) {\n    if (CLPValidKeys.indexOf(operation) == -1) {\n      throw new Parse.Error(Parse.Error.INVALID_JSON, operation + ' is not a valid operation for class level permissions');\n    }\n\n    if (operation === 'readUserFields' || operation === 'writeUserFields') {\n      if (!Array.isArray(perms[operation])) {\n        throw new Parse.Error(Parse.Error.INVALID_JSON, '\\'' + perms[operation] + '\\' is not a valid value for class level permissions ' + operation);\n      } else {\n        perms[operation].forEach(function (key) {\n          if (!fields[key] || fields[key].type != 'Pointer' || fields[key].targetClass != '_User') {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, '\\'' + key + '\\' is not a valid column for class level pointer permissions ' + operation);\n          }\n        });\n      }\n      return;\n    }\n\n    Object.keys(perms[operation]).forEach(function (key) {\n      verifyPermissionKey(key);\n      var perm = perms[operation][key];\n      if (perm !== true) {\n        throw new Parse.Error(Parse.Error.INVALID_JSON, '\\'' + perm + '\\' is not a valid value for class level permissions ' + operation + ':' + key + ':' + perm);\n      }\n    });\n  });\n}\nvar joinClassRegex = /^_Join:[A-Za-z0-9_]+:[A-Za-z0-9_]+/;\nvar classAndFieldRegex = /^[A-Za-z][A-Za-z0-9_]*$/;\nfunction classNameIsValid(className) {\n  // Valid classes must:\n  return (\n    // Be one of _User, _Installation, _Role, _Session OR\n    systemClasses.indexOf(className) > -1 ||\n    // Be a join table OR\n    joinClassRegex.test(className) ||\n    // Include only alpha-numeric and underscores, and not start with an underscore or number\n    fieldNameIsValid(className)\n  );\n}\n\n// Valid fields must be alpha-numeric, and not start with an underscore or number\nfunction fieldNameIsValid(fieldName) {\n  return classAndFieldRegex.test(fieldName);\n}\n\n// Checks that it's not trying to clobber one of the default fields of the class.\nfunction fieldNameIsValidForClass(fieldName, className) {\n  if (!fieldNameIsValid(fieldName)) {\n    return false;\n  }\n  if (defaultColumns._Default[fieldName]) {\n    return false;\n  }\n  if (defaultColumns[className] && defaultColumns[className][fieldName]) {\n    return false;\n  }\n  return true;\n}\n\nfunction invalidClassNameMessage(className) {\n  return 'Invalid classname: ' + className + ', classnames can only have alphanumeric characters and _, and must start with an alpha character ';\n}\n\nvar invalidJsonError = new Parse.Error(Parse.Error.INVALID_JSON, \"invalid JSON\");\nvar validNonRelationOrPointerTypes = ['Number', 'String', 'Boolean', 'Date', 'Object', 'Array', 'GeoPoint', 'File'];\n// Returns an error suitable for throwing if the type is invalid\nvar fieldTypeIsInvalid = function fieldTypeIsInvalid(_ref) {\n  var type = _ref.type,\n      targetClass = _ref.targetClass;\n\n  if (['Pointer', 'Relation'].indexOf(type) >= 0) {\n    if (!targetClass) {\n      return new Parse.Error(135, 'type ' + type + ' needs a class name');\n    } else if (typeof targetClass !== 'string') {\n      return invalidJsonError;\n    } else if (!classNameIsValid(targetClass)) {\n      return new Parse.Error(Parse.Error.INVALID_CLASS_NAME, invalidClassNameMessage(targetClass));\n    } else {\n      return undefined;\n    }\n  }\n  if (typeof type !== 'string') {\n    return invalidJsonError;\n  }\n  if (validNonRelationOrPointerTypes.indexOf(type) < 0) {\n    return new Parse.Error(Parse.Error.INCORRECT_TYPE, 'invalid field type: ' + type);\n  }\n  return undefined;\n};\n\nvar convertSchemaToAdapterSchema = function convertSchemaToAdapterSchema(schema) {\n  schema = injectDefaultSchema(schema);\n  delete schema.fields.ACL;\n  schema.fields._rperm = { type: 'Array' };\n  schema.fields._wperm = { type: 'Array' };\n\n  if (schema.className === '_User') {\n    delete schema.fields.password;\n    schema.fields._hashed_password = { type: 'String' };\n  }\n\n  return schema;\n};\n\nvar convertAdapterSchemaToParseSchema = function convertAdapterSchemaToParseSchema(_ref2) {\n  var schema = _objectWithoutProperties(_ref2, []);\n\n  delete schema.fields._rperm;\n  delete schema.fields._wperm;\n\n  schema.fields.ACL = { type: 'ACL' };\n\n  if (schema.className === '_User') {\n    delete schema.fields.authData; //Auth data is implicit\n    delete schema.fields._hashed_password;\n    schema.fields.password = { type: 'String' };\n  }\n\n  return schema;\n};\n\nvar injectDefaultSchema = function injectDefaultSchema(_ref3) {\n  var className = _ref3.className,\n      fields = _ref3.fields,\n      classLevelPermissions = _ref3.classLevelPermissions;\n  return {\n    className: className,\n    fields: _extends({}, defaultColumns._Default, defaultColumns[className] || {}, fields),\n    classLevelPermissions: classLevelPermissions\n  };\n};\n\nvar _HooksSchema = { className: \"_Hooks\", fields: defaultColumns._Hooks };\nvar _GlobalConfigSchema = { className: \"_GlobalConfig\", fields: defaultColumns._GlobalConfig };\nvar _PushStatusSchema = convertSchemaToAdapterSchema(injectDefaultSchema({\n  className: \"_PushStatus\",\n  fields: {},\n  classLevelPermissions: {}\n}));\nvar _JobStatusSchema = convertSchemaToAdapterSchema(injectDefaultSchema({\n  className: \"_JobStatus\",\n  fields: {},\n  classLevelPermissions: {}\n}));\nvar VolatileClassesSchemas = [_HooksSchema, _JobStatusSchema, _PushStatusSchema, _GlobalConfigSchema];\n\nvar dbTypeMatchesObjectType = function dbTypeMatchesObjectType(dbType, objectType) {\n  if (dbType.type !== objectType.type) return false;\n  if (dbType.targetClass !== objectType.targetClass) return false;\n  if (dbType === objectType.type) return true;\n  if (dbType.type === objectType.type) return true;\n  return false;\n};\n\nvar typeToString = function typeToString(type) {\n  if (type.targetClass) {\n    return type.type + '<' + type.targetClass + '>';\n  }\n  return '' + (type.type || type);\n};\n\n// Stores the entire schema of the app in a weird hybrid format somewhere between\n// the mongo format and the Parse format. Soon, this will all be Parse format.\n\nvar SchemaController = function () {\n  function SchemaController(databaseAdapter, schemaCache) {\n    _classCallCheck(this, SchemaController);\n\n    this._dbAdapter = databaseAdapter;\n    this._cache = schemaCache;\n    // this.data[className][fieldName] tells you the type of that field, in mongo format\n    this.data = {};\n    // this.perms[className][operation] tells you the acl-style permissions\n    this.perms = {};\n  }\n\n  _createClass(SchemaController, [{\n    key: 'reloadData',\n    value: function reloadData() {\n      var _this = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { clearCache: false };\n\n      var promise = Promise.resolve();\n      if (options.clearCache) {\n        promise = promise.then(function () {\n          return _this._cache.clear();\n        });\n      }\n      if (this.reloadDataPromise && !options.clearCache) {\n        return this.reloadDataPromise;\n      }\n      this.reloadDataPromise = promise.then(function () {\n        return _this.getAllClasses(options);\n      }).then(function (allSchemas) {\n        var data = {};\n        var perms = {};\n        allSchemas.forEach(function (schema) {\n          data[schema.className] = injectDefaultSchema(schema).fields;\n          perms[schema.className] = schema.classLevelPermissions;\n        });\n\n        // Inject the in-memory classes\n        volatileClasses.forEach(function (className) {\n          var schema = injectDefaultSchema({ className: className });\n          data[className] = schema.fields;\n          perms[className] = schema.classLevelPermissions;\n        });\n        _this.data = data;\n        _this.perms = perms;\n        delete _this.reloadDataPromise;\n      }, function (err) {\n        _this.data = {};\n        _this.perms = {};\n        delete _this.reloadDataPromise;\n        throw err;\n      });\n      return this.reloadDataPromise;\n    }\n  }, {\n    key: 'getAllClasses',\n    value: function getAllClasses() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { clearCache: false };\n\n      var promise = Promise.resolve();\n      if (options.clearCache) {\n        promise = this._cache.clear();\n      }\n      return promise.then(function () {\n        return _this2._cache.getAllClasses();\n      }).then(function (allClasses) {\n        if (allClasses && allClasses.length && !options.clearCache) {\n          return Promise.resolve(allClasses);\n        }\n        return _this2._dbAdapter.getAllClasses().then(function (allSchemas) {\n          return allSchemas.map(injectDefaultSchema);\n        }).then(function (allSchemas) {\n          return _this2._cache.setAllClasses(allSchemas).then(function () {\n            return allSchemas;\n          });\n        });\n      });\n    }\n  }, {\n    key: 'getOneSchema',\n    value: function getOneSchema(className) {\n      var _this3 = this;\n\n      var allowVolatileClasses = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { clearCache: false };\n\n      var promise = Promise.resolve();\n      if (options.clearCache) {\n        promise = this._cache.clear();\n      }\n      return promise.then(function () {\n        if (allowVolatileClasses && volatileClasses.indexOf(className) > -1) {\n          return Promise.resolve({\n            className: className,\n            fields: _this3.data[className],\n            classLevelPermissions: _this3.perms[className]\n          });\n        }\n        return _this3._cache.getOneSchema(className).then(function (cached) {\n          if (cached && !options.clearCache) {\n            return Promise.resolve(cached);\n          }\n          return _this3._dbAdapter.getClass(className).then(injectDefaultSchema).then(function (result) {\n            return _this3._cache.setOneSchema(className, result).then(function () {\n              return result;\n            });\n          });\n        });\n      });\n    }\n\n    // Create a new class that includes the three default fields.\n    // ACL is an implicit column that does not get an entry in the\n    // _SCHEMAS database. Returns a promise that resolves with the\n    // created schema, in mongo format.\n    // on success, and rejects with an error on fail. Ensure you\n    // have authorization (master key, or client class creation\n    // enabled) before calling this function.\n\n  }, {\n    key: 'addClassIfNotExists',\n    value: function addClassIfNotExists(className) {\n      var _this4 = this;\n\n      var fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var classLevelPermissions = arguments[2];\n\n      var validationError = this.validateNewClass(className, fields, classLevelPermissions);\n      if (validationError) {\n        return Promise.reject(validationError);\n      }\n\n      return this._dbAdapter.createClass(className, convertSchemaToAdapterSchema({ fields: fields, classLevelPermissions: classLevelPermissions, className: className })).then(convertAdapterSchemaToParseSchema).then(function (res) {\n        return _this4._cache.clear().then(function () {\n          return Promise.resolve(res);\n        });\n      }).catch(function (error) {\n        if (error && error.code === Parse.Error.DUPLICATE_VALUE) {\n          throw new Parse.Error(Parse.Error.INVALID_CLASS_NAME, 'Class ' + className + ' already exists.');\n        } else {\n          throw error;\n        }\n      });\n    }\n  }, {\n    key: 'updateClass',\n    value: function updateClass(className, submittedFields, classLevelPermissions, database) {\n      var _this5 = this;\n\n      return this.getOneSchema(className).then(function (schema) {\n        var existingFields = schema.fields;\n        Object.keys(submittedFields).forEach(function (name) {\n          var field = submittedFields[name];\n          if (existingFields[name] && field.__op !== 'Delete') {\n            throw new Parse.Error(255, 'Field ' + name + ' exists, cannot update.');\n          }\n          if (!existingFields[name] && field.__op === 'Delete') {\n            throw new Parse.Error(255, 'Field ' + name + ' does not exist, cannot delete.');\n          }\n        });\n\n        delete existingFields._rperm;\n        delete existingFields._wperm;\n        var newSchema = buildMergedSchemaObject(existingFields, submittedFields);\n        var validationError = _this5.validateSchemaData(className, newSchema, classLevelPermissions, Object.keys(existingFields));\n        if (validationError) {\n          throw new Parse.Error(validationError.code, validationError.error);\n        }\n\n        // Finally we have checked to make sure the request is valid and we can start deleting fields.\n        // Do all deletions first, then a single save to _SCHEMA collection to handle all additions.\n        var deletePromises = [];\n        var insertedFields = [];\n        Object.keys(submittedFields).forEach(function (fieldName) {\n          if (submittedFields[fieldName].__op === 'Delete') {\n            var promise = _this5.deleteField(fieldName, className, database);\n            deletePromises.push(promise);\n          } else {\n            insertedFields.push(fieldName);\n          }\n        });\n\n        return Promise.all(deletePromises) // Delete Everything\n        .then(function () {\n          return _this5.reloadData({ clearCache: true });\n        }) // Reload our Schema, so we have all the new values\n        .then(function () {\n          var promises = insertedFields.map(function (fieldName) {\n            var type = submittedFields[fieldName];\n            return _this5.enforceFieldExists(className, fieldName, type);\n          });\n          return Promise.all(promises);\n        }).then(function () {\n          return _this5.setPermissions(className, classLevelPermissions, newSchema);\n        })\n        //TODO: Move this logic into the database adapter\n        .then(function () {\n          return {\n            className: className,\n            fields: _this5.data[className],\n            classLevelPermissions: _this5.perms[className]\n          };\n        });\n      }).catch(function (error) {\n        if (error === undefined) {\n          throw new Parse.Error(Parse.Error.INVALID_CLASS_NAME, 'Class ' + className + ' does not exist.');\n        } else {\n          throw error;\n        }\n      });\n    }\n\n    // Returns a promise that resolves successfully to the new schema\n    // object or fails with a reason.\n\n  }, {\n    key: 'enforceClassExists',\n    value: function enforceClassExists(className) {\n      var _this6 = this;\n\n      if (this.data[className]) {\n        return Promise.resolve(this);\n      }\n      // We don't have this class. Update the schema\n      return this.addClassIfNotExists(className)\n      // The schema update succeeded. Reload the schema\n      .then(function () {\n        return _this6.reloadData({ clearCache: true });\n      }).catch(function () {\n        // The schema update failed. This can be okay - it might\n        // have failed because there's a race condition and a different\n        // client is making the exact same schema update that we want.\n        // So just reload the schema.\n        return _this6.reloadData({ clearCache: true });\n      }).then(function () {\n        // Ensure that the schema now validates\n        if (_this6.data[className]) {\n          return _this6;\n        } else {\n          throw new Parse.Error(Parse.Error.INVALID_JSON, 'Failed to add ' + className);\n        }\n      }).catch(function () {\n        // The schema still doesn't validate. Give up\n        throw new Parse.Error(Parse.Error.INVALID_JSON, 'schema class name does not revalidate');\n      });\n    }\n  }, {\n    key: 'validateNewClass',\n    value: function validateNewClass(className) {\n      var fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var classLevelPermissions = arguments[2];\n\n      if (this.data[className]) {\n        throw new Parse.Error(Parse.Error.INVALID_CLASS_NAME, 'Class ' + className + ' already exists.');\n      }\n      if (!classNameIsValid(className)) {\n        return {\n          code: Parse.Error.INVALID_CLASS_NAME,\n          error: invalidClassNameMessage(className)\n        };\n      }\n      return this.validateSchemaData(className, fields, classLevelPermissions, []);\n    }\n  }, {\n    key: 'validateSchemaData',\n    value: function validateSchemaData(className, fields, classLevelPermissions, existingFieldNames) {\n      for (var fieldName in fields) {\n        if (existingFieldNames.indexOf(fieldName) < 0) {\n          if (!fieldNameIsValid(fieldName)) {\n            return {\n              code: Parse.Error.INVALID_KEY_NAME,\n              error: 'invalid field name: ' + fieldName\n            };\n          }\n          if (!fieldNameIsValidForClass(fieldName, className)) {\n            return {\n              code: 136,\n              error: 'field ' + fieldName + ' cannot be added'\n            };\n          }\n          var error = fieldTypeIsInvalid(fields[fieldName]);\n          if (error) return { code: error.code, error: error.message };\n        }\n      }\n\n      for (var _fieldName in defaultColumns[className]) {\n        fields[_fieldName] = defaultColumns[className][_fieldName];\n      }\n\n      var geoPoints = Object.keys(fields).filter(function (key) {\n        return fields[key] && fields[key].type === 'GeoPoint';\n      });\n      if (geoPoints.length > 1) {\n        return {\n          code: Parse.Error.INCORRECT_TYPE,\n          error: 'currently, only one GeoPoint field may exist in an object. Adding ' + geoPoints[1] + ' when ' + geoPoints[0] + ' already exists.'\n        };\n      }\n      validateCLP(classLevelPermissions, fields);\n    }\n\n    // Sets the Class-level permissions for a given className, which must exist.\n\n  }, {\n    key: 'setPermissions',\n    value: function setPermissions(className, perms, newSchema) {\n      var _this7 = this;\n\n      if (typeof perms === 'undefined') {\n        return Promise.resolve();\n      }\n      validateCLP(perms, newSchema);\n      return this._dbAdapter.setClassLevelPermissions(className, perms).then(function () {\n        return _this7.reloadData({ clearCache: true });\n      });\n    }\n\n    // Returns a promise that resolves successfully to the new schema\n    // object if the provided className-fieldName-type tuple is valid.\n    // The className must already be validated.\n    // If 'freeze' is true, refuse to update the schema for this field.\n\n  }, {\n    key: 'enforceFieldExists',\n    value: function enforceFieldExists(className, fieldName, type) {\n      var _this8 = this;\n\n      if (fieldName.indexOf(\".\") > 0) {\n        // subdocument key (x.y) => ok if x is of type 'object'\n        fieldName = fieldName.split(\".\")[0];\n        type = 'Object';\n      }\n      if (!fieldNameIsValid(fieldName)) {\n        throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'Invalid field name: ' + fieldName + '.');\n      }\n\n      // If someone tries to create a new field with null/undefined as the value, return;\n      if (!type) {\n        return Promise.resolve(this);\n      }\n\n      return this.reloadData().then(function () {\n        var expectedType = _this8.getExpectedType(className, fieldName);\n        if (typeof type === 'string') {\n          type = { type: type };\n        }\n\n        if (expectedType) {\n          if (!dbTypeMatchesObjectType(expectedType, type)) {\n            throw new Parse.Error(Parse.Error.INCORRECT_TYPE, 'schema mismatch for ' + className + '.' + fieldName + '; expected ' + typeToString(expectedType) + ' but got ' + typeToString(type));\n          }\n          return _this8;\n        }\n\n        return _this8._dbAdapter.addFieldIfNotExists(className, fieldName, type).then(function () {\n          // The update succeeded. Reload the schema\n          return _this8.reloadData({ clearCache: true });\n        }, function () {\n          //TODO: introspect the error and only reload if the error is one for which is makes sense to reload\n\n          // The update failed. This can be okay - it might have been a race\n          // condition where another client updated the schema in the same\n          // way that we wanted to. So, just reload the schema\n          return _this8.reloadData({ clearCache: true });\n        }).then(function () {\n          // Ensure that the schema now validates\n          if (!dbTypeMatchesObjectType(_this8.getExpectedType(className, fieldName), type)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'Could not add field ' + fieldName);\n          }\n          // Remove the cached schema\n          _this8._cache.clear();\n          return _this8;\n        });\n      });\n    }\n\n    // Delete a field, and remove that data from all objects. This is intended\n    // to remove unused fields, if other writers are writing objects that include\n    // this field, the field may reappear. Returns a Promise that resolves with\n    // no object on success, or rejects with { code, error } on failure.\n    // Passing the database and prefix is necessary in order to drop relation collections\n    // and remove fields from objects. Ideally the database would belong to\n    // a database adapter and this function would close over it or access it via member.\n\n  }, {\n    key: 'deleteField',\n    value: function deleteField(fieldName, className, database) {\n      var _this9 = this;\n\n      if (!classNameIsValid(className)) {\n        throw new Parse.Error(Parse.Error.INVALID_CLASS_NAME, invalidClassNameMessage(className));\n      }\n      if (!fieldNameIsValid(fieldName)) {\n        throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'invalid field name: ' + fieldName);\n      }\n      //Don't allow deleting the default fields.\n      if (!fieldNameIsValidForClass(fieldName, className)) {\n        throw new Parse.Error(136, 'field ' + fieldName + ' cannot be changed');\n      }\n\n      return this.getOneSchema(className, false, { clearCache: true }).catch(function (error) {\n        if (error === undefined) {\n          throw new Parse.Error(Parse.Error.INVALID_CLASS_NAME, 'Class ' + className + ' does not exist.');\n        } else {\n          throw error;\n        }\n      }).then(function (schema) {\n        if (!schema.fields[fieldName]) {\n          throw new Parse.Error(255, 'Field ' + fieldName + ' does not exist, cannot delete.');\n        }\n        if (schema.fields[fieldName].type == 'Relation') {\n          //For relations, drop the _Join table\n          return database.adapter.deleteFields(className, schema, [fieldName]).then(function () {\n            return database.adapter.deleteClass('_Join:' + fieldName + ':' + className);\n          });\n        }\n        return database.adapter.deleteFields(className, schema, [fieldName]);\n      }).then(function () {\n        _this9._cache.clear();\n      });\n    }\n\n    // Validates an object provided in REST format.\n    // Returns a promise that resolves to the new schema if this object is\n    // valid.\n\n  }, {\n    key: 'validateObject',\n    value: function validateObject(className, object, query) {\n      var geocount = 0;\n      var promise = this.enforceClassExists(className);\n\n      var _loop = function _loop(fieldName) {\n        if (object[fieldName] === undefined) {\n          return 'continue';\n        }\n        var expected = getType(object[fieldName]);\n        if (expected === 'GeoPoint') {\n          geocount++;\n        }\n        if (geocount > 1) {\n          // Make sure all field validation operations run before we return.\n          // If not - we are continuing to run logic, but already provided response from the server.\n          return {\n            v: promise.then(function () {\n              return Promise.reject(new Parse.Error(Parse.Error.INCORRECT_TYPE, 'there can only be one geopoint field in a class'));\n            })\n          };\n        }\n        if (!expected) {\n          return 'continue';\n        }\n        if (fieldName === 'ACL') {\n          // Every object has ACL implicitly.\n          return 'continue';\n        }\n\n        promise = promise.then(function (schema) {\n          return schema.enforceFieldExists(className, fieldName, expected);\n        });\n      };\n\n      for (var fieldName in object) {\n        var _ret = _loop(fieldName);\n\n        switch (_ret) {\n          case 'continue':\n            continue;\n\n          default:\n            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n        }\n      }\n      promise = thenValidateRequiredColumns(promise, className, object, query);\n      return promise;\n    }\n\n    // Validates that all the properties are set for the object\n\n  }, {\n    key: 'validateRequiredColumns',\n    value: function validateRequiredColumns(className, object, query) {\n      var columns = requiredColumns[className];\n      if (!columns || columns.length == 0) {\n        return Promise.resolve(this);\n      }\n\n      var missingColumns = columns.filter(function (column) {\n        if (query && query.objectId) {\n          if (object[column] && _typeof(object[column]) === \"object\") {\n            // Trying to delete a required column\n            return object[column].__op == 'Delete';\n          }\n          // Not trying to do anything there\n          return false;\n        }\n        return !object[column];\n      });\n\n      if (missingColumns.length > 0) {\n        throw new Parse.Error(Parse.Error.INCORRECT_TYPE, missingColumns[0] + ' is required.');\n      }\n      return Promise.resolve(this);\n    }\n\n    // Validates the base CLP for an operation\n\n  }, {\n    key: 'testBaseCLP',\n    value: function testBaseCLP(className, aclGroup, operation) {\n      if (!this.perms[className] || !this.perms[className][operation]) {\n        return true;\n      }\n      var classPerms = this.perms[className];\n      var perms = classPerms[operation];\n      // Handle the public scenario quickly\n      if (perms['*']) {\n        return true;\n      }\n      // Check permissions against the aclGroup provided (array of userId/roles)\n      if (aclGroup.some(function (acl) {\n        return perms[acl] === true;\n      })) {\n        return true;\n      }\n      return false;\n    }\n\n    // Validates an operation passes class-level-permissions set in the schema\n\n  }, {\n    key: 'validatePermission',\n    value: function validatePermission(className, aclGroup, operation) {\n      if (this.testBaseCLP(className, aclGroup, operation)) {\n        return Promise.resolve();\n      }\n\n      if (!this.perms[className] || !this.perms[className][operation]) {\n        return true;\n      }\n      var classPerms = this.perms[className];\n      var perms = classPerms[operation];\n\n      // If only for authenticated users\n      // make sure we have an aclGroup\n      if (perms['requiresAuthentication']) {\n        // If aclGroup has * (public)\n        if (!aclGroup || aclGroup.length == 0) {\n          throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Permission denied, user needs to be authenticated.');\n        } else if (aclGroup.indexOf('*') > -1 && aclGroup.length == 1) {\n          throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Permission denied, user needs to be authenticated.');\n        }\n        // no other CLP than requiresAuthentication\n        // let's resolve that!\n        if (Object.keys(perms).length == 1) {\n          return Promise.resolve();\n        }\n      }\n\n      // No matching CLP, let's check the Pointer permissions\n      // And handle those later\n      var permissionField = ['get', 'find'].indexOf(operation) > -1 ? 'readUserFields' : 'writeUserFields';\n\n      // Reject create when write lockdown\n      if (permissionField == 'writeUserFields' && operation == 'create') {\n        throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, 'Permission denied for action ' + operation + ' on class ' + className + '.');\n      }\n\n      // Process the readUserFields later\n      if (Array.isArray(classPerms[permissionField]) && classPerms[permissionField].length > 0) {\n        return Promise.resolve();\n      }\n      throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, 'Permission denied for action ' + operation + ' on class ' + className + '.');\n    }\n\n    // Returns the expected type for a className+key combination\n    // or undefined if the schema is not set\n\n  }, {\n    key: 'getExpectedType',\n    value: function getExpectedType(className, fieldName) {\n      if (this.data && this.data[className]) {\n        var expectedType = this.data[className][fieldName];\n        return expectedType === 'map' ? 'Object' : expectedType;\n      }\n      return undefined;\n    }\n\n    // Checks if a given class is in the schema.\n\n  }, {\n    key: 'hasClass',\n    value: function hasClass(className) {\n      var _this10 = this;\n\n      return this.reloadData().then(function () {\n        return !!_this10.data[className];\n      });\n    }\n  }]);\n\n  return SchemaController;\n}();\n\n// Returns a promise for a new Schema.\n\n\nexports.default = SchemaController;\nvar load = function load(dbAdapter, schemaCache, options) {\n  var schema = new SchemaController(dbAdapter, schemaCache);\n  return schema.reloadData(options).then(function () {\n    return schema;\n  });\n};\n\n// Builds a new schema (in schema API response format) out of an\n// existing mongo schema + a schemas API put request. This response\n// does not include the default fields, as it is intended to be passed\n// to mongoSchemaFromFieldsAndClassName. No validation is done here, it\n// is done in mongoSchemaFromFieldsAndClassName.\nfunction buildMergedSchemaObject(existingFields, putRequest) {\n  var newSchema = {};\n  var sysSchemaField = Object.keys(defaultColumns).indexOf(existingFields._id) === -1 ? [] : Object.keys(defaultColumns[existingFields._id]);\n  for (var oldField in existingFields) {\n    if (oldField !== '_id' && oldField !== 'ACL' && oldField !== 'updatedAt' && oldField !== 'createdAt' && oldField !== 'objectId') {\n      if (sysSchemaField.length > 0 && sysSchemaField.indexOf(oldField) !== -1) {\n        continue;\n      }\n      var fieldIsDeleted = putRequest[oldField] && putRequest[oldField].__op === 'Delete';\n      if (!fieldIsDeleted) {\n        newSchema[oldField] = existingFields[oldField];\n      }\n    }\n  }\n  for (var newField in putRequest) {\n    if (newField !== 'objectId' && putRequest[newField].__op !== 'Delete') {\n      if (sysSchemaField.length > 0 && sysSchemaField.indexOf(newField) !== -1) {\n        continue;\n      }\n      newSchema[newField] = putRequest[newField];\n    }\n  }\n  return newSchema;\n}\n\n// Given a schema promise, construct another schema promise that\n// validates this field once the schema loads.\nfunction thenValidateRequiredColumns(schemaPromise, className, object, query) {\n  return schemaPromise.then(function (schema) {\n    return schema.validateRequiredColumns(className, object, query);\n  });\n}\n\n// Gets the type from a REST API formatted object, where 'type' is\n// extended past javascript types to include the rest of the Parse\n// type system.\n// The output should be a valid schema value.\n// TODO: ensure that this is compatible with the format used in Open DB\nfunction getType(obj) {\n  var type = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);\n  switch (type) {\n    case 'boolean':\n      return 'Boolean';\n    case 'string':\n      return 'String';\n    case 'number':\n      return 'Number';\n    case 'map':\n    case 'object':\n      if (!obj) {\n        return undefined;\n      }\n      return getObjectType(obj);\n    case 'function':\n    case 'symbol':\n    case 'undefined':\n    default:\n      throw 'bad obj: ' + obj;\n  }\n}\n\n// This gets the type for non-JSON types like pointers and files, but\n// also gets the appropriate type for $ operators.\n// Returns null if the type is unknown.\nfunction getObjectType(obj) {\n  if (obj instanceof Array) {\n    return 'Array';\n  }\n  if (obj.__type) {\n    switch (obj.__type) {\n      case 'Pointer':\n        if (obj.className) {\n          return {\n            type: 'Pointer',\n            targetClass: obj.className\n          };\n        }\n        break;\n      case 'Relation':\n        if (obj.className) {\n          return {\n            type: 'Relation',\n            targetClass: obj.className\n          };\n        }\n        break;\n      case 'File':\n        if (obj.name) {\n          return 'File';\n        }\n        break;\n      case 'Date':\n        if (obj.iso) {\n          return 'Date';\n        }\n        break;\n      case 'GeoPoint':\n        if (obj.latitude != null && obj.longitude != null) {\n          return 'GeoPoint';\n        }\n        break;\n      case 'Bytes':\n        if (obj.base64) {\n          return;\n        }\n        break;\n    }\n    throw new Parse.Error(Parse.Error.INCORRECT_TYPE, \"This is not a valid \" + obj.__type);\n  }\n  if (obj['$ne']) {\n    return getObjectType(obj['$ne']);\n  }\n  if (obj.__op) {\n    switch (obj.__op) {\n      case 'Increment':\n        return 'Number';\n      case 'Delete':\n        return null;\n      case 'Add':\n      case 'AddUnique':\n      case 'Remove':\n        return 'Array';\n      case 'AddRelation':\n      case 'RemoveRelation':\n        return {\n          type: 'Relation',\n          targetClass: obj.objects[0].className\n        };\n      case 'Batch':\n        return getObjectType(obj.ops[0]);\n      default:\n        throw 'unexpected op: ' + obj.__op;\n    }\n  }\n  return 'Object';\n}\n\nexports.load = load;\nexports.classNameIsValid = classNameIsValid;\nexports.fieldNameIsValid = fieldNameIsValid;\nexports.invalidClassNameMessage = invalidClassNameMessage;\nexports.buildMergedSchemaObject = buildMergedSchemaObject;\nexports.systemClasses = systemClasses;\nexports.defaultColumns = defaultColumns;\nexports.convertSchemaToAdapterSchema = convertSchemaToAdapterSchema;\nexports.VolatileClassesSchemas = VolatileClassesSchemas;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/PromiseRouter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // A router that is based on promises rather than req/res/next.\n// This is intended to replace the use of express.Router to handle\n// subsections of the API surface.\n// This will make it easier to have methods like 'batch' that\n// themselves use our routing information, without disturbing express\n// components that external developers may be modifying.\n\nvar _node = require('parse/node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _express = require('express');\n\nvar _express2 = _interopRequireDefault(_express);\n\nvar _logger = require('./logger');\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nvar _util = require('util');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Layer = require('express/lib/router/layer');\n\nfunction validateParameter(key, value) {\n  if (key == 'className') {\n    if (value.match(/_?[A-Za-z][A-Za-z_0-9]*/)) {\n      return value;\n    }\n  } else if (key == 'objectId') {\n    if (value.match(/[A-Za-z0-9]+/)) {\n      return value;\n    }\n  } else {\n    return value;\n  }\n}\n\nvar PromiseRouter = function () {\n  // Each entry should be an object with:\n  // path: the path to route, in express format\n  // method: the HTTP method that this route handles.\n  //   Must be one of: POST, GET, PUT, DELETE\n  // handler: a function that takes request, and returns a promise.\n  //   Successful handlers should resolve to an object with fields:\n  //     status: optional. the http status code. defaults to 200\n  //     response: a json object with the content of the response\n  //     location: optional. a location header\n  function PromiseRouter() {\n    var routes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var appId = arguments[1];\n\n    _classCallCheck(this, PromiseRouter);\n\n    this.routes = routes;\n    this.appId = appId;\n    this.mountRoutes();\n  }\n\n  // Leave the opportunity to\n  // subclasses to mount their routes by overriding\n\n\n  _createClass(PromiseRouter, [{\n    key: 'mountRoutes',\n    value: function mountRoutes() {}\n\n    // Merge the routes into this one\n\n  }, {\n    key: 'merge',\n    value: function merge(router) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = router.routes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var route = _step.value;\n\n          this.routes.push(route);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'route',\n    value: function route(method, path) {\n      for (var _len = arguments.length, handlers = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        handlers[_key - 2] = arguments[_key];\n      }\n\n      switch (method) {\n        case 'POST':\n        case 'GET':\n        case 'PUT':\n        case 'DELETE':\n          break;\n        default:\n          throw 'cannot route method: ' + method;\n      }\n\n      var handler = handlers[0];\n\n      if (handlers.length > 1) {\n        handler = function handler(req) {\n          return handlers.reduce(function (promise, handler) {\n            return promise.then(function () {\n              return handler(req);\n            });\n          }, Promise.resolve());\n        };\n      }\n\n      this.routes.push({\n        path: path,\n        method: method,\n        handler: handler,\n        layer: new Layer(path, null, handler)\n      });\n    }\n\n    // Returns an object with:\n    //   handler: the handler that should deal with this request\n    //   params: any :-params that got parsed from the path\n    // Returns undefined if there is no match.\n\n  }, {\n    key: 'match',\n    value: function match(method, path) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.routes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var route = _step2.value;\n\n          if (route.method != method) {\n            continue;\n          }\n          var layer = route.layer || new Layer(route.path, null, route.handler);\n          var match = layer.match(path);\n          if (match) {\n            var _ret = function () {\n              var params = layer.params;\n              Object.keys(params).forEach(function (key) {\n                params[key] = validateParameter(key, params[key]);\n              });\n              return {\n                v: { params: params, handler: route.handler }\n              };\n            }();\n\n            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n\n    // Mount the routes on this router onto an express app (or express router)\n\n  }, {\n    key: 'mountOnto',\n    value: function mountOnto(expressApp) {\n      var _this = this;\n\n      this.routes.forEach(function (route) {\n        var method = route.method.toLowerCase();\n        var handler = makeExpressHandler(_this.appId, route.handler);\n        expressApp[method].call(expressApp, route.path, handler);\n      });\n      return expressApp;\n    }\n  }, {\n    key: 'expressRouter',\n    value: function expressRouter() {\n      return this.mountOnto(_express2.default.Router());\n    }\n  }, {\n    key: 'tryRouteRequest',\n    value: function tryRouteRequest(method, path, request) {\n      var match = this.match(method, path);\n      if (!match) {\n        throw new _node2.default.Error(_node2.default.Error.INVALID_JSON, 'cannot route ' + method + ' ' + path);\n      }\n      request.params = match.params;\n      return new Promise(function (resolve, reject) {\n        match.handler(request).then(resolve, reject);\n      });\n    }\n  }]);\n\n  return PromiseRouter;\n}();\n\n// A helper function to make an express handler out of a a promise\n// handler.\n// Express handlers should never throw; if a promise handler throws we\n// just treat it like it resolved to an error.\n\n\nexports.default = PromiseRouter;\nfunction makeExpressHandler(appId, promiseHandler) {\n  return function (req, res, next) {\n    try {\n      var url = maskSensitiveUrl(req);\n      var body = Object.assign({}, req.body);\n      var stringifiedBody = JSON.stringify(body, null, 2);\n      _logger2.default.verbose('REQUEST for [' + req.method + '] ' + url + ': ' + stringifiedBody, {\n        method: req.method,\n        url: url,\n        headers: req.headers,\n        body: body\n      });\n      promiseHandler(req).then(function (result) {\n        if (!result.response && !result.location && !result.text) {\n          _logger2.default.error('the handler did not include a \"response\" or a \"location\" field');\n          throw 'control should not get here';\n        }\n\n        var stringifiedResponse = JSON.stringify(result, null, 2);\n        _logger2.default.verbose('RESPONSE from [' + req.method + '] ' + url + ': ' + stringifiedResponse, { result: result });\n\n        var status = result.status || 200;\n        res.status(status);\n\n        if (result.text) {\n          res.send(result.text);\n          return;\n        }\n\n        if (result.location) {\n          res.set('Location', result.location);\n          // Override the default expressjs response\n          // as it double encodes %encoded chars in URL\n          if (!result.response) {\n            res.send('Found. Redirecting to ' + result.location);\n            return;\n          }\n        }\n        if (result.headers) {\n          Object.keys(result.headers).forEach(function (header) {\n            res.set(header, result.headers[header]);\n          });\n        }\n        res.json(result.response);\n      }, function (e) {\n        _logger2.default.error('Error generating response. ' + (0, _util.inspect)(e), { error: e });\n        next(e);\n      });\n    } catch (e) {\n      _logger2.default.error('Error handling request: ' + (0, _util.inspect)(e), { error: e });\n      next(e);\n    }\n  };\n}\n\nfunction maskSensitiveUrl(req) {\n  var maskUrl = req.originalUrl.toString();\n  var shouldMaskUrl = req.method === 'GET' && req.originalUrl.includes('/login') && !req.originalUrl.includes('classes');\n  if (shouldMaskUrl) {\n    maskUrl = _logger2.default.maskSensitiveUrl(maskUrl);\n  }\n  return maskUrl;\n}","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/requiredParameter.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (errorMessage) {\n  throw errorMessage;\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Routers/AnalyticsRouter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AnalyticsRouter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _PromiseRouter2 = require('../PromiseRouter');\n\nvar _PromiseRouter3 = _interopRequireDefault(_PromiseRouter2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // AnalyticsRouter.js\n\n\nfunction appOpened(req) {\n  var analyticsController = req.config.analyticsController;\n  return analyticsController.appOpened(req);\n}\n\nfunction trackEvent(req) {\n  var analyticsController = req.config.analyticsController;\n  return analyticsController.trackEvent(req);\n}\n\nvar AnalyticsRouter = exports.AnalyticsRouter = function (_PromiseRouter) {\n  _inherits(AnalyticsRouter, _PromiseRouter);\n\n  function AnalyticsRouter() {\n    _classCallCheck(this, AnalyticsRouter);\n\n    return _possibleConstructorReturn(this, (AnalyticsRouter.__proto__ || Object.getPrototypeOf(AnalyticsRouter)).apply(this, arguments));\n  }\n\n  _createClass(AnalyticsRouter, [{\n    key: 'mountRoutes',\n    value: function mountRoutes() {\n      this.route('POST', '/events/AppOpened', appOpened);\n      this.route('POST', '/events/:eventName', trackEvent);\n    }\n  }]);\n\n  return AnalyticsRouter;\n}(_PromiseRouter3.default);","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Routers/ClassesRouter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClassesRouter = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _PromiseRouter2 = require('../PromiseRouter');\n\nvar _PromiseRouter3 = _interopRequireDefault(_PromiseRouter2);\n\nvar _rest = require('../rest');\n\nvar _rest2 = _interopRequireDefault(_rest);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _node = require('parse/node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ALLOWED_GET_QUERY_KEYS = ['keys', 'include'];\n\nvar ClassesRouter = exports.ClassesRouter = function (_PromiseRouter) {\n  _inherits(ClassesRouter, _PromiseRouter);\n\n  function ClassesRouter() {\n    _classCallCheck(this, ClassesRouter);\n\n    return _possibleConstructorReturn(this, (ClassesRouter.__proto__ || Object.getPrototypeOf(ClassesRouter)).apply(this, arguments));\n  }\n\n  _createClass(ClassesRouter, [{\n    key: 'handleFind',\n    value: function handleFind(req) {\n      var body = Object.assign(req.body, ClassesRouter.JSONFromQuery(req.query));\n      var options = {};\n      var allowConstraints = ['skip', 'limit', 'order', 'count', 'keys', 'include', 'redirectClassNameForKey', 'where'];\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = Object.keys(body)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var key = _step.value;\n\n          if (allowConstraints.indexOf(key) === -1) {\n            throw new _node2.default.Error(_node2.default.Error.INVALID_QUERY, 'Invalid parameter for query: ' + key);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (body.skip) {\n        options.skip = Number(body.skip);\n      }\n      if (body.limit || body.limit === 0) {\n        options.limit = Number(body.limit);\n      } else {\n        options.limit = Number(100);\n      }\n      if (body.order) {\n        options.order = String(body.order);\n      }\n      if (body.count) {\n        options.count = true;\n      }\n      if (typeof body.keys == 'string') {\n        options.keys = body.keys;\n      }\n      if (body.include) {\n        options.include = String(body.include);\n      }\n      if (body.redirectClassNameForKey) {\n        options.redirectClassNameForKey = String(body.redirectClassNameForKey);\n      }\n      if (typeof body.where === 'string') {\n        body.where = JSON.parse(body.where);\n      }\n      return _rest2.default.find(req.config, req.auth, req.params.className, body.where, options, req.info.clientSDK).then(function (response) {\n        if (response && response.results) {\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = response.results[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var result = _step2.value;\n\n              if (result.sessionToken) {\n                result.sessionToken = req.info.sessionToken || result.sessionToken;\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        }\n        return { response: response };\n      });\n    }\n\n    // Returns a promise for a {response} object.\n\n  }, {\n    key: 'handleGet',\n    value: function handleGet(req) {\n      var body = Object.assign(req.body, ClassesRouter.JSONFromQuery(req.query));\n      var options = {};\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = Object.keys(body)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var key = _step3.value;\n\n          if (ALLOWED_GET_QUERY_KEYS.indexOf(key) === -1) {\n            throw new _node2.default.Error(_node2.default.Error.INVALID_QUERY, 'Improper encode of parameter');\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      if (typeof body.keys == 'string') {\n        options.keys = body.keys;\n      }\n      if (body.include) {\n        options.include = String(body.include);\n      }\n\n      return _rest2.default.get(req.config, req.auth, req.params.className, req.params.objectId, options, req.info.clientSDK).then(function (response) {\n        if (!response.results || response.results.length == 0) {\n          throw new _node2.default.Error(_node2.default.Error.OBJECT_NOT_FOUND, 'Object not found.');\n        }\n\n        if (req.params.className === \"_User\") {\n\n          delete response.results[0].sessionToken;\n\n          var user = response.results[0];\n\n          if (req.auth.user && user.objectId == req.auth.user.id) {\n            // Force the session token\n            response.results[0].sessionToken = req.info.sessionToken;\n          }\n        }\n        return { response: response.results[0] };\n      });\n    }\n  }, {\n    key: 'handleCreate',\n    value: function handleCreate(req) {\n      return _rest2.default.create(req.config, req.auth, req.params.className, req.body, req.info.clientSDK);\n    }\n  }, {\n    key: 'handleUpdate',\n    value: function handleUpdate(req) {\n      return _rest2.default.update(req.config, req.auth, req.params.className, req.params.objectId, req.body, req.info.clientSDK);\n    }\n  }, {\n    key: 'handleDelete',\n    value: function handleDelete(req) {\n      return _rest2.default.del(req.config, req.auth, req.params.className, req.params.objectId, req.info.clientSDK).then(function () {\n        return { response: {} };\n      });\n    }\n  }, {\n    key: 'mountRoutes',\n    value: function mountRoutes() {\n      var _this2 = this;\n\n      this.route('GET', '/classes/:className', function (req) {\n        return _this2.handleFind(req);\n      });\n      this.route('GET', '/classes/:className/:objectId', function (req) {\n        return _this2.handleGet(req);\n      });\n      this.route('POST', '/classes/:className', function (req) {\n        return _this2.handleCreate(req);\n      });\n      this.route('PUT', '/classes/:className/:objectId', function (req) {\n        return _this2.handleUpdate(req);\n      });\n      this.route('DELETE', '/classes/:className/:objectId', function (req) {\n        return _this2.handleDelete(req);\n      });\n    }\n  }], [{\n    key: 'JSONFromQuery',\n    value: function JSONFromQuery(query) {\n      var json = {};\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = _lodash2.default.entries(query)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var _step4$value = _slicedToArray(_step4.value, 2),\n              key = _step4$value[0],\n              value = _step4$value[1];\n\n          try {\n            json[key] = JSON.parse(value);\n          } catch (e) {\n            json[key] = value;\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return json;\n    }\n  }]);\n\n  return ClassesRouter;\n}(_PromiseRouter3.default);\n\nexports.default = ClassesRouter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/rest.js":"'use strict';\n\nvar _Auth = require('./Auth');\n\nvar _Auth2 = _interopRequireDefault(_Auth);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// This file contains helpers for running operations in REST format.\n// The goal is that handlers that explicitly handle an express route\n// should just be shallow wrappers around things in this file, but\n// these functions should not explicitly depend on the request\n// object.\n// This means that one of these handlers can support multiple\n// routes. That's useful for the routes that do really similar\n// things.\n\nvar Parse = require('parse/node').Parse;\n\n\nvar RestQuery = require('./RestQuery');\nvar RestWrite = require('./RestWrite');\nvar triggers = require('./triggers');\n\nfunction checkTriggers(className, config, types) {\n  return types.some(function (triggerType) {\n    return triggers.getTrigger(className, triggers.Types[triggerType], config.applicationId);\n  });\n}\n\nfunction checkLiveQuery(className, config) {\n  return config.liveQueryController && config.liveQueryController.hasLiveQuery(className);\n}\n\n// Returns a promise for an object with optional keys 'results' and 'count'.\nfunction find(config, auth, className, restWhere, restOptions, clientSDK) {\n  enforceRoleSecurity('find', className, auth);\n  return triggers.maybeRunQueryTrigger(triggers.Types.beforeFind, className, restWhere, restOptions, config, auth).then(function (result) {\n    restWhere = result.restWhere || restWhere;\n    restOptions = result.restOptions || restOptions;\n    var query = new RestQuery(config, auth, className, restWhere, restOptions, clientSDK);\n    return query.execute();\n  });\n}\n\n// get is just like find but only queries an objectId.\nvar get = function get(config, auth, className, objectId, restOptions, clientSDK) {\n  enforceRoleSecurity('get', className, auth);\n  var query = new RestQuery(config, auth, className, { objectId: objectId }, restOptions, clientSDK);\n  return query.execute();\n};\n\n// Returns a promise that doesn't resolve to any useful value.\nfunction del(config, auth, className, objectId) {\n  if (typeof objectId !== 'string') {\n    throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad objectId');\n  }\n\n  if (className === '_User' && !auth.couldUpdateUserId(objectId)) {\n    throw new Parse.Error(Parse.Error.SESSION_MISSING, 'insufficient auth to delete user');\n  }\n\n  enforceRoleSecurity('delete', className, auth);\n\n  var inflatedObject;\n\n  return Promise.resolve().then(function () {\n    var hasTriggers = checkTriggers(className, config, ['beforeDelete', 'afterDelete']);\n    var hasLiveQuery = checkLiveQuery(className, config);\n    if (hasTriggers || hasLiveQuery || className == '_Session') {\n      return find(config, _Auth2.default.master(config), className, { objectId: objectId }).then(function (response) {\n        if (response && response.results && response.results.length) {\n          response.results[0].className = className;\n\n          var cacheAdapter = config.cacheController;\n          cacheAdapter.user.del(response.results[0].sessionToken);\n          inflatedObject = Parse.Object.fromJSON(response.results[0]);\n          // Notify LiveQuery server if possible\n          config.liveQueryController.onAfterDelete(inflatedObject.className, inflatedObject);\n          return triggers.maybeRunTrigger(triggers.Types.beforeDelete, auth, inflatedObject, null, config);\n        }\n        throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found for delete.');\n      });\n    }\n    return Promise.resolve({});\n  }).then(function () {\n    if (!auth.isMaster) {\n      return auth.getUserRoles();\n    } else {\n      return;\n    }\n  }).then(function () {\n    var options = {};\n    if (!auth.isMaster) {\n      options.acl = ['*'];\n      if (auth.user) {\n        options.acl.push(auth.user.id);\n        options.acl = options.acl.concat(auth.userRoles);\n      }\n    }\n\n    return config.database.destroy(className, {\n      objectId: objectId\n    }, options);\n  }).then(function () {\n    return triggers.maybeRunTrigger(triggers.Types.afterDelete, auth, inflatedObject, null, config);\n  });\n}\n\n// Returns a promise for a {response, status, location} object.\nfunction create(config, auth, className, restObject, clientSDK) {\n  enforceRoleSecurity('create', className, auth);\n  var write = new RestWrite(config, auth, className, null, restObject, null, clientSDK);\n  return write.execute();\n}\n\n// Returns a promise that contains the fields of the update that the\n// REST API is supposed to return.\n// Usually, this is just updatedAt.\nfunction update(config, auth, className, objectId, restObject, clientSDK) {\n  enforceRoleSecurity('update', className, auth);\n\n  return Promise.resolve().then(function () {\n    var hasTriggers = checkTriggers(className, config, ['beforeSave', 'afterSave']);\n    var hasLiveQuery = checkLiveQuery(className, config);\n    if (hasTriggers || hasLiveQuery) {\n      return find(config, _Auth2.default.master(config), className, { objectId: objectId });\n    }\n    return Promise.resolve({});\n  }).then(function (response) {\n    var originalRestObject;\n    if (response && response.results && response.results.length) {\n      originalRestObject = response.results[0];\n    }\n\n    var write = new RestWrite(config, auth, className, { objectId: objectId }, restObject, originalRestObject, clientSDK);\n    return write.execute();\n  });\n}\n\n// Disallowing access to the _Role collection except by master key\nfunction enforceRoleSecurity(method, className, auth) {\n  if (className === '_Installation' && !auth.isMaster) {\n    if (method === 'delete' || method === 'find') {\n      var error = 'Clients aren\\'t allowed to perform the ' + method + ' operation on the installation collection.';\n      throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);\n    }\n  }\n}\n\nmodule.exports = {\n  create: create,\n  del: del,\n  find: find,\n  get: get,\n  update: update\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Auth.js":"'use strict';\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar Parse = require('parse/node').Parse;\nvar RestQuery = require('./RestQuery');\n\n// An Auth object tells you who is requesting something and whether\n// the master key was used.\n// userObject is a Parse.User and can be null if there's no user.\nfunction Auth() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      config = _ref.config,\n      _ref$isMaster = _ref.isMaster,\n      isMaster = _ref$isMaster === undefined ? false : _ref$isMaster,\n      user = _ref.user,\n      installationId = _ref.installationId;\n\n  this.config = config;\n  this.installationId = installationId;\n  this.isMaster = isMaster;\n  this.user = user;\n\n  // Assuming a users roles won't change during a single request, we'll\n  // only load them once.\n  this.userRoles = [];\n  this.fetchedRoles = false;\n  this.rolePromise = null;\n}\n\n// Whether this auth could possibly modify the given user id.\n// It still could be forbidden via ACLs even if this returns true.\nAuth.prototype.couldUpdateUserId = function (userId) {\n  if (this.isMaster) {\n    return true;\n  }\n  if (this.user && this.user.id === userId) {\n    return true;\n  }\n  return false;\n};\n\n// A helper to get a master-level Auth object\nfunction master(config) {\n  return new Auth({ config: config, isMaster: true });\n}\n\n// A helper to get a nobody-level Auth object\nfunction nobody(config) {\n  return new Auth({ config: config, isMaster: false });\n}\n\n// Returns a promise that resolves to an Auth object\nvar getAuthForSessionToken = function getAuthForSessionToken() {\n  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      config = _ref2.config,\n      sessionToken = _ref2.sessionToken,\n      installationId = _ref2.installationId;\n\n  return config.cacheController.user.get(sessionToken).then(function (userJSON) {\n    if (userJSON) {\n      var cachedUser = Parse.Object.fromJSON(userJSON);\n      return Promise.resolve(new Auth({ config: config, isMaster: false, installationId: installationId, user: cachedUser }));\n    }\n\n    var restOptions = {\n      limit: 1,\n      include: 'user'\n    };\n\n    var query = new RestQuery(config, master(config), '_Session', { sessionToken: sessionToken }, restOptions);\n    return query.execute().then(function (response) {\n      var results = response.results;\n      if (results.length !== 1 || !results[0]['user']) {\n        throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'invalid session token');\n      }\n\n      var now = new Date(),\n          expiresAt = results[0].expiresAt ? new Date(results[0].expiresAt.iso) : undefined;\n      if (expiresAt < now) {\n        throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Session token is expired.');\n      }\n      var obj = results[0]['user'];\n      delete obj.password;\n      obj['className'] = '_User';\n      obj['sessionToken'] = sessionToken;\n      config.cacheController.user.put(sessionToken, obj);\n      var userObject = Parse.Object.fromJSON(obj);\n      return new Auth({ config: config, isMaster: false, installationId: installationId, user: userObject });\n    });\n  });\n};\n\nvar getAuthForLegacySessionToken = function getAuthForLegacySessionToken() {\n  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      config = _ref3.config,\n      sessionToken = _ref3.sessionToken,\n      installationId = _ref3.installationId;\n\n  var restOptions = {\n    limit: 1\n  };\n  var query = new RestQuery(config, master(config), '_User', { sessionToken: sessionToken }, restOptions);\n  return query.execute().then(function (response) {\n    var results = response.results;\n    if (results.length !== 1) {\n      throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'invalid legacy session token');\n    }\n    var obj = results[0];\n    obj.className = '_User';\n    var userObject = Parse.Object.fromJSON(obj);\n    return new Auth({ config: config, isMaster: false, installationId: installationId, user: userObject });\n  });\n};\n\n// Returns a promise that resolves to an array of role names\nAuth.prototype.getUserRoles = function () {\n  if (this.isMaster || !this.user) {\n    return Promise.resolve([]);\n  }\n  if (this.fetchedRoles) {\n    return Promise.resolve(this.userRoles);\n  }\n  if (this.rolePromise) {\n    return this.rolePromise;\n  }\n  this.rolePromise = this._loadRoles();\n  return this.rolePromise;\n};\n\n// Iterates through the role tree and compiles a users roles\nAuth.prototype._loadRoles = function () {\n  var _this = this;\n\n  var cacheAdapter = this.config.cacheController;\n  return cacheAdapter.role.get(this.user.id).then(function (cachedRoles) {\n    if (cachedRoles != null) {\n      _this.fetchedRoles = true;\n      _this.userRoles = cachedRoles;\n      return Promise.resolve(cachedRoles);\n    }\n\n    var restWhere = {\n      'users': {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: _this.user.id\n      }\n    };\n    // First get the role ids this user is directly a member of\n    var query = new RestQuery(_this.config, master(_this.config), '_Role', restWhere, {});\n    return query.execute().then(function (response) {\n      var results = response.results;\n      if (!results.length) {\n        _this.userRoles = [];\n        _this.fetchedRoles = true;\n        _this.rolePromise = null;\n\n        cacheAdapter.role.put(_this.user.id, _this.userRoles);\n        return Promise.resolve(_this.userRoles);\n      }\n      var rolesMap = results.reduce(function (m, r) {\n        m.names.push(r.name);\n        m.ids.push(r.objectId);\n        return m;\n      }, { ids: [], names: [] });\n\n      // run the recursive finding\n      return _this._getAllRolesNamesForRoleIds(rolesMap.ids, rolesMap.names).then(function (roleNames) {\n        _this.userRoles = roleNames.map(function (r) {\n          return 'role:' + r;\n        });\n        _this.fetchedRoles = true;\n        _this.rolePromise = null;\n\n        cacheAdapter.role.put(_this.user.id, _this.userRoles);\n        return Promise.resolve(_this.userRoles);\n      });\n    });\n  });\n};\n\n// Given a list of roleIds, find all the parent roles, returns a promise with all names\nAuth.prototype._getAllRolesNamesForRoleIds = function (roleIDs) {\n  var _this2 = this;\n\n  var names = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var queriedRoles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var ins = roleIDs.filter(function (roleID) {\n    return queriedRoles[roleID] !== true;\n  }).map(function (roleID) {\n    // mark as queried\n    queriedRoles[roleID] = true;\n    return {\n      __type: 'Pointer',\n      className: '_Role',\n      objectId: roleID\n    };\n  });\n\n  // all roles are accounted for, return the names\n  if (ins.length == 0) {\n    return Promise.resolve([].concat(_toConsumableArray(new Set(names))));\n  }\n  // Build an OR query across all parentRoles\n  var restWhere = void 0;\n  if (ins.length == 1) {\n    restWhere = { 'roles': ins[0] };\n  } else {\n    restWhere = { 'roles': { '$in': ins } };\n  }\n  var query = new RestQuery(this.config, master(this.config), '_Role', restWhere, {});\n  return query.execute().then(function (response) {\n    var results = response.results;\n    // Nothing found\n    if (!results.length) {\n      return Promise.resolve(names);\n    }\n    // Map the results with all Ids and names\n    var resultMap = results.reduce(function (memo, role) {\n      memo.names.push(role.name);\n      memo.ids.push(role.objectId);\n      return memo;\n    }, { ids: [], names: [] });\n    // store the new found names\n    names = names.concat(resultMap.names);\n    // find the next ones, circular roles will be cut\n    return _this2._getAllRolesNamesForRoleIds(resultMap.ids, names, queriedRoles);\n  }).then(function (names) {\n    return Promise.resolve([].concat(_toConsumableArray(new Set(names))));\n  });\n};\n\nmodule.exports = {\n  Auth: Auth,\n  master: master,\n  nobody: nobody,\n  getAuthForSessionToken: getAuthForSessionToken,\n  getAuthForLegacySessionToken: getAuthForLegacySessionToken\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/RestQuery.js":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n// An object that encapsulates everything we need to run a 'find'\n// operation, encoded in the REST API format.\n\nvar SchemaController = require('./Controllers/SchemaController');\nvar Parse = require('parse/node').Parse;\nvar triggers = require('./triggers');\n\nvar AlwaysSelectedKeys = ['objectId', 'createdAt', 'updatedAt'];\n// restOptions can include:\n//   skip\n//   limit\n//   order\n//   count\n//   include\n//   keys\n//   redirectClassNameForKey\nfunction RestQuery(config, auth, className) {\n  var restWhere = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var restOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var clientSDK = arguments[5];\n\n\n  this.config = config;\n  this.auth = auth;\n  this.className = className;\n  this.restWhere = restWhere;\n  this.restOptions = restOptions;\n  this.clientSDK = clientSDK;\n  this.response = null;\n  this.findOptions = {};\n  if (!this.auth.isMaster) {\n    this.findOptions.acl = this.auth.user ? [this.auth.user.id] : null;\n    if (this.className == '_Session') {\n      if (!this.findOptions.acl) {\n        throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'This session token is invalid.');\n      }\n      this.restWhere = {\n        '$and': [this.restWhere, {\n          'user': {\n            __type: 'Pointer',\n            className: '_User',\n            objectId: this.auth.user.id\n          }\n        }]\n      };\n    }\n  }\n\n  this.doCount = false;\n\n  // The format for this.include is not the same as the format for the\n  // include option - it's the paths we should include, in order,\n  // stored as arrays, taking into account that we need to include foo\n  // before including foo.bar. Also it should dedupe.\n  // For example, passing an arg of include=foo.bar,foo.baz could lead to\n  // this.include = [['foo'], ['foo', 'baz'], ['foo', 'bar']]\n  this.include = [];\n\n  // If we have keys, we probably want to force some includes (n-1 level)\n  // See issue: https://github.com/ParsePlatform/parse-server/issues/3185\n  if (restOptions.hasOwnProperty('keys')) {\n    var keysForInclude = restOptions.keys.split(',').filter(function (key) {\n      // At least 2 components\n      return key.split(\".\").length > 1;\n    }).map(function (key) {\n      // Slice the last component (a.b.c -> a.b)\n      // Otherwise we'll include one level too much.\n      return key.slice(0, key.lastIndexOf(\".\"));\n    }).join(',');\n\n    // Concat the possibly present include string with the one from the keys\n    // Dedup / sorting is handle in 'include' case.\n    if (keysForInclude.length > 0) {\n      if (!restOptions.include || restOptions.include.length == 0) {\n        restOptions.include = keysForInclude;\n      } else {\n        restOptions.include += \",\" + keysForInclude;\n      }\n    }\n  }\n\n  for (var option in restOptions) {\n    switch (option) {\n      case 'keys':\n        {\n          var keys = restOptions.keys.split(',').concat(AlwaysSelectedKeys);\n          this.keys = Array.from(new Set(keys));\n          break;\n        }\n      case 'count':\n        this.doCount = true;\n        break;\n      case 'skip':\n      case 'limit':\n        this.findOptions[option] = restOptions[option];\n        break;\n      case 'order':\n        var fields = restOptions.order.split(',');\n        this.findOptions.sort = fields.reduce(function (sortMap, field) {\n          field = field.trim();\n          if (field[0] == '-') {\n            sortMap[field.slice(1)] = -1;\n          } else {\n            sortMap[field] = 1;\n          }\n          return sortMap;\n        }, {});\n        break;\n      case 'include':\n        {\n          var paths = restOptions.include.split(',');\n          // Load the existing includes (from keys)\n          var pathSet = paths.reduce(function (memo, path) {\n            // Split each paths on . (a.b.c -> [a,b,c])\n            // reduce to create all paths\n            // ([a,b,c] -> {a: true, 'a.b': true, 'a.b.c': true})\n            return path.split('.').reduce(function (memo, path, index, parts) {\n              memo[parts.slice(0, index + 1).join('.')] = true;\n              return memo;\n            }, memo);\n          }, {});\n\n          this.include = Object.keys(pathSet).map(function (s) {\n            return s.split('.');\n          }).sort(function (a, b) {\n            return a.length - b.length; // Sort by number of components\n          });\n          break;\n        }\n      case 'redirectClassNameForKey':\n        this.redirectKey = restOptions.redirectClassNameForKey;\n        this.redirectClassName = null;\n        break;\n      default:\n        throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad option: ' + option);\n    }\n  }\n}\n\n// A convenient method to perform all the steps of processing a query\n// in order.\n// Returns a promise for the response - an object with optional keys\n// 'results' and 'count'.\n// TODO: consolidate the replaceX functions\nRestQuery.prototype.execute = function (executeOptions) {\n  var _this = this;\n\n  return Promise.resolve().then(function () {\n    return _this.buildRestWhere();\n  }).then(function () {\n    return _this.runFind(executeOptions);\n  }).then(function () {\n    return _this.runCount();\n  }).then(function () {\n    return _this.handleInclude();\n  }).then(function () {\n    return _this.runAfterFindTrigger();\n  }).then(function () {\n    return _this.response;\n  });\n};\n\nRestQuery.prototype.buildRestWhere = function () {\n  var _this2 = this;\n\n  return Promise.resolve().then(function () {\n    return _this2.getUserAndRoleACL();\n  }).then(function () {\n    return _this2.redirectClassNameForKey();\n  }).then(function () {\n    return _this2.validateClientClassCreation();\n  }).then(function () {\n    return _this2.replaceSelect();\n  }).then(function () {\n    return _this2.replaceDontSelect();\n  }).then(function () {\n    return _this2.replaceInQuery();\n  }).then(function () {\n    return _this2.replaceNotInQuery();\n  });\n};\n\n// Uses the Auth object to get the list of roles, adds the user id\nRestQuery.prototype.getUserAndRoleACL = function () {\n  var _this3 = this;\n\n  if (this.auth.isMaster || !this.auth.user) {\n    return Promise.resolve();\n  }\n  return this.auth.getUserRoles().then(function (roles) {\n    // Concat with the roles to prevent duplications on multiple calls\n    var aclSet = new Set([].concat(_this3.findOptions.acl, roles));\n    _this3.findOptions.acl = Array.from(aclSet);\n    return Promise.resolve();\n  });\n};\n\n// Changes the className if redirectClassNameForKey is set.\n// Returns a promise.\nRestQuery.prototype.redirectClassNameForKey = function () {\n  var _this4 = this;\n\n  if (!this.redirectKey) {\n    return Promise.resolve();\n  }\n\n  // We need to change the class name based on the schema\n  return this.config.database.redirectClassNameForKey(this.className, this.redirectKey).then(function (newClassName) {\n    _this4.className = newClassName;\n    _this4.redirectClassName = newClassName;\n  });\n};\n\n// Validates this operation against the allowClientClassCreation config.\nRestQuery.prototype.validateClientClassCreation = function () {\n  var _this5 = this;\n\n  if (this.config.allowClientClassCreation === false && !this.auth.isMaster && SchemaController.systemClasses.indexOf(this.className) === -1) {\n    return this.config.database.loadSchema().then(function (schemaController) {\n      return schemaController.hasClass(_this5.className);\n    }).then(function (hasClass) {\n      if (hasClass !== true) {\n        throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, 'This user is not allowed to access ' + 'non-existent class: ' + _this5.className);\n      }\n    });\n  } else {\n    return Promise.resolve();\n  }\n};\n\nfunction transformInQuery(inQueryObject, className, results) {\n  var values = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = results[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var result = _step.value;\n\n      values.push({\n        __type: 'Pointer',\n        className: className,\n        objectId: result.objectId\n      });\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  delete inQueryObject['$inQuery'];\n  if (Array.isArray(inQueryObject['$in'])) {\n    inQueryObject['$in'] = inQueryObject['$in'].concat(values);\n  } else {\n    inQueryObject['$in'] = values;\n  }\n}\n\n// Replaces a $inQuery clause by running the subquery, if there is an\n// $inQuery clause.\n// The $inQuery clause turns into an $in with values that are just\n// pointers to the objects returned in the subquery.\nRestQuery.prototype.replaceInQuery = function () {\n  var _this6 = this;\n\n  var inQueryObject = findObjectWithKey(this.restWhere, '$inQuery');\n  if (!inQueryObject) {\n    return;\n  }\n\n  // The inQuery value must have precisely two keys - where and className\n  var inQueryValue = inQueryObject['$inQuery'];\n  if (!inQueryValue.where || !inQueryValue.className) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $inQuery');\n  }\n\n  var additionalOptions = {\n    redirectClassNameForKey: inQueryValue.redirectClassNameForKey\n  };\n\n  var subquery = new RestQuery(this.config, this.auth, inQueryValue.className, inQueryValue.where, additionalOptions);\n  return subquery.execute().then(function (response) {\n    transformInQuery(inQueryObject, subquery.className, response.results);\n    // Recurse to repeat\n    return _this6.replaceInQuery();\n  });\n};\n\nfunction transformNotInQuery(notInQueryObject, className, results) {\n  var values = [];\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = results[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var result = _step2.value;\n\n      values.push({\n        __type: 'Pointer',\n        className: className,\n        objectId: result.objectId\n      });\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  delete notInQueryObject['$notInQuery'];\n  if (Array.isArray(notInQueryObject['$nin'])) {\n    notInQueryObject['$nin'] = notInQueryObject['$nin'].concat(values);\n  } else {\n    notInQueryObject['$nin'] = values;\n  }\n}\n\n// Replaces a $notInQuery clause by running the subquery, if there is an\n// $notInQuery clause.\n// The $notInQuery clause turns into a $nin with values that are just\n// pointers to the objects returned in the subquery.\nRestQuery.prototype.replaceNotInQuery = function () {\n  var _this7 = this;\n\n  var notInQueryObject = findObjectWithKey(this.restWhere, '$notInQuery');\n  if (!notInQueryObject) {\n    return;\n  }\n\n  // The notInQuery value must have precisely two keys - where and className\n  var notInQueryValue = notInQueryObject['$notInQuery'];\n  if (!notInQueryValue.where || !notInQueryValue.className) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $notInQuery');\n  }\n\n  var additionalOptions = {\n    redirectClassNameForKey: notInQueryValue.redirectClassNameForKey\n  };\n\n  var subquery = new RestQuery(this.config, this.auth, notInQueryValue.className, notInQueryValue.where, additionalOptions);\n  return subquery.execute().then(function (response) {\n    transformNotInQuery(notInQueryObject, subquery.className, response.results);\n    // Recurse to repeat\n    return _this7.replaceNotInQuery();\n  });\n};\n\nvar transformSelect = function transformSelect(selectObject, key, objects) {\n  var values = [];\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = objects[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var result = _step3.value;\n\n      values.push(result[key]);\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  delete selectObject['$select'];\n  if (Array.isArray(selectObject['$in'])) {\n    selectObject['$in'] = selectObject['$in'].concat(values);\n  } else {\n    selectObject['$in'] = values;\n  }\n};\n\n// Replaces a $select clause by running the subquery, if there is a\n// $select clause.\n// The $select clause turns into an $in with values selected out of\n// the subquery.\n// Returns a possible-promise.\nRestQuery.prototype.replaceSelect = function () {\n  var _this8 = this;\n\n  var selectObject = findObjectWithKey(this.restWhere, '$select');\n  if (!selectObject) {\n    return;\n  }\n\n  // The select value must have precisely two keys - query and key\n  var selectValue = selectObject['$select'];\n  // iOS SDK don't send where if not set, let it pass\n  if (!selectValue.query || !selectValue.key || _typeof(selectValue.query) !== 'object' || !selectValue.query.className || Object.keys(selectValue).length !== 2) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $select');\n  }\n\n  var additionalOptions = {\n    redirectClassNameForKey: selectValue.query.redirectClassNameForKey\n  };\n\n  var subquery = new RestQuery(this.config, this.auth, selectValue.query.className, selectValue.query.where, additionalOptions);\n  return subquery.execute().then(function (response) {\n    transformSelect(selectObject, selectValue.key, response.results);\n    // Keep replacing $select clauses\n    return _this8.replaceSelect();\n  });\n};\n\nvar transformDontSelect = function transformDontSelect(dontSelectObject, key, objects) {\n  var values = [];\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = objects[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var result = _step4.value;\n\n      values.push(result[key]);\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  delete dontSelectObject['$dontSelect'];\n  if (Array.isArray(dontSelectObject['$nin'])) {\n    dontSelectObject['$nin'] = dontSelectObject['$nin'].concat(values);\n  } else {\n    dontSelectObject['$nin'] = values;\n  }\n};\n\n// Replaces a $dontSelect clause by running the subquery, if there is a\n// $dontSelect clause.\n// The $dontSelect clause turns into an $nin with values selected out of\n// the subquery.\n// Returns a possible-promise.\nRestQuery.prototype.replaceDontSelect = function () {\n  var _this9 = this;\n\n  var dontSelectObject = findObjectWithKey(this.restWhere, '$dontSelect');\n  if (!dontSelectObject) {\n    return;\n  }\n\n  // The dontSelect value must have precisely two keys - query and key\n  var dontSelectValue = dontSelectObject['$dontSelect'];\n  if (!dontSelectValue.query || !dontSelectValue.key || _typeof(dontSelectValue.query) !== 'object' || !dontSelectValue.query.className || Object.keys(dontSelectValue).length !== 2) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $dontSelect');\n  }\n  var additionalOptions = {\n    redirectClassNameForKey: dontSelectValue.query.redirectClassNameForKey\n  };\n\n  var subquery = new RestQuery(this.config, this.auth, dontSelectValue.query.className, dontSelectValue.query.where, additionalOptions);\n  return subquery.execute().then(function (response) {\n    transformDontSelect(dontSelectObject, dontSelectValue.key, response.results);\n    // Keep replacing $dontSelect clauses\n    return _this9.replaceDontSelect();\n  });\n};\n\nvar cleanResultOfSensitiveUserInfo = function cleanResultOfSensitiveUserInfo(result, auth, config) {\n  delete result.password;\n\n  if (auth.isMaster || auth.user && auth.user.id === result.objectId) {\n    return;\n  }\n\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = config.userSensitiveFields[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var field = _step5.value;\n\n      delete result[field];\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n};\n\nvar cleanResultAuthData = function cleanResultAuthData(result) {\n  if (result.authData) {\n    Object.keys(result.authData).forEach(function (provider) {\n      if (result.authData[provider] === null) {\n        delete result.authData[provider];\n      }\n    });\n\n    if (Object.keys(result.authData).length == 0) {\n      delete result.authData;\n    }\n  }\n};\n\n// Returns a promise for whether it was successful.\n// Populates this.response with an object that only has 'results'.\nRestQuery.prototype.runFind = function () {\n  var _this10 = this;\n\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (this.findOptions.limit === 0) {\n    this.response = { results: [] };\n    return Promise.resolve();\n  }\n  var findOptions = Object.assign({}, this.findOptions);\n  if (this.keys) {\n    findOptions.keys = this.keys.map(function (key) {\n      return key.split('.')[0];\n    });\n  }\n  if (options.op) {\n    findOptions.op = options.op;\n  }\n  return this.config.database.find(this.className, this.restWhere, findOptions).then(function (results) {\n    if (_this10.className === '_User') {\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = results[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var result = _step6.value;\n\n          cleanResultOfSensitiveUserInfo(result, _this10.auth, _this10.config);\n          cleanResultAuthData(result);\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n\n    _this10.config.filesController.expandFilesInObject(_this10.config, results);\n\n    if (_this10.redirectClassName) {\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = results[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var r = _step7.value;\n\n          r.className = _this10.redirectClassName;\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n    }\n    _this10.response = { results: results };\n  });\n};\n\n// Returns a promise for whether it was successful.\n// Populates this.response.count with the count\nRestQuery.prototype.runCount = function () {\n  var _this11 = this;\n\n  if (!this.doCount) {\n    return;\n  }\n  this.findOptions.count = true;\n  delete this.findOptions.skip;\n  delete this.findOptions.limit;\n  return this.config.database.find(this.className, this.restWhere, this.findOptions).then(function (c) {\n    _this11.response.count = c;\n  });\n};\n\n// Augments this.response with data at the paths provided in this.include.\nRestQuery.prototype.handleInclude = function () {\n  var _this12 = this;\n\n  if (this.include.length == 0) {\n    return;\n  }\n\n  var pathResponse = includePath(this.config, this.auth, this.response, this.include[0], this.restOptions);\n  if (pathResponse.then) {\n    return pathResponse.then(function (newResponse) {\n      _this12.response = newResponse;\n      _this12.include = _this12.include.slice(1);\n      return _this12.handleInclude();\n    });\n  } else if (this.include.length > 0) {\n    this.include = this.include.slice(1);\n    return this.handleInclude();\n  }\n\n  return pathResponse;\n};\n\n//Returns a promise of a processed set of results\nRestQuery.prototype.runAfterFindTrigger = function () {\n  var _this13 = this;\n\n  if (!this.response) {\n    return;\n  }\n  // Avoid doing any setup for triggers if there is no 'afterFind' trigger for this class.\n  var hasAfterFindHook = triggers.triggerExists(this.className, triggers.Types.afterFind, this.config.applicationId);\n  if (!hasAfterFindHook) {\n    return Promise.resolve();\n  }\n  // Run afterFind trigger and set the new results\n  return triggers.maybeRunAfterFindTrigger(triggers.Types.afterFind, this.auth, this.className, this.response.results, this.config).then(function (results) {\n    _this13.response.results = results;\n  });\n};\n\n// Adds included values to the response.\n// Path is a list of field names.\n// Returns a promise for an augmented response.\nfunction includePath(config, auth, response, path) {\n  var restOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n  var pointers = findPointers(response.results, path);\n  if (pointers.length == 0) {\n    return response;\n  }\n  var pointersHash = {};\n  var _iteratorNormalCompletion8 = true;\n  var _didIteratorError8 = false;\n  var _iteratorError8 = undefined;\n\n  try {\n    for (var _iterator8 = pointers[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n      var pointer = _step8.value;\n\n      if (!pointer) {\n        continue;\n      }\n      var className = pointer.className;\n      // only include the good pointers\n      if (className) {\n        pointersHash[className] = pointersHash[className] || new Set();\n        pointersHash[className].add(pointer.objectId);\n      }\n    }\n  } catch (err) {\n    _didIteratorError8 = true;\n    _iteratorError8 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion8 && _iterator8.return) {\n        _iterator8.return();\n      }\n    } finally {\n      if (_didIteratorError8) {\n        throw _iteratorError8;\n      }\n    }\n  }\n\n  var includeRestOptions = {};\n  if (restOptions.keys) {\n    var keys = new Set(restOptions.keys.split(','));\n    var keySet = Array.from(keys).reduce(function (set, key) {\n      var keyPath = key.split('.');\n      var i = 0;\n      for (i; i < path.length; i++) {\n        if (path[i] != keyPath[i]) {\n          return set;\n        }\n      }\n      if (i < keyPath.length) {\n        set.add(keyPath[i]);\n      }\n      return set;\n    }, new Set());\n    if (keySet.size > 0) {\n      includeRestOptions.keys = Array.from(keySet).join(',');\n    }\n  }\n\n  var queryPromises = Object.keys(pointersHash).map(function (className) {\n    var where = { 'objectId': { '$in': Array.from(pointersHash[className]) } };\n    var query = new RestQuery(config, auth, className, where, includeRestOptions);\n    return query.execute({ op: 'get' }).then(function (results) {\n      results.className = className;\n      return Promise.resolve(results);\n    });\n  });\n\n  // Get the objects for all these object ids\n  return Promise.all(queryPromises).then(function (responses) {\n    var replace = responses.reduce(function (replace, includeResponse) {\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = includeResponse.results[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var obj = _step9.value;\n\n          obj.__type = 'Object';\n          obj.className = includeResponse.className;\n\n          if (obj.className == \"_User\" && !auth.isMaster) {\n            delete obj.sessionToken;\n            delete obj.authData;\n          }\n          replace[obj.objectId] = obj;\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return) {\n            _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n\n      return replace;\n    }, {});\n\n    var resp = {\n      results: replacePointers(response.results, path, replace)\n    };\n    if (response.count) {\n      resp.count = response.count;\n    }\n    return resp;\n  });\n}\n\n// Object may be a list of REST-format object to find pointers in, or\n// it may be a single object.\n// If the path yields things that aren't pointers, this throws an error.\n// Path is a list of fields to search into.\n// Returns a list of pointers in REST format.\nfunction findPointers(object, path) {\n  if (object instanceof Array) {\n    var answer = [];\n    var _iteratorNormalCompletion10 = true;\n    var _didIteratorError10 = false;\n    var _iteratorError10 = undefined;\n\n    try {\n      for (var _iterator10 = object[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n        var x = _step10.value;\n\n        answer = answer.concat(findPointers(x, path));\n      }\n    } catch (err) {\n      _didIteratorError10 = true;\n      _iteratorError10 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion10 && _iterator10.return) {\n          _iterator10.return();\n        }\n      } finally {\n        if (_didIteratorError10) {\n          throw _iteratorError10;\n        }\n      }\n    }\n\n    return answer;\n  }\n\n  if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object' || !object) {\n    return [];\n  }\n\n  if (path.length == 0) {\n    if (object === null || object.__type == 'Pointer') {\n      return [object];\n    }\n    return [];\n  }\n\n  var subobject = object[path[0]];\n  if (!subobject) {\n    return [];\n  }\n  return findPointers(subobject, path.slice(1));\n}\n\n// Object may be a list of REST-format objects to replace pointers\n// in, or it may be a single object.\n// Path is a list of fields to search into.\n// replace is a map from object id -> object.\n// Returns something analogous to object, but with the appropriate\n// pointers inflated.\nfunction replacePointers(object, path, replace) {\n  if (object instanceof Array) {\n    return object.map(function (obj) {\n      return replacePointers(obj, path, replace);\n    }).filter(function (obj) {\n      return typeof obj !== 'undefined';\n    });\n  }\n\n  if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object' || !object) {\n    return object;\n  }\n\n  if (path.length === 0) {\n    if (object && object.__type === 'Pointer') {\n      return replace[object.objectId];\n    }\n    return object;\n  }\n\n  var subobject = object[path[0]];\n  if (!subobject) {\n    return object;\n  }\n  var newsub = replacePointers(subobject, path.slice(1), replace);\n  var answer = {};\n  for (var key in object) {\n    if (key == path[0]) {\n      answer[key] = newsub;\n    } else {\n      answer[key] = object[key];\n    }\n  }\n  return answer;\n}\n\n// Finds a subobject that has the given key, if there is one.\n// Returns undefined otherwise.\nfunction findObjectWithKey(root, key) {\n  if ((typeof root === 'undefined' ? 'undefined' : _typeof(root)) !== 'object') {\n    return;\n  }\n  if (root instanceof Array) {\n    var _iteratorNormalCompletion11 = true;\n    var _didIteratorError11 = false;\n    var _iteratorError11 = undefined;\n\n    try {\n      for (var _iterator11 = root[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n        var item = _step11.value;\n\n        var answer = findObjectWithKey(item, key);\n        if (answer) {\n          return answer;\n        }\n      }\n    } catch (err) {\n      _didIteratorError11 = true;\n      _iteratorError11 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion11 && _iterator11.return) {\n          _iterator11.return();\n        }\n      } finally {\n        if (_didIteratorError11) {\n          throw _iteratorError11;\n        }\n      }\n    }\n  }\n  if (root && root[key]) {\n    return root;\n  }\n  for (var subkey in root) {\n    var _answer = findObjectWithKey(root[subkey], key);\n    if (_answer) {\n      return _answer;\n    }\n  }\n}\n\nmodule.exports = RestQuery;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/triggers.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Types = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; // triggers.js\n\n\nexports.addFunction = addFunction;\nexports.addJob = addJob;\nexports.addTrigger = addTrigger;\nexports.removeFunction = removeFunction;\nexports.removeJob = removeJob;\nexports.removeTrigger = removeTrigger;\nexports._unregister = _unregister;\nexports._unregisterAll = _unregisterAll;\nexports.getTrigger = getTrigger;\nexports.triggerExists = triggerExists;\nexports.getFunction = getFunction;\nexports.getJob = getJob;\nexports.getJobs = getJobs;\nexports.getValidator = getValidator;\nexports.getRequestObject = getRequestObject;\nexports.getRequestQueryObject = getRequestQueryObject;\nexports.getResponseObject = getResponseObject;\nexports.maybeRunAfterFindTrigger = maybeRunAfterFindTrigger;\nexports.maybeRunQueryTrigger = maybeRunQueryTrigger;\nexports.maybeRunTrigger = maybeRunTrigger;\nexports.inflate = inflate;\n\nvar _node = require('parse/node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _logger = require('./logger');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Types = exports.Types = {\n  beforeSave: 'beforeSave',\n  afterSave: 'afterSave',\n  beforeDelete: 'beforeDelete',\n  afterDelete: 'afterDelete',\n  beforeFind: 'beforeFind',\n  afterFind: 'afterFind'\n};\n\nvar baseStore = function baseStore() {\n  var Validators = {};\n  var Functions = {};\n  var Jobs = {};\n  var Triggers = Object.keys(Types).reduce(function (base, key) {\n    base[key] = {};\n    return base;\n  }, {});\n\n  return Object.freeze({\n    Functions: Functions,\n    Jobs: Jobs,\n    Validators: Validators,\n    Triggers: Triggers\n  });\n};\n\nvar _triggerStore = {};\n\nfunction addFunction(functionName, handler, validationHandler, applicationId) {\n  applicationId = applicationId || _node2.default.applicationId;\n  _triggerStore[applicationId] = _triggerStore[applicationId] || baseStore();\n  _triggerStore[applicationId].Functions[functionName] = handler;\n  _triggerStore[applicationId].Validators[functionName] = validationHandler;\n}\n\nfunction addJob(jobName, handler, applicationId) {\n  applicationId = applicationId || _node2.default.applicationId;\n  _triggerStore[applicationId] = _triggerStore[applicationId] || baseStore();\n  _triggerStore[applicationId].Jobs[jobName] = handler;\n}\n\nfunction addTrigger(type, className, handler, applicationId) {\n  applicationId = applicationId || _node2.default.applicationId;\n  _triggerStore[applicationId] = _triggerStore[applicationId] || baseStore();\n  _triggerStore[applicationId].Triggers[type][className] = handler;\n}\n\nfunction removeFunction(functionName, applicationId) {\n  applicationId = applicationId || _node2.default.applicationId;\n  delete _triggerStore[applicationId].Functions[functionName];\n}\n\nfunction removeJob(jobName, applicationId) {\n  applicationId = applicationId || _node2.default.applicationId;\n  delete _triggerStore[applicationId].Jobs[jobName];\n}\n\nfunction removeTrigger(type, className, applicationId) {\n  applicationId = applicationId || _node2.default.applicationId;\n  delete _triggerStore[applicationId].Triggers[type][className];\n}\n\nfunction _unregister(appId, category, className, type) {\n  if (type) {\n    removeTrigger(className, type, appId);\n    delete _triggerStore[appId][category][className][type];\n  } else {\n    delete _triggerStore[appId][category][className];\n  }\n}\n\nfunction _unregisterAll() {\n  Object.keys(_triggerStore).forEach(function (appId) {\n    return delete _triggerStore[appId];\n  });\n}\n\nfunction getTrigger(className, triggerType, applicationId) {\n  if (!applicationId) {\n    throw \"Missing ApplicationID\";\n  }\n  var manager = _triggerStore[applicationId];\n  if (manager && manager.Triggers && manager.Triggers[triggerType] && manager.Triggers[triggerType][className]) {\n    return manager.Triggers[triggerType][className];\n  }\n  return undefined;\n}\n\nfunction triggerExists(className, type, applicationId) {\n  return getTrigger(className, type, applicationId) != undefined;\n}\n\nfunction getFunction(functionName, applicationId) {\n  var manager = _triggerStore[applicationId];\n  if (manager && manager.Functions) {\n    return manager.Functions[functionName];\n  }\n  return undefined;\n}\n\nfunction getJob(jobName, applicationId) {\n  var manager = _triggerStore[applicationId];\n  if (manager && manager.Jobs) {\n    return manager.Jobs[jobName];\n  }\n  return undefined;\n}\n\nfunction getJobs(applicationId) {\n  var manager = _triggerStore[applicationId];\n  if (manager && manager.Jobs) {\n    return manager.Jobs;\n  }\n  return undefined;\n}\n\nfunction getValidator(functionName, applicationId) {\n  var manager = _triggerStore[applicationId];\n  if (manager && manager.Validators) {\n    return manager.Validators[functionName];\n  }\n  return undefined;\n}\n\nfunction getRequestObject(triggerType, auth, parseObject, originalParseObject, config) {\n  var request = {\n    triggerName: triggerType,\n    object: parseObject,\n    master: false,\n    log: config.loggerController\n  };\n\n  if (originalParseObject) {\n    request.original = originalParseObject;\n  }\n\n  if (!auth) {\n    return request;\n  }\n  if (auth.isMaster) {\n    request['master'] = true;\n  }\n  if (auth.user) {\n    request['user'] = auth.user;\n  }\n  if (auth.installationId) {\n    request['installationId'] = auth.installationId;\n  }\n  return request;\n}\n\nfunction getRequestQueryObject(triggerType, auth, query, config) {\n  var request = {\n    triggerName: triggerType,\n    query: query,\n    master: false,\n    log: config.loggerController\n  };\n\n  if (!auth) {\n    return request;\n  }\n  if (auth.isMaster) {\n    request['master'] = true;\n  }\n  if (auth.user) {\n    request['user'] = auth.user;\n  }\n  if (auth.installationId) {\n    request['installationId'] = auth.installationId;\n  }\n  return request;\n}\n\n// Creates the response object, and uses the request object to pass data\n// The API will call this with REST API formatted objects, this will\n// transform them to Parse.Object instances expected by Cloud Code.\n// Any changes made to the object in a beforeSave will be included.\nfunction getResponseObject(request, resolve, reject) {\n  return {\n    success: function success(response) {\n      if (request.triggerName === Types.afterFind) {\n        if (!response) {\n          response = request.objects;\n        }\n        response = response.map(function (object) {\n          return object.toJSON();\n        });\n        return resolve(response);\n      }\n      // Use the JSON response\n      if (response && !request.object.equals(response) && request.triggerName === Types.beforeSave) {\n        return resolve(response);\n      }\n      response = {};\n      if (request.triggerName === Types.beforeSave) {\n        response['object'] = request.object._getSaveJSON();\n      }\n      return resolve(response);\n    },\n    error: function error(code, message) {\n      if (!message) {\n        message = code;\n        code = _node2.default.Error.SCRIPT_FAILED;\n      }\n      var scriptError = new _node2.default.Error(code, message);\n      return reject(scriptError);\n    }\n  };\n}\n\nfunction userIdForLog(auth) {\n  return auth && auth.user ? auth.user.id : undefined;\n}\n\nfunction logTriggerAfterHook(triggerType, className, input, auth) {\n  var cleanInput = _logger.logger.truncateLogMessage(JSON.stringify(input));\n  _logger.logger.info(triggerType + ' triggered for ' + className + ' for user ' + userIdForLog(auth) + ':\\n  Input: ' + cleanInput, {\n    className: className,\n    triggerType: triggerType,\n    user: userIdForLog(auth)\n  });\n}\n\nfunction logTriggerSuccessBeforeHook(triggerType, className, input, result, auth) {\n  var cleanInput = _logger.logger.truncateLogMessage(JSON.stringify(input));\n  var cleanResult = _logger.logger.truncateLogMessage(JSON.stringify(result));\n  _logger.logger.info(triggerType + ' triggered for ' + className + ' for user ' + userIdForLog(auth) + ':\\n  Input: ' + cleanInput + '\\n  Result: ' + cleanResult, {\n    className: className,\n    triggerType: triggerType,\n    user: userIdForLog(auth)\n  });\n}\n\nfunction logTriggerErrorBeforeHook(triggerType, className, input, auth, error) {\n  var cleanInput = _logger.logger.truncateLogMessage(JSON.stringify(input));\n  _logger.logger.error(triggerType + ' failed for ' + className + ' for user ' + userIdForLog(auth) + ':\\n  Input: ' + cleanInput + '\\n  Error: ' + JSON.stringify(error), {\n    className: className,\n    triggerType: triggerType,\n    error: error,\n    user: userIdForLog(auth)\n  });\n}\n\nfunction maybeRunAfterFindTrigger(triggerType, auth, className, objects, config) {\n  return new Promise(function (resolve, reject) {\n    var trigger = getTrigger(className, triggerType, config.applicationId);\n    if (!trigger) {\n      return resolve();\n    }\n    var request = getRequestObject(triggerType, auth, null, null, config);\n    var response = getResponseObject(request, function (object) {\n      resolve(object);\n    }, function (error) {\n      reject(error);\n    });\n    logTriggerSuccessBeforeHook(triggerType, className, 'AfterFind', JSON.stringify(objects), auth);\n    request.objects = objects.map(function (object) {\n      //setting the class name to transform into parse object\n      object.className = className;\n      return _node2.default.Object.fromJSON(object);\n    });\n    var triggerPromise = trigger(request, response);\n    if (triggerPromise && typeof triggerPromise.then === \"function\") {\n      return triggerPromise.then(function (promiseResults) {\n        if (promiseResults) {\n          resolve(promiseResults);\n        } else {\n          return reject(new _node2.default.Error(_node2.default.Error.SCRIPT_FAILED, \"AfterFind expect results to be returned in the promise\"));\n        }\n      });\n    }\n  }).then(function (results) {\n    logTriggerAfterHook(triggerType, className, JSON.stringify(results), auth);\n    return results;\n  });\n}\n\nfunction maybeRunQueryTrigger(triggerType, className, restWhere, restOptions, config, auth) {\n  var trigger = getTrigger(className, triggerType, config.applicationId);\n  if (!trigger) {\n    return Promise.resolve({\n      restWhere: restWhere,\n      restOptions: restOptions\n    });\n  }\n\n  var parseQuery = new _node2.default.Query(className);\n  if (restWhere) {\n    parseQuery._where = restWhere;\n  }\n  if (restOptions) {\n    if (restOptions.include && restOptions.include.length > 0) {\n      parseQuery._include = restOptions.include.split(',');\n    }\n    if (restOptions.skip) {\n      parseQuery._skip = restOptions.skip;\n    }\n    if (restOptions.limit) {\n      parseQuery._limit = restOptions.limit;\n    }\n  }\n  var requestObject = getRequestQueryObject(triggerType, auth, parseQuery, config);\n  return Promise.resolve().then(function () {\n    return trigger(requestObject);\n  }).then(function (result) {\n    var queryResult = parseQuery;\n    if (result && result instanceof _node2.default.Query) {\n      queryResult = result;\n    }\n    var jsonQuery = queryResult.toJSON();\n    if (jsonQuery.where) {\n      restWhere = jsonQuery.where;\n    }\n    if (jsonQuery.limit) {\n      restOptions = restOptions || {};\n      restOptions.limit = jsonQuery.limit;\n    }\n    if (jsonQuery.skip) {\n      restOptions = restOptions || {};\n      restOptions.skip = jsonQuery.skip;\n    }\n    if (jsonQuery.include) {\n      restOptions = restOptions || {};\n      restOptions.include = jsonQuery.include;\n    }\n    if (jsonQuery.keys) {\n      restOptions = restOptions || {};\n      restOptions.keys = jsonQuery.keys;\n    }\n    return {\n      restWhere: restWhere,\n      restOptions: restOptions\n    };\n  }, function (err) {\n    if (typeof err === 'string') {\n      throw new _node2.default.Error(1, err);\n    } else {\n      throw err;\n    }\n  });\n}\n\n// To be used as part of the promise chain when saving/deleting an object\n// Will resolve successfully if no trigger is configured\n// Resolves to an object, empty or containing an object key. A beforeSave\n// trigger will set the object key to the rest format object to save.\n// originalParseObject is optional, we only need that for before/afterSave functions\nfunction maybeRunTrigger(triggerType, auth, parseObject, originalParseObject, config) {\n  if (!parseObject) {\n    return Promise.resolve({});\n  }\n  return new Promise(function (resolve, reject) {\n    var trigger = getTrigger(parseObject.className, triggerType, config.applicationId);\n    if (!trigger) return resolve();\n    var request = getRequestObject(triggerType, auth, parseObject, originalParseObject, config);\n    var response = getResponseObject(request, function (object) {\n      logTriggerSuccessBeforeHook(triggerType, parseObject.className, parseObject.toJSON(), object, auth);\n      resolve(object);\n    }, function (error) {\n      logTriggerErrorBeforeHook(triggerType, parseObject.className, parseObject.toJSON(), auth, error);\n      reject(error);\n    });\n    // Force the current Parse app before the trigger\n    _node2.default.applicationId = config.applicationId;\n    _node2.default.javascriptKey = config.javascriptKey || '';\n    _node2.default.masterKey = config.masterKey;\n\n    // AfterSave and afterDelete triggers can return a promise, which if they\n    // do, needs to be resolved before this promise is resolved,\n    // so trigger execution is synced with RestWrite.execute() call.\n    // If triggers do not return a promise, they can run async code parallel\n    // to the RestWrite.execute() call.\n    var triggerPromise = trigger(request, response);\n    if (triggerType === Types.afterSave || triggerType === Types.afterDelete) {\n      logTriggerAfterHook(triggerType, parseObject.className, parseObject.toJSON(), auth);\n      if (triggerPromise && typeof triggerPromise.then === \"function\") {\n        return triggerPromise.then(resolve, resolve);\n      } else {\n        return resolve();\n      }\n    }\n  });\n}\n\n// Converts a REST-format object to a Parse.Object\n// data is either className or an object\nfunction inflate(data, restObject) {\n  var copy = (typeof data === 'undefined' ? 'undefined' : _typeof(data)) == 'object' ? data : { className: data };\n  for (var key in restObject) {\n    copy[key] = restObject[key];\n  }\n  return _node2.default.Object.fromJSON(copy);\n}","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/RestWrite.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _RestQuery = require('./RestQuery');\n\nvar _RestQuery2 = _interopRequireDefault(_RestQuery);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// A RestWrite encapsulates everything we need to run an operation\n// that writes to the database.\n// This could be either a \"create\" or an \"update\".\n\nvar SchemaController = require('./Controllers/SchemaController');\nvar deepcopy = require('deepcopy');\n\nvar Auth = require('./Auth');\nvar cryptoUtils = require('./cryptoUtils');\nvar passwordCrypto = require('./password');\nvar Parse = require('parse/node');\nvar triggers = require('./triggers');\nvar ClientSDK = require('./ClientSDK');\n\n\n// query and data are both provided in REST API format. So data\n// types are encoded by plain old objects.\n// If query is null, this is a \"create\" and the data in data should be\n// created.\n// Otherwise this is an \"update\" - the object matching the query\n// should get updated with data.\n// RestWrite will handle objectId, createdAt, and updatedAt for\n// everything. It also knows to use triggers and special modifications\n// for the _User class.\nfunction RestWrite(config, auth, className, query, data, originalData, clientSDK) {\n  this.config = config;\n  this.auth = auth;\n  this.className = className;\n  this.clientSDK = clientSDK;\n  this.storage = {};\n  this.runOptions = {};\n  if (!query && data.objectId) {\n    throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'objectId is an invalid field name.');\n  }\n\n  // When the operation is complete, this.response may have several\n  // fields.\n  // response: the actual data to be returned\n  // status: the http status code. if not present, treated like a 200\n  // location: the location header. if not present, no location header\n  this.response = null;\n\n  // Processing this operation may mutate our data, so we operate on a\n  // copy\n  this.query = deepcopy(query);\n  this.data = deepcopy(data);\n  // We never change originalData, so we do not need a deep copy\n  this.originalData = originalData;\n\n  // The timestamp we'll use for this whole operation\n  this.updatedAt = Parse._encode(new Date()).iso;\n}\n\n// A convenient method to perform all the steps of processing the\n// write, in order.\n// Returns a promise for a {response, status, location} object.\n// status and location are optional.\nRestWrite.prototype.execute = function () {\n  var _this = this;\n\n  return Promise.resolve().then(function () {\n    return _this.getUserAndRoleACL();\n  }).then(function () {\n    return _this.validateClientClassCreation();\n  }).then(function () {\n    return _this.handleInstallation();\n  }).then(function () {\n    return _this.handleSession();\n  }).then(function () {\n    return _this.validateAuthData();\n  }).then(function () {\n    return _this.runBeforeTrigger();\n  }).then(function () {\n    return _this.validateSchema();\n  }).then(function () {\n    return _this.setRequiredFieldsIfNeeded();\n  }).then(function () {\n    return _this.transformUser();\n  }).then(function () {\n    return _this.expandFilesForExistingObjects();\n  }).then(function () {\n    return _this.runDatabaseOperation();\n  }).then(function () {\n    return _this.createSessionTokenIfNeeded();\n  }).then(function () {\n    return _this.handleFollowup();\n  }).then(function () {\n    return _this.runAfterTrigger();\n  }).then(function () {\n    return _this.cleanUserAuthData();\n  }).then(function () {\n    return _this.response;\n  });\n};\n\n// Uses the Auth object to get the list of roles, adds the user id\nRestWrite.prototype.getUserAndRoleACL = function () {\n  var _this2 = this;\n\n  if (this.auth.isMaster) {\n    return Promise.resolve();\n  }\n\n  this.runOptions.acl = ['*'];\n\n  if (this.auth.user) {\n    return this.auth.getUserRoles().then(function (roles) {\n      roles.push(_this2.auth.user.id);\n      _this2.runOptions.acl = _this2.runOptions.acl.concat(roles);\n      return;\n    });\n  } else {\n    return Promise.resolve();\n  }\n};\n\n// Validates this operation against the allowClientClassCreation config.\nRestWrite.prototype.validateClientClassCreation = function () {\n  var _this3 = this;\n\n  if (this.config.allowClientClassCreation === false && !this.auth.isMaster && SchemaController.systemClasses.indexOf(this.className) === -1) {\n    return this.config.database.loadSchema().then(function (schemaController) {\n      return schemaController.hasClass(_this3.className);\n    }).then(function (hasClass) {\n      if (hasClass !== true) {\n        throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, 'This user is not allowed to access ' + 'non-existent class: ' + _this3.className);\n      }\n    });\n  } else {\n    return Promise.resolve();\n  }\n};\n\n// Validates this operation against the schema.\nRestWrite.prototype.validateSchema = function () {\n  return this.config.database.validateObject(this.className, this.data, this.query, this.runOptions);\n};\n\n// Runs any beforeSave triggers against this operation.\n// Any change leads to our data being mutated.\nRestWrite.prototype.runBeforeTrigger = function () {\n  var _this4 = this;\n\n  if (this.response) {\n    return;\n  }\n\n  // Avoid doing any setup for triggers if there is no 'beforeSave' trigger for this class.\n  if (!triggers.triggerExists(this.className, triggers.Types.beforeSave, this.config.applicationId)) {\n    return Promise.resolve();\n  }\n\n  // Cloud code gets a bit of extra data for its objects\n  var extraData = { className: this.className };\n  if (this.query && this.query.objectId) {\n    extraData.objectId = this.query.objectId;\n  }\n\n  var originalObject = null;\n  var updatedObject = triggers.inflate(extraData, this.originalData);\n  if (this.query && this.query.objectId) {\n    // This is an update for existing object.\n    originalObject = triggers.inflate(extraData, this.originalData);\n  }\n  updatedObject.set(this.sanitizedData());\n\n  return Promise.resolve().then(function () {\n    return triggers.maybeRunTrigger(triggers.Types.beforeSave, _this4.auth, updatedObject, originalObject, _this4.config);\n  }).then(function (response) {\n    if (response && response.object) {\n      _this4.storage.fieldsChangedByTrigger = _lodash2.default.reduce(response.object, function (result, value, key) {\n        if (!_lodash2.default.isEqual(_this4.data[key], value)) {\n          result.push(key);\n        }\n        return result;\n      }, []);\n      _this4.data = response.object;\n      // We should delete the objectId for an update write\n      if (_this4.query && _this4.query.objectId) {\n        delete _this4.data.objectId;\n      }\n    }\n  });\n};\n\nRestWrite.prototype.setRequiredFieldsIfNeeded = function () {\n  if (this.data) {\n    // Add default fields\n    this.data.updatedAt = this.updatedAt;\n    if (!this.query) {\n      this.data.createdAt = this.updatedAt;\n\n      // Only assign new objectId if we are creating new object\n      if (!this.data.objectId) {\n        this.data.objectId = cryptoUtils.newObjectId();\n      }\n    }\n  }\n  return Promise.resolve();\n};\n\n// Transforms auth data for a user object.\n// Does nothing if this isn't a user object.\n// Returns a promise for when we're done if it can't finish this tick.\nRestWrite.prototype.validateAuthData = function () {\n  if (this.className !== '_User') {\n    return;\n  }\n\n  if (!this.query && !this.data.authData) {\n    if (typeof this.data.username !== 'string' || _lodash2.default.isEmpty(this.data.username)) {\n      throw new Parse.Error(Parse.Error.USERNAME_MISSING, 'bad or missing username');\n    }\n    if (typeof this.data.password !== 'string' || _lodash2.default.isEmpty(this.data.password)) {\n      throw new Parse.Error(Parse.Error.PASSWORD_MISSING, 'password is required');\n    }\n  }\n\n  if (!this.data.authData || !Object.keys(this.data.authData).length) {\n    return;\n  }\n\n  var authData = this.data.authData;\n  var providers = Object.keys(authData);\n  if (providers.length > 0) {\n    var canHandleAuthData = providers.reduce(function (canHandle, provider) {\n      var providerAuthData = authData[provider];\n      var hasToken = providerAuthData && providerAuthData.id;\n      return canHandle && (hasToken || providerAuthData == null);\n    }, true);\n    if (canHandleAuthData) {\n      return this.handleAuthData(authData);\n    }\n  }\n  throw new Parse.Error(Parse.Error.UNSUPPORTED_SERVICE, 'This authentication method is unsupported.');\n};\n\nRestWrite.prototype.handleAuthDataValidation = function (authData) {\n  var _this5 = this;\n\n  var validations = Object.keys(authData).map(function (provider) {\n    if (authData[provider] === null) {\n      return Promise.resolve();\n    }\n    var validateAuthData = _this5.config.authDataManager.getValidatorForProvider(provider);\n    if (!validateAuthData) {\n      throw new Parse.Error(Parse.Error.UNSUPPORTED_SERVICE, 'This authentication method is unsupported.');\n    }\n    return validateAuthData(authData[provider]);\n  });\n  return Promise.all(validations);\n};\n\nRestWrite.prototype.findUsersWithAuthData = function (authData) {\n  var providers = Object.keys(authData);\n  var query = providers.reduce(function (memo, provider) {\n    if (!authData[provider]) {\n      return memo;\n    }\n    var queryKey = 'authData.' + provider + '.id';\n    var query = {};\n    query[queryKey] = authData[provider].id;\n    memo.push(query);\n    return memo;\n  }, []).filter(function (q) {\n    return typeof q !== 'undefined';\n  });\n\n  var findPromise = Promise.resolve([]);\n  if (query.length > 0) {\n    findPromise = this.config.database.find(this.className, { '$or': query }, {});\n  }\n\n  return findPromise;\n};\n\nRestWrite.prototype.handleAuthData = function (authData) {\n  var _this6 = this;\n\n  var results = void 0;\n  return this.handleAuthDataValidation(authData).then(function () {\n    return _this6.findUsersWithAuthData(authData);\n  }).then(function (r) {\n    results = r;\n    if (results.length > 1) {\n      // More than 1 user with the passed id's\n      throw new Parse.Error(Parse.Error.ACCOUNT_ALREADY_LINKED, 'this auth is already used');\n    }\n\n    _this6.storage['authProvider'] = Object.keys(authData).join(',');\n\n    if (results.length > 0) {\n      if (!_this6.query) {\n        // Login with auth data\n        delete results[0].password;\n        var userResult = results[0];\n\n        // need to set the objectId first otherwise location has trailing undefined\n        _this6.data.objectId = userResult.objectId;\n\n        // Determine if authData was updated\n        var mutatedAuthData = {};\n        Object.keys(authData).forEach(function (provider) {\n          var providerData = authData[provider];\n          var userAuthData = userResult.authData[provider];\n          if (!_lodash2.default.isEqual(providerData, userAuthData)) {\n            mutatedAuthData[provider] = providerData;\n          }\n        });\n\n        _this6.response = {\n          response: userResult,\n          location: _this6.location()\n        };\n\n        // We have authData that is updated on login\n        // that can happen when token are refreshed,\n        // We should update the token and let the user in\n        if (Object.keys(mutatedAuthData).length > 0) {\n          // Assign the new authData in the response\n          Object.keys(mutatedAuthData).forEach(function (provider) {\n            _this6.response.response.authData[provider] = mutatedAuthData[provider];\n          });\n          // Run the DB update directly, as 'master'\n          // Just update the authData part\n          return _this6.config.database.update(_this6.className, { objectId: _this6.data.objectId }, { authData: mutatedAuthData }, {});\n        }\n        return;\n      } else if (_this6.query && _this6.query.objectId) {\n        // Trying to update auth data but users\n        // are different\n        if (results[0].objectId !== _this6.query.objectId) {\n          throw new Parse.Error(Parse.Error.ACCOUNT_ALREADY_LINKED, 'this auth is already used');\n        }\n      }\n    }\n    return;\n  });\n};\n\n// The non-third-party parts of User transformation\nRestWrite.prototype.transformUser = function () {\n  var _this7 = this;\n\n  var promise = Promise.resolve();\n\n  if (this.className !== '_User') {\n    return promise;\n  }\n\n  if (this.query) {\n    // If we're updating a _User object, we need to clear out the cache for that user. Find all their\n    // session tokens, and remove them from the cache.\n    promise = new _RestQuery2.default(this.config, Auth.master(this.config), '_Session', {\n      user: {\n        __type: \"Pointer\",\n        className: \"_User\",\n        objectId: this.objectId()\n      }\n    }).execute().then(function (results) {\n      results.results.forEach(function (session) {\n        return _this7.config.cacheController.user.del(session.sessionToken);\n      });\n    });\n  }\n\n  return promise.then(function () {\n    // Transform the password\n    if (_this7.data.password === undefined) {\n      // ignore only if undefined. should proceed if empty ('')\n      return Promise.resolve();\n    }\n\n    if (_this7.query && !_this7.auth.isMaster) {\n      _this7.storage['clearSessions'] = true;\n      _this7.storage['generateNewSession'] = true;\n    }\n\n    return _this7._validatePasswordPolicy().then(function () {\n      return passwordCrypto.hash(_this7.data.password).then(function (hashedPassword) {\n        _this7.data._hashed_password = hashedPassword;\n        delete _this7.data.password;\n      });\n    });\n  }).then(function () {\n    return _this7._validateUserName();\n  }).then(function () {\n    return _this7._validateEmail();\n  });\n};\n\nRestWrite.prototype._validateUserName = function () {\n  // Check for username uniqueness\n  if (!this.data.username) {\n    if (!this.query) {\n      this.data.username = cryptoUtils.randomString(25);\n      this.responseShouldHaveUsername = true;\n    }\n    return Promise.resolve();\n  }\n  // We need to a find to check for duplicate username in case they are missing the unique index on usernames\n  // TODO: Check if there is a unique index, and if so, skip this query.\n  return this.config.database.find(this.className, { username: this.data.username, objectId: { '$ne': this.objectId() } }, { limit: 1 }).then(function (results) {\n    if (results.length > 0) {\n      throw new Parse.Error(Parse.Error.USERNAME_TAKEN, 'Account already exists for this username.');\n    }\n    return;\n  });\n};\n\nRestWrite.prototype._validateEmail = function () {\n  var _this8 = this;\n\n  if (!this.data.email || this.data.email.__op === 'Delete') {\n    return Promise.resolve();\n  }\n  // Validate basic email address format\n  if (!this.data.email.match(/^.+@.+$/)) {\n    return Promise.reject(new Parse.Error(Parse.Error.INVALID_EMAIL_ADDRESS, 'Email address format is invalid.'));\n  }\n  // Same problem for email as above for username\n  return this.config.database.find(this.className, { email: this.data.email, objectId: { '$ne': this.objectId() } }, { limit: 1 }).then(function (results) {\n    if (results.length > 0) {\n      throw new Parse.Error(Parse.Error.EMAIL_TAKEN, 'Account already exists for this email address.');\n    }\n    // We updated the email, send a new validation\n    _this8.storage['sendVerificationEmail'] = true;\n    _this8.config.userController.setEmailVerifyToken(_this8.data);\n  });\n};\n\nRestWrite.prototype._validatePasswordPolicy = function () {\n  var _this9 = this;\n\n  if (!this.config.passwordPolicy) return Promise.resolve();\n  return this._validatePasswordRequirements().then(function () {\n    return _this9._validatePasswordHistory();\n  });\n};\n\nRestWrite.prototype._validatePasswordRequirements = function () {\n  var _this10 = this;\n\n  // check if the password conforms to the defined password policy if configured\n  var policyError = 'Password does not meet the Password Policy requirements.';\n\n  // check whether the password meets the password strength requirements\n  if (this.config.passwordPolicy.patternValidator && !this.config.passwordPolicy.patternValidator(this.data.password) || this.config.passwordPolicy.validatorCallback && !this.config.passwordPolicy.validatorCallback(this.data.password)) {\n    return Promise.reject(new Parse.Error(Parse.Error.VALIDATION_ERROR, policyError));\n  }\n\n  // check whether password contain username\n  if (this.config.passwordPolicy.doNotAllowUsername === true) {\n    if (this.data.username) {\n      // username is not passed during password reset\n      if (this.data.password.indexOf(this.data.username) >= 0) return Promise.reject(new Parse.Error(Parse.Error.VALIDATION_ERROR, policyError));\n    } else {\n      // retrieve the User object using objectId during password reset\n      return this.config.database.find('_User', { objectId: this.objectId() }).then(function (results) {\n        if (results.length != 1) {\n          throw undefined;\n        }\n        if (_this10.data.password.indexOf(results[0].username) >= 0) return Promise.reject(new Parse.Error(Parse.Error.VALIDATION_ERROR, policyError));\n        return Promise.resolve();\n      });\n    }\n  }\n  return Promise.resolve();\n};\n\nRestWrite.prototype._validatePasswordHistory = function () {\n  var _this11 = this;\n\n  // check whether password is repeating from specified history\n  if (this.query && this.config.passwordPolicy.maxPasswordHistory) {\n    return this.config.database.find('_User', { objectId: this.objectId() }, { keys: [\"_password_history\", \"_hashed_password\"] }).then(function (results) {\n      if (results.length != 1) {\n        throw undefined;\n      }\n      var user = results[0];\n      var oldPasswords = [];\n      if (user._password_history) oldPasswords = _lodash2.default.take(user._password_history, _this11.config.passwordPolicy.maxPasswordHistory - 1);\n      oldPasswords.push(user.password);\n      var newPassword = _this11.data.password;\n      // compare the new password hash with all old password hashes\n      var promises = oldPasswords.map(function (hash) {\n        return passwordCrypto.compare(newPassword, hash).then(function (result) {\n          if (result) // reject if there is a match\n            return Promise.reject(\"REPEAT_PASSWORD\");\n          return Promise.resolve();\n        });\n      });\n      // wait for all comparisons to complete\n      return Promise.all(promises).then(function () {\n        return Promise.resolve();\n      }).catch(function (err) {\n        if (err === \"REPEAT_PASSWORD\") // a match was found\n          return Promise.reject(new Parse.Error(Parse.Error.VALIDATION_ERROR, 'New password should not be the same as last ' + _this11.config.passwordPolicy.maxPasswordHistory + ' passwords.'));\n        throw err;\n      });\n    });\n  }\n  return Promise.resolve();\n};\n\nRestWrite.prototype.createSessionTokenIfNeeded = function () {\n  if (this.className !== '_User') {\n    return;\n  }\n  if (this.query) {\n    return;\n  }\n  return this.createSessionToken();\n};\n\nRestWrite.prototype.createSessionToken = function () {\n  // cloud installationId from Cloud Code,\n  // never create session tokens from there.\n  if (this.auth.installationId && this.auth.installationId === 'cloud') {\n    return;\n  }\n  var token = 'r:' + cryptoUtils.newToken();\n\n  var expiresAt = this.config.generateSessionExpiresAt();\n  var sessionData = {\n    sessionToken: token,\n    user: {\n      __type: 'Pointer',\n      className: '_User',\n      objectId: this.objectId()\n    },\n    createdWith: {\n      'action': 'signup',\n      'authProvider': this.storage['authProvider'] || 'password'\n    },\n    restricted: false,\n    installationId: this.auth.installationId,\n    expiresAt: Parse._encode(expiresAt)\n  };\n  if (this.response && this.response.response) {\n    this.response.response.sessionToken = token;\n  }\n  var create = new RestWrite(this.config, Auth.master(this.config), '_Session', null, sessionData);\n  return create.execute();\n};\n\n// Handles any followup logic\nRestWrite.prototype.handleFollowup = function () {\n  if (this.storage && this.storage['clearSessions'] && this.config.revokeSessionOnPasswordReset) {\n    var sessionQuery = {\n      user: {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: this.objectId()\n      }\n    };\n    delete this.storage['clearSessions'];\n    return this.config.database.destroy('_Session', sessionQuery).then(this.handleFollowup.bind(this));\n  }\n\n  if (this.storage && this.storage['generateNewSession']) {\n    delete this.storage['generateNewSession'];\n    return this.createSessionToken().then(this.handleFollowup.bind(this));\n  }\n\n  if (this.storage && this.storage['sendVerificationEmail']) {\n    delete this.storage['sendVerificationEmail'];\n    // Fire and forget!\n    this.config.userController.sendVerificationEmail(this.data);\n    return this.handleFollowup.bind(this);\n  }\n};\n\n// Handles the _Session class specialness.\n// Does nothing if this isn't an installation object.\nRestWrite.prototype.handleSession = function () {\n  var _this12 = this;\n\n  if (this.response || this.className !== '_Session') {\n    return;\n  }\n\n  if (!this.auth.user && !this.auth.isMaster) {\n    throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Session token required.');\n  }\n\n  // TODO: Verify proper error to throw\n  if (this.data.ACL) {\n    throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'Cannot set ' + 'ACL on a Session.');\n  }\n\n  if (!this.query && !this.auth.isMaster) {\n    var token = 'r:' + cryptoUtils.newToken();\n    var expiresAt = this.config.generateSessionExpiresAt();\n    var sessionData = {\n      sessionToken: token,\n      user: {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: this.auth.user.id\n      },\n      createdWith: {\n        'action': 'create'\n      },\n      restricted: true,\n      expiresAt: Parse._encode(expiresAt)\n    };\n    for (var key in this.data) {\n      if (key == 'objectId') {\n        continue;\n      }\n      sessionData[key] = this.data[key];\n    }\n    var create = new RestWrite(this.config, Auth.master(this.config), '_Session', null, sessionData);\n    return create.execute().then(function (results) {\n      if (!results.response) {\n        throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, 'Error creating session.');\n      }\n      sessionData['objectId'] = results.response['objectId'];\n      _this12.response = {\n        status: 201,\n        location: results.location,\n        response: sessionData\n      };\n    });\n  }\n};\n\n// Handles the _Installation class specialness.\n// Does nothing if this isn't an installation object.\n// If an installation is found, this can mutate this.query and turn a create\n// into an update.\n// Returns a promise for when we're done if it can't finish this tick.\nRestWrite.prototype.handleInstallation = function () {\n  var _this13 = this;\n\n  if (this.response || this.className !== '_Installation') {\n    return;\n  }\n\n  if (!this.query && !this.data.deviceToken && !this.data.installationId && !this.auth.installationId) {\n    throw new Parse.Error(135, 'at least one ID field (deviceToken, installationId) ' + 'must be specified in this operation');\n  }\n\n  // If the device token is 64 characters long, we assume it is for iOS\n  // and lowercase it.\n  if (this.data.deviceToken && this.data.deviceToken.length == 64) {\n    this.data.deviceToken = this.data.deviceToken.toLowerCase();\n  }\n\n  // We lowercase the installationId if present\n  if (this.data.installationId) {\n    this.data.installationId = this.data.installationId.toLowerCase();\n  }\n\n  var installationId = this.data.installationId;\n\n  // If data.installationId is not set and we're not master, we can lookup in auth\n  if (!installationId && !this.auth.isMaster) {\n    installationId = this.auth.installationId;\n  }\n\n  if (installationId) {\n    installationId = installationId.toLowerCase();\n  }\n\n  // Updating _Installation but not updating anything critical\n  if (this.query && !this.data.deviceToken && !installationId && !this.data.deviceType) {\n    return;\n  }\n\n  var promise = Promise.resolve();\n\n  var idMatch; // Will be a match on either objectId or installationId\n  var objectIdMatch;\n  var installationIdMatch;\n  var deviceTokenMatches = [];\n\n  // Instead of issuing 3 reads, let's do it with one OR.\n  var orQueries = [];\n  if (this.query && this.query.objectId) {\n    orQueries.push({\n      objectId: this.query.objectId\n    });\n  }\n  if (installationId) {\n    orQueries.push({\n      'installationId': installationId\n    });\n  }\n  if (this.data.deviceToken) {\n    orQueries.push({ 'deviceToken': this.data.deviceToken });\n  }\n\n  if (orQueries.length == 0) {\n    return;\n  }\n\n  promise = promise.then(function () {\n    return _this13.config.database.find('_Installation', {\n      '$or': orQueries\n    }, {});\n  }).then(function (results) {\n    results.forEach(function (result) {\n      if (_this13.query && _this13.query.objectId && result.objectId == _this13.query.objectId) {\n        objectIdMatch = result;\n      }\n      if (result.installationId == installationId) {\n        installationIdMatch = result;\n      }\n      if (result.deviceToken == _this13.data.deviceToken) {\n        deviceTokenMatches.push(result);\n      }\n    });\n\n    // Sanity checks when running a query\n    if (_this13.query && _this13.query.objectId) {\n      if (!objectIdMatch) {\n        throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found for update.');\n      }\n      if (_this13.data.installationId && objectIdMatch.installationId && _this13.data.installationId !== objectIdMatch.installationId) {\n        throw new Parse.Error(136, 'installationId may not be changed in this ' + 'operation');\n      }\n      if (_this13.data.deviceToken && objectIdMatch.deviceToken && _this13.data.deviceToken !== objectIdMatch.deviceToken && !_this13.data.installationId && !objectIdMatch.installationId) {\n        throw new Parse.Error(136, 'deviceToken may not be changed in this ' + 'operation');\n      }\n      if (_this13.data.deviceType && _this13.data.deviceType && _this13.data.deviceType !== objectIdMatch.deviceType) {\n        throw new Parse.Error(136, 'deviceType may not be changed in this ' + 'operation');\n      }\n    }\n\n    if (_this13.query && _this13.query.objectId && objectIdMatch) {\n      idMatch = objectIdMatch;\n    }\n\n    if (installationId && installationIdMatch) {\n      idMatch = installationIdMatch;\n    }\n    // need to specify deviceType only if it's new\n    if (!_this13.query && !_this13.data.deviceType && !idMatch) {\n      throw new Parse.Error(135, 'deviceType must be specified in this operation');\n    }\n  }).then(function () {\n    if (!idMatch) {\n      if (!deviceTokenMatches.length) {\n        return;\n      } else if (deviceTokenMatches.length == 1 && (!deviceTokenMatches[0]['installationId'] || !installationId)) {\n        // Single match on device token but none on installationId, and either\n        // the passed object or the match is missing an installationId, so we\n        // can just return the match.\n        return deviceTokenMatches[0]['objectId'];\n      } else if (!_this13.data.installationId) {\n        throw new Parse.Error(132, 'Must specify installationId when deviceToken ' + 'matches multiple Installation objects');\n      } else {\n        // Multiple device token matches and we specified an installation ID,\n        // or a single match where both the passed and matching objects have\n        // an installation ID. Try cleaning out old installations that match\n        // the deviceToken, and return nil to signal that a new object should\n        // be created.\n        var delQuery = {\n          'deviceToken': _this13.data.deviceToken,\n          'installationId': {\n            '$ne': installationId\n          }\n        };\n        if (_this13.data.appIdentifier) {\n          delQuery['appIdentifier'] = _this13.data.appIdentifier;\n        }\n        _this13.config.database.destroy('_Installation', delQuery);\n        return;\n      }\n    } else {\n      if (deviceTokenMatches.length == 1 && !deviceTokenMatches[0]['installationId']) {\n        // Exactly one device token match and it doesn't have an installation\n        // ID. This is the one case where we want to merge with the existing\n        // object.\n        var _delQuery = { objectId: idMatch.objectId };\n        return _this13.config.database.destroy('_Installation', _delQuery).then(function () {\n          return deviceTokenMatches[0]['objectId'];\n        });\n      } else {\n        if (_this13.data.deviceToken && idMatch.deviceToken != _this13.data.deviceToken) {\n          // We're setting the device token on an existing installation, so\n          // we should try cleaning out old installations that match this\n          // device token.\n          var _delQuery2 = {\n            'deviceToken': _this13.data.deviceToken\n          };\n          // We have a unique install Id, use that to preserve\n          // the interesting installation\n          if (_this13.data.installationId) {\n            _delQuery2['installationId'] = {\n              '$ne': _this13.data.installationId\n            };\n          } else if (idMatch.objectId && _this13.data.objectId && idMatch.objectId == _this13.data.objectId) {\n            // we passed an objectId, preserve that instalation\n            _delQuery2['objectId'] = {\n              '$ne': idMatch.objectId\n            };\n          } else {\n            // What to do here? can't really clean up everything...\n            return idMatch.objectId;\n          }\n          if (_this13.data.appIdentifier) {\n            _delQuery2['appIdentifier'] = _this13.data.appIdentifier;\n          }\n          _this13.config.database.destroy('_Installation', _delQuery2);\n        }\n        // In non-merge scenarios, just return the installation match id\n        return idMatch.objectId;\n      }\n    }\n  }).then(function (objId) {\n    if (objId) {\n      _this13.query = { objectId: objId };\n      delete _this13.data.objectId;\n      delete _this13.data.createdAt;\n    }\n    // TODO: Validate ops (add/remove on channels, $inc on badge, etc.)\n  });\n  return promise;\n};\n\n// If we short-circuted the object response - then we need to make sure we expand all the files,\n// since this might not have a query, meaning it won't return the full result back.\n// TODO: (nlutsenko) This should die when we move to per-class based controllers on _Session/_User\nRestWrite.prototype.expandFilesForExistingObjects = function () {\n  // Check whether we have a short-circuited response - only then run expansion.\n  if (this.response && this.response.response) {\n    this.config.filesController.expandFilesInObject(this.config, this.response.response);\n  }\n};\n\nRestWrite.prototype.runDatabaseOperation = function () {\n  var _this14 = this;\n\n  if (this.response) {\n    return;\n  }\n\n  if (this.className === '_Role') {\n    this.config.cacheController.role.clear();\n  }\n\n  if (this.className === '_User' && this.query && !this.auth.couldUpdateUserId(this.query.objectId)) {\n    throw new Parse.Error(Parse.Error.SESSION_MISSING, 'Cannot modify user ' + this.query.objectId + '.');\n  }\n\n  if (this.className === '_Product' && this.data.download) {\n    this.data.downloadName = this.data.download.name;\n  }\n\n  // TODO: Add better detection for ACL, ensuring a user can't be locked from\n  //       their own user record.\n  if (this.data.ACL && this.data.ACL['*unresolved']) {\n    throw new Parse.Error(Parse.Error.INVALID_ACL, 'Invalid ACL.');\n  }\n\n  if (this.query) {\n    // Force the user to not lockout\n    // Matched with parse.com\n    if (this.className === '_User' && this.data.ACL) {\n      this.data.ACL[this.query.objectId] = { read: true, write: true };\n    }\n    // update password timestamp if user password is being changed\n    if (this.className === '_User' && this.data._hashed_password && this.config.passwordPolicy && this.config.passwordPolicy.maxPasswordAge) {\n      this.data._password_changed_at = Parse._encode(new Date());\n    }\n    // Ignore createdAt when update\n    delete this.data.createdAt;\n\n    var defer = Promise.resolve();\n    // if password history is enabled then save the current password to history\n    if (this.className === '_User' && this.data._hashed_password && this.config.passwordPolicy && this.config.passwordPolicy.maxPasswordHistory) {\n      defer = this.config.database.find('_User', { objectId: this.objectId() }, { keys: [\"_password_history\", \"_hashed_password\"] }).then(function (results) {\n        if (results.length != 1) {\n          throw undefined;\n        }\n        var user = results[0];\n        var oldPasswords = [];\n        if (user._password_history) {\n          oldPasswords = _lodash2.default.take(user._password_history, _this14.config.passwordPolicy.maxPasswordHistory);\n        }\n        //n-1 passwords go into history including last password\n        while (oldPasswords.length > _this14.config.passwordPolicy.maxPasswordHistory - 2) {\n          oldPasswords.shift();\n        }\n        oldPasswords.push(user.password);\n        _this14.data._password_history = oldPasswords;\n      });\n    }\n\n    return defer.then(function () {\n      // Run an update\n      return _this14.config.database.update(_this14.className, _this14.query, _this14.data, _this14.runOptions).then(function (response) {\n        response.updatedAt = _this14.updatedAt;\n        _this14._updateResponseWithData(response, _this14.data);\n        _this14.response = { response: response };\n      });\n    });\n  } else {\n    // Set the default ACL and password timestamp for the new _User\n    if (this.className === '_User') {\n      var ACL = this.data.ACL;\n      // default public r/w ACL\n      if (!ACL) {\n        ACL = {};\n        ACL['*'] = { read: true, write: false };\n      }\n      // make sure the user is not locked down\n      ACL[this.data.objectId] = { read: true, write: true };\n      this.data.ACL = ACL;\n      // password timestamp to be used when password expiry policy is enforced\n      if (this.config.passwordPolicy && this.config.passwordPolicy.maxPasswordAge) {\n        this.data._password_changed_at = Parse._encode(new Date());\n      }\n    }\n\n    // Run a create\n    return this.config.database.create(this.className, this.data, this.runOptions).catch(function (error) {\n      if (_this14.className !== '_User' || error.code !== Parse.Error.DUPLICATE_VALUE) {\n        throw error;\n      }\n      // If this was a failed user creation due to username or email already taken, we need to\n      // check whether it was username or email and return the appropriate error.\n\n      // TODO: See if we can later do this without additional queries by using named indexes.\n      return _this14.config.database.find(_this14.className, { username: _this14.data.username, objectId: { '$ne': _this14.objectId() } }, { limit: 1 }).then(function (results) {\n        if (results.length > 0) {\n          throw new Parse.Error(Parse.Error.USERNAME_TAKEN, 'Account already exists for this username.');\n        }\n        return _this14.config.database.find(_this14.className, { email: _this14.data.email, objectId: { '$ne': _this14.objectId() } }, { limit: 1 });\n      }).then(function (results) {\n        if (results.length > 0) {\n          throw new Parse.Error(Parse.Error.EMAIL_TAKEN, 'Account already exists for this email address.');\n        }\n        throw new Parse.Error(Parse.Error.DUPLICATE_VALUE, 'A duplicate value for a field with unique values was provided');\n      });\n    }).then(function (response) {\n      response.objectId = _this14.data.objectId;\n      response.createdAt = _this14.data.createdAt;\n\n      if (_this14.responseShouldHaveUsername) {\n        response.username = _this14.data.username;\n      }\n      _this14._updateResponseWithData(response, _this14.data);\n      _this14.response = {\n        status: 201,\n        response: response,\n        location: _this14.location()\n      };\n    });\n  }\n};\n\n// Returns nothing - doesn't wait for the trigger.\nRestWrite.prototype.runAfterTrigger = function () {\n  if (!this.response || !this.response.response) {\n    return;\n  }\n\n  // Avoid doing any setup for triggers if there is no 'afterSave' trigger for this class.\n  var hasAfterSaveHook = triggers.triggerExists(this.className, triggers.Types.afterSave, this.config.applicationId);\n  var hasLiveQuery = this.config.liveQueryController.hasLiveQuery(this.className);\n  if (!hasAfterSaveHook && !hasLiveQuery) {\n    return Promise.resolve();\n  }\n\n  var extraData = { className: this.className };\n  if (this.query && this.query.objectId) {\n    extraData.objectId = this.query.objectId;\n  }\n\n  // Build the original object, we only do this for a update write.\n  var originalObject = void 0;\n  if (this.query && this.query.objectId) {\n    originalObject = triggers.inflate(extraData, this.originalData);\n  }\n\n  // Build the inflated object, different from beforeSave, originalData is not empty\n  // since developers can change data in the beforeSave.\n  var updatedObject = triggers.inflate(extraData, this.originalData);\n  updatedObject.set(this.sanitizedData());\n  updatedObject._handleSaveResponse(this.response.response, this.response.status || 200);\n\n  // Notifiy LiveQueryServer if possible\n  this.config.liveQueryController.onAfterSave(updatedObject.className, updatedObject, originalObject);\n\n  // Run afterSave trigger\n  return triggers.maybeRunTrigger(triggers.Types.afterSave, this.auth, updatedObject, originalObject, this.config);\n};\n\n// A helper to figure out what location this operation happens at.\nRestWrite.prototype.location = function () {\n  var middle = this.className === '_User' ? '/users/' : '/classes/' + this.className + '/';\n  return this.config.mount + middle + this.data.objectId;\n};\n\n// A helper to get the object id for this operation.\n// Because it could be either on the query or on the data\nRestWrite.prototype.objectId = function () {\n  return this.data.objectId || this.query.objectId;\n};\n\n// Returns a copy of the data and delete bad keys (_auth_data, _hashed_password...)\nRestWrite.prototype.sanitizedData = function () {\n  var data = Object.keys(this.data).reduce(function (data, key) {\n    // Regexp comes from Parse.Object.prototype.validate\n    if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(key)) {\n      delete data[key];\n    }\n    return data;\n  }, deepcopy(this.data));\n  return Parse._decode(undefined, data);\n};\n\nRestWrite.prototype.cleanUserAuthData = function () {\n  if (this.response && this.response.response && this.className === '_User') {\n    var user = this.response.response;\n    if (user.authData) {\n      Object.keys(user.authData).forEach(function (provider) {\n        if (user.authData[provider] === null) {\n          delete user.authData[provider];\n        }\n      });\n      if (Object.keys(user.authData).length == 0) {\n        delete user.authData;\n      }\n    }\n  }\n};\n\nRestWrite.prototype._updateResponseWithData = function (response, data) {\n  if (_lodash2.default.isEmpty(this.storage.fieldsChangedByTrigger)) {\n    return response;\n  }\n  var clientSupportsDelete = ClientSDK.supportsForwardDelete(this.clientSDK);\n  this.storage.fieldsChangedByTrigger.forEach(function (fieldName) {\n    var dataValue = data[fieldName];\n    var responseValue = response[fieldName];\n\n    response[fieldName] = responseValue || dataValue;\n\n    // Strips operations from responses\n    if (response[fieldName] && response[fieldName].__op) {\n      delete response[fieldName];\n      if (clientSupportsDelete && dataValue.__op == 'Delete') {\n        response[fieldName] = dataValue;\n      }\n    }\n  });\n  return response;\n};\n\nexports.default = RestWrite;\n\nmodule.exports = RestWrite;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/password.js":"'use strict';\n\n// Tools for encrypting and decrypting passwords.\n// Basically promise-friendly wrappers for bcrypt.\nvar bcrypt = require('bcryptjs');\n\ntry {\n  bcrypt = require('bcrypt');\n} catch (e) {} /* */\n\n// Returns a promise for a hashed password string.\nfunction hash(password) {\n  return new Promise(function (fulfill, reject) {\n    bcrypt.hash(password, 10, function (err, hashedPassword) {\n      if (err) {\n        reject(err);\n      } else {\n        fulfill(hashedPassword);\n      }\n    });\n  });\n}\n\n// Returns a promise for whether this password compares to equal this\n// hashed password.\nfunction compare(password, hashedPassword) {\n  return new Promise(function (fulfill, reject) {\n    // Cannot bcrypt compare when one is undefined\n    if (!password || !hashedPassword) {\n      return fulfill(false);\n    }\n    bcrypt.compare(password, hashedPassword, function (err, success) {\n      if (err) {\n        reject(err);\n      } else {\n        fulfill(success);\n      }\n    });\n  });\n}\n\nmodule.exports = {\n  hash: hash,\n  compare: compare\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/ClientSDK.js":"'use strict';\n\nvar semver = require('semver');\n\nfunction compatible(compatibleSDK) {\n  return function (clientSDK) {\n    if (typeof clientSDK === 'string') {\n      clientSDK = fromString(clientSDK);\n    }\n    // REST API, or custom SDK\n    if (!clientSDK) {\n      return true;\n    }\n    var clientVersion = clientSDK.version;\n    var compatiblityVersion = compatibleSDK[clientSDK.sdk];\n    return semver.satisfies(clientVersion, compatiblityVersion);\n  };\n}\n\nfunction supportsForwardDelete(clientSDK) {\n  return compatible({\n    js: '>=1.9.0'\n  })(clientSDK);\n}\n\nfunction fromString(version) {\n  var versionRE = /([-a-zA-Z]+)([0-9\\.]+)/;\n  var match = version.toLowerCase().match(versionRE);\n  if (match && match.length === 3) {\n    return {\n      sdk: match[1],\n      version: match[2]\n    };\n  }\n  return undefined;\n}\n\nmodule.exports = {\n  compatible: compatible,\n  supportsForwardDelete: supportsForwardDelete,\n  fromString: fromString\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Routers/FeaturesRouter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FeaturesRouter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _package = require('../../package.json');\n\nvar _PromiseRouter2 = require('../PromiseRouter');\n\nvar _PromiseRouter3 = _interopRequireDefault(_PromiseRouter2);\n\nvar _middlewares = require('../middlewares');\n\nvar middleware = _interopRequireWildcard(_middlewares);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar FeaturesRouter = exports.FeaturesRouter = function (_PromiseRouter) {\n  _inherits(FeaturesRouter, _PromiseRouter);\n\n  function FeaturesRouter() {\n    _classCallCheck(this, FeaturesRouter);\n\n    return _possibleConstructorReturn(this, (FeaturesRouter.__proto__ || Object.getPrototypeOf(FeaturesRouter)).apply(this, arguments));\n  }\n\n  _createClass(FeaturesRouter, [{\n    key: 'mountRoutes',\n    value: function mountRoutes() {\n      this.route('GET', '/serverInfo', middleware.promiseEnforceMasterKeyAccess, function (req) {\n        var features = {\n          globalConfig: {\n            create: true,\n            read: true,\n            update: true,\n            delete: true\n          },\n          hooks: {\n            create: true,\n            read: true,\n            update: true,\n            delete: true\n          },\n          cloudCode: {\n            jobs: true\n          },\n          logs: {\n            level: true,\n            size: true,\n            order: true,\n            until: true,\n            from: true\n          },\n          push: {\n            immediatePush: req.config.hasPushSupport,\n            scheduledPush: false,\n            storedPushData: req.config.hasPushSupport,\n            pushAudiences: false\n          },\n          schemas: {\n            addField: true,\n            removeField: true,\n            addClass: true,\n            removeClass: true,\n            clearAllDataFromClass: true,\n            exportClass: false,\n            editClassLevelPermissions: true,\n            editPointerPermissions: true\n          }\n        };\n\n        return { response: {\n            features: features,\n            parseServerVersion: _package.version\n          } };\n      });\n    }\n  }]);\n\n  return FeaturesRouter;\n}(_PromiseRouter3.default);","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/middlewares.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.handleParseHeaders = handleParseHeaders;\nexports.allowCrossDomain = allowCrossDomain;\nexports.allowMethodOverride = allowMethodOverride;\nexports.handleParseErrors = handleParseErrors;\nexports.enforceMasterKeyAccess = enforceMasterKeyAccess;\nexports.promiseEnforceMasterKeyAccess = promiseEnforceMasterKeyAccess;\n\nvar _cache = require('./cache');\n\nvar _cache2 = _interopRequireDefault(_cache);\n\nvar _logger = require('./logger');\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nvar _node = require('parse/node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _Auth = require('./Auth');\n\nvar _Auth2 = _interopRequireDefault(_Auth);\n\nvar _Config = require('./Config');\n\nvar _Config2 = _interopRequireDefault(_Config);\n\nvar _ClientSDK = require('./ClientSDK');\n\nvar _ClientSDK2 = _interopRequireDefault(_ClientSDK);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Checks that the request is authorized for this app and checks user\n// auth too.\n// The bodyparser should run before this middleware.\n// Adds info to the request:\n// req.config - the Config for this app\n// req.auth - the Auth for this request\nfunction handleParseHeaders(req, res, next) {\n  var mountPathLength = req.originalUrl.length - req.url.length;\n  var mountPath = req.originalUrl.slice(0, mountPathLength);\n  var mount = req.protocol + '://' + req.get('host') + mountPath;\n\n  var info = {\n    appId: req.get('X-Parse-Application-Id'),\n    sessionToken: req.get('X-Parse-Session-Token'),\n    masterKey: req.get('X-Parse-Master-Key'),\n    installationId: req.get('X-Parse-Installation-Id'),\n    clientKey: req.get('X-Parse-Client-Key'),\n    javascriptKey: req.get('X-Parse-Javascript-Key'),\n    dotNetKey: req.get('X-Parse-Windows-Key'),\n    restAPIKey: req.get('X-Parse-REST-API-Key'),\n    clientVersion: req.get('X-Parse-Client-Version')\n  };\n\n  var basicAuth = httpAuth(req);\n\n  if (basicAuth) {\n    var basicAuthAppId = basicAuth.appId;\n    if (_cache2.default.get(basicAuthAppId)) {\n      info.appId = basicAuthAppId;\n      info.masterKey = basicAuth.masterKey || info.masterKey;\n      info.javascriptKey = basicAuth.javascriptKey || info.javascriptKey;\n    }\n  }\n\n  if (req.body) {\n    // Unity SDK sends a _noBody key which needs to be removed.\n    // Unclear at this point if action needs to be taken.\n    delete req.body._noBody;\n  }\n\n  var fileViaJSON = false;\n\n  if (!info.appId || !_cache2.default.get(info.appId)) {\n    // See if we can find the app id on the body.\n    if (req.body instanceof Buffer) {\n      // The only chance to find the app id is if this is a file\n      // upload that actually is a JSON body. So try to parse it.\n      req.body = JSON.parse(req.body);\n      fileViaJSON = true;\n    }\n\n    if (req.body) {\n      delete req.body._RevocableSession;\n    }\n\n    if (req.body && req.body._ApplicationId && _cache2.default.get(req.body._ApplicationId) && (!info.masterKey || _cache2.default.get(req.body._ApplicationId).masterKey === info.masterKey)) {\n      info.appId = req.body._ApplicationId;\n      info.javascriptKey = req.body._JavaScriptKey || '';\n      delete req.body._ApplicationId;\n      delete req.body._JavaScriptKey;\n      // TODO: test that the REST API formats generated by the other\n      // SDKs are handled ok\n      if (req.body._ClientVersion) {\n        info.clientVersion = req.body._ClientVersion;\n        delete req.body._ClientVersion;\n      }\n      if (req.body._InstallationId) {\n        info.installationId = req.body._InstallationId;\n        delete req.body._InstallationId;\n      }\n      if (req.body._SessionToken) {\n        info.sessionToken = req.body._SessionToken;\n        delete req.body._SessionToken;\n      }\n      if (req.body._MasterKey) {\n        info.masterKey = req.body._MasterKey;\n        delete req.body._MasterKey;\n      }\n      if (req.body._ContentType) {\n        req.headers['content-type'] = req.body._ContentType;\n        delete req.body._ContentType;\n      }\n    } else {\n      return invalidRequest(req, res);\n    }\n  }\n\n  if (info.clientVersion) {\n    info.clientSDK = _ClientSDK2.default.fromString(info.clientVersion);\n  }\n\n  if (fileViaJSON) {\n    // We need to repopulate req.body with a buffer\n    var base64 = req.body.base64;\n    req.body = new Buffer(base64, 'base64');\n  }\n\n  info.app = _cache2.default.get(info.appId);\n  req.config = new _Config2.default(info.appId, mount);\n  req.info = info;\n\n  var isMaster = info.masterKey === req.config.masterKey;\n\n  if (isMaster) {\n    req.auth = new _Auth2.default.Auth({ config: req.config, installationId: info.installationId, isMaster: true });\n    next();\n    return;\n  }\n\n  // Client keys are not required in parse-server, but if any have been configured in the server, validate them\n  //  to preserve original behavior.\n  var keys = [\"clientKey\", \"javascriptKey\", \"dotNetKey\", \"restAPIKey\"];\n  var oneKeyConfigured = keys.some(function (key) {\n    return req.config[key] !== undefined;\n  });\n  var oneKeyMatches = keys.some(function (key) {\n    return req.config[key] !== undefined && info[key] === req.config[key];\n  });\n\n  if (oneKeyConfigured && !oneKeyMatches) {\n    return invalidRequest(req, res);\n  }\n\n  if (req.url == \"/login\") {\n    delete info.sessionToken;\n  }\n\n  if (!info.sessionToken) {\n    req.auth = new _Auth2.default.Auth({ config: req.config, installationId: info.installationId, isMaster: false });\n    next();\n    return;\n  }\n\n  return Promise.resolve().then(function () {\n    // handle the upgradeToRevocableSession path on it's own\n    if (info.sessionToken && req.url === '/upgradeToRevocableSession' && info.sessionToken.indexOf('r:') != 0) {\n      return _Auth2.default.getAuthForLegacySessionToken({ config: req.config, installationId: info.installationId, sessionToken: info.sessionToken });\n    } else {\n      return _Auth2.default.getAuthForSessionToken({ config: req.config, installationId: info.installationId, sessionToken: info.sessionToken });\n    }\n  }).then(function (auth) {\n    if (auth) {\n      req.auth = auth;\n      next();\n    }\n  }).catch(function (error) {\n    if (error instanceof _node2.default.Error) {\n      next(error);\n      return;\n    } else {\n      // TODO: Determine the correct error scenario.\n      _logger2.default.error('error getting auth for sessionToken', error);\n      throw new _node2.default.Error(_node2.default.Error.UNKNOWN_ERROR, error);\n    }\n  });\n}\n\nfunction httpAuth(req) {\n  if (!(req.req || req).headers.authorization) return;\n\n  var header = (req.req || req).headers.authorization;\n  var appId, masterKey, javascriptKey;\n\n  // parse header\n  var authPrefix = 'basic ';\n\n  var match = header.toLowerCase().indexOf(authPrefix);\n\n  if (match == 0) {\n    var encodedAuth = header.substring(authPrefix.length, header.length);\n    var credentials = decodeBase64(encodedAuth).split(':');\n\n    if (credentials.length == 2) {\n      appId = credentials[0];\n      var key = credentials[1];\n\n      var jsKeyPrefix = 'javascript-key=';\n\n      var matchKey = key.indexOf(jsKeyPrefix);\n      if (matchKey == 0) {\n        javascriptKey = key.substring(jsKeyPrefix.length, key.length);\n      } else {\n        masterKey = key;\n      }\n    }\n  }\n\n  return { appId: appId, masterKey: masterKey, javascriptKey: javascriptKey };\n}\n\nfunction decodeBase64(str) {\n  return new Buffer(str, 'base64').toString();\n}\n\nfunction allowCrossDomain(req, res, next) {\n  res.header('Access-Control-Allow-Origin', '*');\n  res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');\n  res.header('Access-Control-Allow-Headers', 'X-Parse-Master-Key, X-Parse-REST-API-Key, X-Parse-Javascript-Key, X-Parse-Application-Id, X-Parse-Client-Version, X-Parse-Session-Token, X-Requested-With, X-Parse-Revocable-Session, Content-Type');\n\n  // intercept OPTIONS method\n  if ('OPTIONS' == req.method) {\n    res.sendStatus(200);\n  } else {\n    next();\n  }\n}\n\nfunction allowMethodOverride(req, res, next) {\n  if (req.method === 'POST' && req.body._method) {\n    req.originalMethod = req.method;\n    req.method = req.body._method;\n    delete req.body._method;\n  }\n  next();\n}\n\nfunction handleParseErrors(err, req, res, next) {\n  if (err instanceof _node2.default.Error) {\n    var httpStatus = void 0;\n    // TODO: fill out this mapping\n    switch (err.code) {\n      case _node2.default.Error.INTERNAL_SERVER_ERROR:\n        httpStatus = 500;\n        break;\n      case _node2.default.Error.OBJECT_NOT_FOUND:\n        httpStatus = 404;\n        break;\n      default:\n        httpStatus = 400;\n    }\n\n    res.status(httpStatus);\n    res.json({ code: err.code, error: err.message });\n    _logger2.default.error(err.message, err);\n  } else if (err.status && err.message) {\n    res.status(err.status);\n    res.json({ error: err.message });\n    next(err);\n  } else {\n    _logger2.default.error('Uncaught internal server error.', err, err.stack);\n    res.status(500);\n    res.json({\n      code: _node2.default.Error.INTERNAL_SERVER_ERROR,\n      message: 'Internal server error.'\n    });\n    next(err);\n  }\n}\n\nfunction enforceMasterKeyAccess(req, res, next) {\n  if (!req.auth.isMaster) {\n    res.status(403);\n    res.end('{\"error\":\"unauthorized: master key is required\"}');\n    return;\n  }\n  next();\n}\n\nfunction promiseEnforceMasterKeyAccess(request) {\n  if (!request.auth.isMaster) {\n    var error = new Error();\n    error.status = 403;\n    error.message = \"unauthorized: master key is required\";\n    throw error;\n  }\n  return Promise.resolve();\n}\n\nfunction invalidRequest(req, res) {\n  res.status(403);\n  res.end('{\"error\":\"unauthorized\"}');\n}","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Cache/InMemoryCacheAdapter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InMemoryCacheAdapter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _InMemoryCache = require('./InMemoryCache');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar InMemoryCacheAdapter = exports.InMemoryCacheAdapter = function () {\n  function InMemoryCacheAdapter(ctx) {\n    _classCallCheck(this, InMemoryCacheAdapter);\n\n    this.cache = new _InMemoryCache.InMemoryCache(ctx);\n  }\n\n  _createClass(InMemoryCacheAdapter, [{\n    key: 'get',\n    value: function get(key) {\n      var _this = this;\n\n      return new Promise(function (resolve) {\n        var record = _this.cache.get(key);\n        if (record == null) {\n          return resolve(null);\n        }\n\n        return resolve(JSON.parse(record));\n      });\n    }\n  }, {\n    key: 'put',\n    value: function put(key, value, ttl) {\n      this.cache.put(key, JSON.stringify(value), ttl);\n      return Promise.resolve();\n    }\n  }, {\n    key: 'del',\n    value: function del(key) {\n      this.cache.del(key);\n      return Promise.resolve();\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this.cache.clear();\n      return Promise.resolve();\n    }\n  }]);\n\n  return InMemoryCacheAdapter;\n}();\n\nexports.default = InMemoryCacheAdapter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Controllers/AnalyticsController.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AnalyticsController = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _AdaptableController2 = require('./AdaptableController');\n\nvar _AdaptableController3 = _interopRequireDefault(_AdaptableController2);\n\nvar _AnalyticsAdapter = require('../Adapters/Analytics/AnalyticsAdapter');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar AnalyticsController = exports.AnalyticsController = function (_AdaptableController) {\n  _inherits(AnalyticsController, _AdaptableController);\n\n  function AnalyticsController() {\n    _classCallCheck(this, AnalyticsController);\n\n    return _possibleConstructorReturn(this, (AnalyticsController.__proto__ || Object.getPrototypeOf(AnalyticsController)).apply(this, arguments));\n  }\n\n  _createClass(AnalyticsController, [{\n    key: 'appOpened',\n    value: function appOpened(req) {\n      var _this2 = this;\n\n      return Promise.resolve().then(function () {\n        return _this2.adapter.appOpened(req.body, req);\n      }).then(function (response) {\n        return { response: response || {} };\n      }).catch(function () {\n        return { response: {} };\n      });\n    }\n  }, {\n    key: 'trackEvent',\n    value: function trackEvent(req) {\n      var _this3 = this;\n\n      return Promise.resolve().then(function () {\n        return _this3.adapter.trackEvent(req.params.eventName, req.body, req);\n      }).then(function (response) {\n        return { response: response || {} };\n      }).catch(function () {\n        return { response: {} };\n      });\n    }\n  }, {\n    key: 'expectedAdapterType',\n    value: function expectedAdapterType() {\n      return _AnalyticsAdapter.AnalyticsAdapter;\n    }\n  }]);\n\n  return AnalyticsController;\n}(_AdaptableController3.default);\n\nexports.default = AnalyticsController;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Analytics/AnalyticsAdapter.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*eslint no-unused-vars: \"off\"*/\nvar AnalyticsAdapter = exports.AnalyticsAdapter = function () {\n  function AnalyticsAdapter() {\n    _classCallCheck(this, AnalyticsAdapter);\n  }\n\n  _createClass(AnalyticsAdapter, [{\n    key: \"appOpened\",\n\n\n    /*\n    @param parameters: the analytics request body, analytics info will be in the dimensions property\n    @param req: the original http request\n     */\n    value: function appOpened(parameters, req) {\n      return Promise.resolve({});\n    }\n\n    /*\n    @param eventName: the name of the custom eventName\n    @param parameters: the analytics request body, analytics info will be in the dimensions property\n    @param req: the original http request\n     */\n\n  }, {\n    key: \"trackEvent\",\n    value: function trackEvent(eventName, parameters, req) {\n      return Promise.resolve({});\n    }\n  }]);\n\n  return AnalyticsAdapter;\n}();\n\nexports.default = AnalyticsAdapter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Controllers/CacheController.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CacheController = exports.SubCache = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _AdaptableController2 = require('./AdaptableController');\n\nvar _AdaptableController3 = _interopRequireDefault(_AdaptableController2);\n\nvar _CacheAdapter = require('../Adapters/Cache/CacheAdapter');\n\nvar _CacheAdapter2 = _interopRequireDefault(_CacheAdapter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar KEY_SEPARATOR_CHAR = ':';\n\nfunction joinKeys() {\n  for (var _len = arguments.length, keys = Array(_len), _key = 0; _key < _len; _key++) {\n    keys[_key] = arguments[_key];\n  }\n\n  return keys.join(KEY_SEPARATOR_CHAR);\n}\n\n/**\n * Prefix all calls to the cache via a prefix string, useful when grouping Cache by object type.\n *\n * eg \"Role\" or \"Session\"\n */\n\nvar SubCache = exports.SubCache = function () {\n  function SubCache(prefix, cacheController, ttl) {\n    _classCallCheck(this, SubCache);\n\n    this.prefix = prefix;\n    this.cache = cacheController;\n    this.ttl = ttl;\n  }\n\n  _createClass(SubCache, [{\n    key: 'get',\n    value: function get(key) {\n      var cacheKey = joinKeys(this.prefix, key);\n      return this.cache.get(cacheKey);\n    }\n  }, {\n    key: 'put',\n    value: function put(key, value, ttl) {\n      var cacheKey = joinKeys(this.prefix, key);\n      return this.cache.put(cacheKey, value, ttl);\n    }\n  }, {\n    key: 'del',\n    value: function del(key) {\n      var cacheKey = joinKeys(this.prefix, key);\n      return this.cache.del(cacheKey);\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      return this.cache.clear();\n    }\n  }]);\n\n  return SubCache;\n}();\n\nvar CacheController = exports.CacheController = function (_AdaptableController) {\n  _inherits(CacheController, _AdaptableController);\n\n  function CacheController(adapter, appId) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, CacheController);\n\n    var _this = _possibleConstructorReturn(this, (CacheController.__proto__ || Object.getPrototypeOf(CacheController)).call(this, adapter, appId, options));\n\n    _this.role = new SubCache('role', _this);\n    _this.user = new SubCache('user', _this);\n    return _this;\n  }\n\n  _createClass(CacheController, [{\n    key: 'get',\n    value: function get(key) {\n      var cacheKey = joinKeys(this.appId, key);\n      return this.adapter.get(cacheKey).then(null, function () {\n        return Promise.resolve(null);\n      });\n    }\n  }, {\n    key: 'put',\n    value: function put(key, value, ttl) {\n      var cacheKey = joinKeys(this.appId, key);\n      return this.adapter.put(cacheKey, value, ttl);\n    }\n  }, {\n    key: 'del',\n    value: function del(key) {\n      var cacheKey = joinKeys(this.appId, key);\n      return this.adapter.del(cacheKey);\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      return this.adapter.clear();\n    }\n  }, {\n    key: 'expectedAdapterType',\n    value: function expectedAdapterType() {\n      return _CacheAdapter2.default;\n    }\n  }]);\n\n  return CacheController;\n}(_AdaptableController3.default);\n\nexports.default = CacheController;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Cache/CacheAdapter.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*eslint no-unused-vars: \"off\"*/\nvar CacheAdapter = exports.CacheAdapter = function () {\n  function CacheAdapter() {\n    _classCallCheck(this, CacheAdapter);\n  }\n\n  _createClass(CacheAdapter, [{\n    key: \"get\",\n\n    /**\n     * Get a value in the cache\n     * @param key Cache key to get\n     * @return Promise that will eventually resolve to the value in the cache.\n     */\n    value: function get(key) {}\n\n    /**\n     * Set a value in the cache\n     * @param key Cache key to set\n     * @param value Value to set the key\n     * @param ttl Optional TTL\n     */\n\n  }, {\n    key: \"put\",\n    value: function put(key, value, ttl) {}\n\n    /**\n     * Remove a value from the cache.\n     * @param key Cache key to remove\n     */\n\n  }, {\n    key: \"del\",\n    value: function del(key) {}\n\n    /**\n     * Empty a cache\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {}\n  }]);\n\n  return CacheAdapter;\n}();","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Controllers/FilesController.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FilesController = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _cryptoUtils = require('../cryptoUtils');\n\nvar _AdaptableController2 = require('./AdaptableController');\n\nvar _AdaptableController3 = _interopRequireDefault(_AdaptableController2);\n\nvar _FilesAdapter = require('../Adapters/Files/FilesAdapter');\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _mime = require('mime');\n\nvar _mime2 = _interopRequireDefault(_mime);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // FilesController.js\n\n\nvar legacyFilesRegex = new RegExp(\"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}-.*\");\n\nvar FilesController = exports.FilesController = function (_AdaptableController) {\n  _inherits(FilesController, _AdaptableController);\n\n  function FilesController() {\n    _classCallCheck(this, FilesController);\n\n    return _possibleConstructorReturn(this, (FilesController.__proto__ || Object.getPrototypeOf(FilesController)).apply(this, arguments));\n  }\n\n  _createClass(FilesController, [{\n    key: 'getFileData',\n    value: function getFileData(config, filename) {\n      return this.adapter.getFileData(filename);\n    }\n  }, {\n    key: 'createFile',\n    value: function createFile(config, filename, data, contentType) {\n\n      var extname = _path2.default.extname(filename);\n\n      var hasExtension = extname.length > 0;\n\n      if (!hasExtension && contentType && _mime2.default.extension(contentType)) {\n        filename = filename + '.' + _mime2.default.extension(contentType);\n      } else if (hasExtension && !contentType) {\n        contentType = _mime2.default.lookup(filename);\n      }\n\n      filename = (0, _cryptoUtils.randomHexString)(32) + '_' + filename;\n\n      var location = this.adapter.getFileLocation(config, filename);\n      return this.adapter.createFile(filename, data, contentType).then(function () {\n        return Promise.resolve({\n          url: location,\n          name: filename\n        });\n      });\n    }\n  }, {\n    key: 'deleteFile',\n    value: function deleteFile(config, filename) {\n      return this.adapter.deleteFile(filename);\n    }\n\n    /**\n     * Find file references in REST-format object and adds the url key\n     * with the current mount point and app id.\n     * Object may be a single object or list of REST-format objects.\n     */\n\n  }, {\n    key: 'expandFilesInObject',\n    value: function expandFilesInObject(config, object) {\n      var _this2 = this;\n\n      if (object instanceof Array) {\n        object.map(function (obj) {\n          return _this2.expandFilesInObject(config, obj);\n        });\n        return;\n      }\n      if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {\n        return;\n      }\n      for (var key in object) {\n        var fileObject = object[key];\n        if (fileObject && fileObject['__type'] === 'File') {\n          if (fileObject['url']) {\n            continue;\n          }\n          var filename = fileObject['name'];\n          // all filenames starting with \"tfss-\" should be from files.parsetfss.com\n          // all filenames starting with a \"-\" seperated UUID should be from files.parse.com\n          // all other filenames have been migrated or created from Parse Server\n          if (config.fileKey === undefined) {\n            fileObject['url'] = this.adapter.getFileLocation(config, filename);\n          } else {\n            if (filename.indexOf('tfss-') === 0) {\n              fileObject['url'] = 'http://files.parsetfss.com/' + config.fileKey + '/' + encodeURIComponent(filename);\n            } else if (legacyFilesRegex.test(filename)) {\n              fileObject['url'] = 'http://files.parse.com/' + config.fileKey + '/' + encodeURIComponent(filename);\n            } else {\n              fileObject['url'] = this.adapter.getFileLocation(config, filename);\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: 'expectedAdapterType',\n    value: function expectedAdapterType() {\n      return _FilesAdapter.FilesAdapter;\n    }\n  }, {\n    key: 'getFileStream',\n    value: function getFileStream(config, filename) {\n      return this.adapter.getFileStream(filename);\n    }\n  }]);\n\n  return FilesController;\n}(_AdaptableController3.default);\n\nexports.default = FilesController;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Files/FilesAdapter.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*eslint no-unused-vars: \"off\"*/\n// Files Adapter\n//\n// Allows you to change the file storage mechanism.\n//\n// Adapter classes must implement the following functions:\n// * createFile(config, filename, data)\n// * getFileData(config, filename)\n// * getFileLocation(config, request, filename)\n//\n// Default is GridStoreAdapter, which requires mongo\n// and for the API server to be using the DatabaseController with Mongo\n// database adapter.\n\nvar FilesAdapter = exports.FilesAdapter = function () {\n  function FilesAdapter() {\n    _classCallCheck(this, FilesAdapter);\n  }\n\n  _createClass(FilesAdapter, [{\n    key: \"createFile\",\n\n    /* This method is responsible to store the file in order to be retrieved later by its file name\n     *\n     * @param filename the filename to save\n     * @param data the buffer of data from the file\n     * @param contentType the supposed contentType\n     * @discussion the contentType can be undefined if the controller was not able to determine it\n     *\n     * @return a promise that should fail if the storage didn't succeed\n     *\n     */\n    value: function createFile(filename, data, contentType) {}\n  }, {\n    key: \"deleteFile\",\n    value: function deleteFile(filename) {}\n  }, {\n    key: \"getFileData\",\n    value: function getFileData(filename) {}\n  }, {\n    key: \"getFileLocation\",\n    value: function getFileLocation(config, filename) {}\n  }]);\n\n  return FilesAdapter;\n}();\n\nexports.default = FilesAdapter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Routers/FilesRouter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FilesRouter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _express = require('express');\n\nvar _express2 = _interopRequireDefault(_express);\n\nvar _bodyParser = require('body-parser');\n\nvar _bodyParser2 = _interopRequireDefault(_bodyParser);\n\nvar _middlewares = require('../middlewares');\n\nvar Middlewares = _interopRequireWildcard(_middlewares);\n\nvar _node = require('parse/node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _Config = require('../Config');\n\nvar _Config2 = _interopRequireDefault(_Config);\n\nvar _mime = require('mime');\n\nvar _mime2 = _interopRequireDefault(_mime);\n\nvar _logger = require('../logger');\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar FilesRouter = exports.FilesRouter = function () {\n  function FilesRouter() {\n    _classCallCheck(this, FilesRouter);\n  }\n\n  _createClass(FilesRouter, [{\n    key: 'expressRouter',\n    value: function expressRouter() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var router = _express2.default.Router();\n      router.get('/files/:appId/:filename', this.getHandler);\n\n      router.post('/files', function (req, res, next) {\n        next(new _node2.default.Error(_node2.default.Error.INVALID_FILE_NAME, 'Filename not provided.'));\n      });\n\n      router.post('/files/:filename', Middlewares.allowCrossDomain, _bodyParser2.default.raw({ type: function type() {\n          return true;\n        }, limit: options.maxUploadSize || '20mb' }), // Allow uploads without Content-Type, or with any Content-Type.\n      Middlewares.handleParseHeaders, this.createHandler);\n\n      router.delete('/files/:filename', Middlewares.allowCrossDomain, Middlewares.handleParseHeaders, Middlewares.enforceMasterKeyAccess, this.deleteHandler);\n      return router;\n    }\n  }, {\n    key: 'getHandler',\n    value: function getHandler(req, res) {\n      var config = new _Config2.default(req.params.appId);\n      var filesController = config.filesController;\n      var filename = req.params.filename;\n      var contentType = _mime2.default.lookup(filename);\n      if (isFileStreamable(req, filesController)) {\n        filesController.getFileStream(config, filename).then(function (stream) {\n          handleFileStream(stream, req, res, contentType);\n        }).catch(function () {\n          res.status(404);\n          res.set('Content-Type', 'text/plain');\n          res.end('File not found.');\n        });\n      } else {\n        filesController.getFileData(config, filename).then(function (data) {\n          res.status(200);\n          res.set('Content-Type', contentType);\n          res.set('Content-Length', data.length);\n          res.end(data);\n        }).catch(function () {\n          res.status(404);\n          res.set('Content-Type', 'text/plain');\n          res.end('File not found.');\n        });\n      }\n    }\n  }, {\n    key: 'createHandler',\n    value: function createHandler(req, res, next) {\n      if (!req.body || !req.body.length) {\n        next(new _node2.default.Error(_node2.default.Error.FILE_SAVE_ERROR, 'Invalid file upload.'));\n        return;\n      }\n\n      if (req.params.filename.length > 128) {\n        next(new _node2.default.Error(_node2.default.Error.INVALID_FILE_NAME, 'Filename too long.'));\n        return;\n      }\n\n      if (!req.params.filename.match(/^[_a-zA-Z0-9][a-zA-Z0-9@\\.\\ ~_-]*$/)) {\n        next(new _node2.default.Error(_node2.default.Error.INVALID_FILE_NAME, 'Filename contains invalid characters.'));\n        return;\n      }\n\n      var filename = req.params.filename;\n      var contentType = req.get('Content-type');\n      var config = req.config;\n      var filesController = config.filesController;\n\n      filesController.createFile(config, filename, req.body, contentType).then(function (result) {\n        res.status(201);\n        res.set('Location', result.url);\n        res.json(result);\n      }).catch(function (e) {\n        _logger2.default.error(e.message, e);\n        next(new _node2.default.Error(_node2.default.Error.FILE_SAVE_ERROR, 'Could not store file.'));\n      });\n    }\n  }, {\n    key: 'deleteHandler',\n    value: function deleteHandler(req, res, next) {\n      var filesController = req.config.filesController;\n      filesController.deleteFile(req.config, req.params.filename).then(function () {\n        res.status(200);\n        // TODO: return useful JSON here?\n        res.end();\n      }).catch(function () {\n        next(new _node2.default.Error(_node2.default.Error.FILE_DELETE_ERROR, 'Could not delete file.'));\n      });\n    }\n  }]);\n\n  return FilesRouter;\n}();\n\nfunction isFileStreamable(req, filesController) {\n  if (req.get('Range')) {\n    if (!(typeof filesController.adapter.getFileStream === 'function')) {\n      return false;\n    }\n    if (typeof filesController.adapter.constructor.name !== 'undefined') {\n      if (filesController.adapter.constructor.name == 'GridStoreAdapter') {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n// handleFileStream is licenced under Creative Commons Attribution 4.0 International License (https://creativecommons.org/licenses/by/4.0/).\n// Author: LEROIB at weightingformypizza (https://weightingformypizza.wordpress.com/2015/06/24/stream-html5-media-content-like-video-audio-from-mongodb-using-express-and-gridstore/).\nfunction handleFileStream(stream, req, res, contentType) {\n  var buffer_size = 1024 * 1024; //1024Kb\n  // Range request, partiall stream the file\n  var parts = req.get('Range').replace(/bytes=/, \"\").split(\"-\");\n  var partialstart = parts[0];\n  var partialend = parts[1];\n  var start = partialstart ? parseInt(partialstart, 10) : 0;\n  var end = partialend ? parseInt(partialend, 10) : stream.length - 1;\n  var chunksize = end - start + 1;\n\n  if (chunksize == 1) {\n    start = 0;\n    partialend = false;\n  }\n\n  if (!partialend) {\n    if (stream.length - 1 - start < buffer_size) {\n      end = stream.length - 1;\n    } else {\n      end = start + buffer_size;\n    }\n    chunksize = end - start + 1;\n  }\n\n  if (start == 0 && end == 2) {\n    chunksize = 1;\n  }\n\n  res.writeHead(206, {\n    'Content-Range': 'bytes ' + start + '-' + end + '/' + stream.length,\n    'Accept-Ranges': 'bytes',\n    'Content-Length': chunksize,\n    'Content-Type': contentType\n  });\n\n  stream.seek(start, function () {\n    // get gridFile stream\n    var gridFileStream = stream.stream(true);\n    var bufferAvail = 0;\n    var range = end - start + 1;\n    var totalbyteswanted = end - start + 1;\n    var totalbyteswritten = 0;\n    // write to response\n    gridFileStream.on('data', function (buff) {\n      bufferAvail += buff.length;\n      //Ok check if we have enough to cover our range\n      if (bufferAvail < range) {\n        //Not enough bytes to satisfy our full range\n        if (bufferAvail > 0) {\n          //Write full buffer\n          res.write(buff);\n          totalbyteswritten += buff.length;\n          range -= buff.length;\n          bufferAvail -= buff.length;\n        }\n      } else {\n        //Enough bytes to satisfy our full range!\n        if (bufferAvail > 0) {\n          var buffer = buff.slice(0, range);\n          res.write(buffer);\n          totalbyteswritten += buffer.length;\n          bufferAvail -= range;\n        }\n      }\n      if (totalbyteswritten >= totalbyteswanted) {\n        //totalbytes = 0;\n        stream.close();\n        res.end();\n        this.destroy();\n      }\n    });\n  });\n}","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Routers/FunctionsRouter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FunctionsRouter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _PromiseRouter2 = require('../PromiseRouter');\n\nvar _PromiseRouter3 = _interopRequireDefault(_PromiseRouter2);\n\nvar _middlewares = require('../middlewares');\n\nvar _StatusHandler = require('../StatusHandler');\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _logger = require('../logger');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// FunctionsRouter.js\n\nvar Parse = require('parse/node').Parse,\n    triggers = require('../triggers');\n\nfunction parseObject(obj) {\n  if (Array.isArray(obj)) {\n    return obj.map(function (item) {\n      return parseObject(item);\n    });\n  } else if (obj && obj.__type == 'Date') {\n    return Object.assign(new Date(obj.iso), obj);\n  } else if (obj && obj.__type == 'File') {\n    return Parse.File.fromJSON(obj);\n  } else if (obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {\n    return parseParams(obj);\n  } else {\n    return obj;\n  }\n}\n\nfunction parseParams(params) {\n  return _lodash2.default.mapValues(params, parseObject);\n}\n\nvar FunctionsRouter = exports.FunctionsRouter = function (_PromiseRouter) {\n  _inherits(FunctionsRouter, _PromiseRouter);\n\n  function FunctionsRouter() {\n    _classCallCheck(this, FunctionsRouter);\n\n    return _possibleConstructorReturn(this, (FunctionsRouter.__proto__ || Object.getPrototypeOf(FunctionsRouter)).apply(this, arguments));\n  }\n\n  _createClass(FunctionsRouter, [{\n    key: 'mountRoutes',\n    value: function mountRoutes() {\n      this.route('POST', '/functions/:functionName', FunctionsRouter.handleCloudFunction);\n      this.route('POST', '/jobs/:jobName', _middlewares.promiseEnforceMasterKeyAccess, function (req) {\n        return FunctionsRouter.handleCloudJob(req);\n      });\n      this.route('POST', '/jobs', _middlewares.promiseEnforceMasterKeyAccess, function (req) {\n        return FunctionsRouter.handleCloudJob(req);\n      });\n    }\n  }], [{\n    key: 'handleCloudJob',\n    value: function handleCloudJob(req) {\n      var jobName = req.params.jobName || req.body.jobName;\n      var applicationId = req.config.applicationId;\n      var jobHandler = (0, _StatusHandler.jobStatusHandler)(req.config);\n      var jobFunction = triggers.getJob(jobName, applicationId);\n      if (!jobFunction) {\n        throw new Parse.Error(Parse.Error.SCRIPT_FAILED, 'Invalid job.');\n      }\n      var params = Object.assign({}, req.body, req.query);\n      params = parseParams(params);\n      var request = {\n        params: params,\n        log: req.config.loggerController,\n        headers: req.headers,\n        jobName: jobName\n      };\n      var status = {\n        success: jobHandler.setSucceeded.bind(jobHandler),\n        error: jobHandler.setFailed.bind(jobHandler),\n        message: jobHandler.setMessage.bind(jobHandler)\n      };\n      return jobHandler.setRunning(jobName, params).then(function (jobStatus) {\n        request.jobId = jobStatus.objectId;\n        // run the function async\n        process.nextTick(function () {\n          jobFunction(request, status);\n        });\n        return {\n          headers: {\n            'X-Parse-Job-Status-Id': jobStatus.objectId\n          },\n          response: {}\n        };\n      });\n    }\n  }, {\n    key: 'createResponseObject',\n    value: function createResponseObject(resolve, reject, message) {\n      return {\n        success: function success(result) {\n          resolve({\n            response: {\n              result: Parse._encode(result)\n            }\n          });\n        },\n        error: function error(code, message) {\n          if (!message) {\n            message = code;\n            code = Parse.Error.SCRIPT_FAILED;\n          }\n          reject(new Parse.Error(code, message));\n        },\n        message: message\n      };\n    }\n  }, {\n    key: 'handleCloudFunction',\n    value: function handleCloudFunction(req) {\n      var functionName = req.params.functionName;\n      var applicationId = req.config.applicationId;\n      var theFunction = triggers.getFunction(functionName, applicationId);\n      var theValidator = triggers.getValidator(req.params.functionName, applicationId);\n      if (theFunction) {\n        var params = Object.assign({}, req.body, req.query);\n        params = parseParams(params);\n        var request = {\n          params: params,\n          master: req.auth && req.auth.isMaster,\n          user: req.auth && req.auth.user,\n          installationId: req.info.installationId,\n          log: req.config.loggerController,\n          headers: req.headers,\n          functionName: functionName\n        };\n\n        if (theValidator && typeof theValidator === \"function\") {\n          var result = theValidator(request);\n          if (!result) {\n            throw new Parse.Error(Parse.Error.VALIDATION_ERROR, 'Validation failed.');\n          }\n        }\n\n        return new Promise(function (resolve, reject) {\n          var userString = req.auth && req.auth.user ? req.auth.user.id : undefined;\n          var cleanInput = _logger.logger.truncateLogMessage(JSON.stringify(params));\n          var response = FunctionsRouter.createResponseObject(function (result) {\n            try {\n              var cleanResult = _logger.logger.truncateLogMessage(JSON.stringify(result.response.result));\n              _logger.logger.info('Ran cloud function ' + functionName + ' for user ' + userString + ' ' + ('with:\\n  Input: ' + cleanInput + '\\n  Result: ' + cleanResult), {\n                functionName: functionName,\n                params: params,\n                user: userString\n              });\n              resolve(result);\n            } catch (e) {\n              reject(e);\n            }\n          }, function (error) {\n            try {\n              _logger.logger.error('Failed running cloud function ' + functionName + ' for ' + ('user ' + userString + ' with:\\n  Input: ' + cleanInput + '\\n  Error: ') + JSON.stringify(error), {\n                functionName: functionName,\n                error: error,\n                params: params,\n                user: userString\n              });\n              reject(error);\n            } catch (e) {\n              reject(e);\n            }\n          });\n          // Force the keys before the function calls.\n          Parse.applicationId = req.config.applicationId;\n          Parse.javascriptKey = req.config.javascriptKey;\n          Parse.masterKey = req.config.masterKey;\n          theFunction(request, response);\n        });\n      } else {\n        throw new Parse.Error(Parse.Error.SCRIPT_FAILED, 'Invalid function: \"' + functionName + '\"');\n      }\n    }\n  }]);\n\n  return FunctionsRouter;\n}(_PromiseRouter3.default);","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/StatusHandler.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.flatten = flatten;\nexports.jobStatusHandler = jobStatusHandler;\nexports.pushStatusHandler = pushStatusHandler;\n\nvar _cryptoUtils = require('./cryptoUtils');\n\nvar _logger = require('./logger');\n\nvar PUSH_STATUS_COLLECTION = '_PushStatus';\nvar JOB_STATUS_COLLECTION = '_JobStatus';\n\nvar incrementOp = function incrementOp() {\n  var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var key = arguments[1];\n  var amount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n  if (!object[key]) {\n    object[key] = { __op: 'Increment', amount: amount };\n  } else {\n    object[key].amount += amount;\n  }\n  return object[key];\n};\n\nfunction flatten(array) {\n  var flattened = [];\n  for (var i = 0; i < array.length; i++) {\n    if (Array.isArray(array[i])) {\n      flattened = flattened.concat(flatten(array[i]));\n    } else {\n      flattened.push(array[i]);\n    }\n  }\n  return flattened;\n}\n\nfunction statusHandler(className, database) {\n  var lastPromise = Promise.resolve();\n\n  function create(object) {\n    lastPromise = lastPromise.then(function () {\n      return database.create(className, object).then(function () {\n        return Promise.resolve(object);\n      });\n    });\n    return lastPromise;\n  }\n\n  function update(where, object) {\n    lastPromise = lastPromise.then(function () {\n      return database.update(className, where, object);\n    });\n    return lastPromise;\n  }\n\n  return Object.freeze({\n    create: create,\n    update: update\n  });\n}\n\nfunction jobStatusHandler(config) {\n  var jobStatus = void 0;\n  var objectId = (0, _cryptoUtils.newObjectId)();\n  var database = config.database;\n  var handler = statusHandler(JOB_STATUS_COLLECTION, database);\n  var setRunning = function setRunning(jobName, params) {\n    var now = new Date();\n    jobStatus = {\n      objectId: objectId,\n      jobName: jobName,\n      params: params,\n      status: 'running',\n      source: 'api',\n      createdAt: now,\n      // lockdown!\n      ACL: {}\n    };\n\n    return handler.create(jobStatus);\n  };\n\n  var setMessage = function setMessage(message) {\n    if (!message || typeof message !== 'string') {\n      return Promise.resolve();\n    }\n    return handler.update({ objectId: objectId }, { message: message });\n  };\n\n  var setSucceeded = function setSucceeded(message) {\n    return setFinalStatus('succeeded', message);\n  };\n\n  var setFailed = function setFailed(message) {\n    return setFinalStatus('failed', message);\n  };\n\n  var setFinalStatus = function setFinalStatus(status) {\n    var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n    var finishedAt = new Date();\n    var update = { status: status, finishedAt: finishedAt };\n    if (message && typeof message === 'string') {\n      update.message = message;\n    }\n    return handler.update({ objectId: objectId }, update);\n  };\n\n  return Object.freeze({\n    setRunning: setRunning,\n    setSucceeded: setSucceeded,\n    setMessage: setMessage,\n    setFailed: setFailed\n  });\n}\n\nfunction pushStatusHandler(config) {\n  var objectId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, _cryptoUtils.newObjectId)();\n\n\n  var pushStatus = void 0;\n  var database = config.database;\n  var handler = statusHandler(PUSH_STATUS_COLLECTION, database);\n  var setInitial = function setInitial() {\n    var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var where = arguments[1];\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { source: 'rest' };\n\n    var now = new Date();\n    var data = body.data || {};\n    var payloadString = JSON.stringify(data);\n    var pushHash = void 0;\n    if (typeof data.alert === 'string') {\n      pushHash = (0, _cryptoUtils.md5Hash)(data.alert);\n    } else if (_typeof(data.alert) === 'object') {\n      pushHash = (0, _cryptoUtils.md5Hash)(JSON.stringify(data.alert));\n    } else {\n      pushHash = 'd41d8cd98f00b204e9800998ecf8427e';\n    }\n    var object = {\n      objectId: objectId,\n      createdAt: now,\n      pushTime: now.toISOString(),\n      query: JSON.stringify(where),\n      payload: payloadString,\n      source: options.source,\n      title: options.title,\n      expiry: body.expiration_time,\n      status: \"pending\",\n      numSent: 0,\n      pushHash: pushHash,\n      // lockdown!\n      ACL: {}\n    };\n\n    return handler.create(object).then(function () {\n      pushStatus = {\n        objectId: objectId\n      };\n      return Promise.resolve(pushStatus);\n    });\n  };\n\n  var setRunning = function setRunning(count) {\n    _logger.logger.verbose('_PushStatus ' + objectId + ': sending push to %d installations', count);\n    return handler.update({ status: \"pending\", objectId: objectId }, { status: \"running\", updatedAt: new Date(), count: count });\n  };\n\n  var trackSent = function trackSent(results) {\n    var _this = this;\n\n    var update = {\n      updatedAt: new Date(),\n      numSent: 0,\n      numFailed: 0\n    };\n    if (Array.isArray(results)) {\n      results = flatten(results);\n      results.reduce(function (memo, result) {\n        // Cannot handle that\n        if (!result || !result.device || !result.device.deviceType) {\n          return memo;\n        }\n        var deviceType = result.device.deviceType;\n        var key = result.transmitted ? 'sentPerType.' + deviceType : 'failedPerType.' + deviceType;\n        memo[key] = incrementOp(memo, key);\n        if (result.transmitted) {\n          memo.numSent++;\n        } else {\n          memo.numFailed++;\n        }\n        return memo;\n      }, update);\n      incrementOp(update, 'count', -results.length);\n    }\n\n    _logger.logger.verbose('_PushStatus ' + objectId + ': sent push! %d success, %d failures', update.numSent, update.numFailed);\n\n    ['numSent', 'numFailed'].forEach(function (key) {\n      if (update[key] > 0) {\n        update[key] = {\n          __op: 'Increment',\n          amount: update[key]\n        };\n      } else {\n        delete update[key];\n      }\n    });\n\n    return handler.update({ objectId: objectId }, update).then(function (res) {\n      if (res && res.count === 0) {\n        return _this.complete();\n      }\n    });\n  };\n\n  var complete = function complete() {\n    return handler.update({ objectId: objectId }, {\n      status: 'succeeded',\n      count: { __op: 'Delete' },\n      updatedAt: new Date()\n    });\n  };\n\n  var fail = function fail(err) {\n    var update = {\n      errorMessage: JSON.stringify(err),\n      status: 'failed',\n      updatedAt: new Date()\n    };\n    _logger.logger.warn('_PushStatus ' + objectId + ': error while sending push', err);\n    return handler.update({ objectId: objectId }, update);\n  };\n\n  return Object.freeze({\n    objectId: objectId,\n    setInitial: setInitial,\n    setRunning: setRunning,\n    trackSent: trackSent,\n    complete: complete,\n    fail: fail\n  });\n}","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Routers/GlobalConfigRouter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GlobalConfigRouter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _PromiseRouter2 = require('../PromiseRouter');\n\nvar _PromiseRouter3 = _interopRequireDefault(_PromiseRouter2);\n\nvar _middlewares = require('../middlewares');\n\nvar middleware = _interopRequireWildcard(_middlewares);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // global_config.js\n\nvar GlobalConfigRouter = exports.GlobalConfigRouter = function (_PromiseRouter) {\n  _inherits(GlobalConfigRouter, _PromiseRouter);\n\n  function GlobalConfigRouter() {\n    _classCallCheck(this, GlobalConfigRouter);\n\n    return _possibleConstructorReturn(this, (GlobalConfigRouter.__proto__ || Object.getPrototypeOf(GlobalConfigRouter)).apply(this, arguments));\n  }\n\n  _createClass(GlobalConfigRouter, [{\n    key: 'getGlobalConfig',\n    value: function getGlobalConfig(req) {\n      return req.config.database.find('_GlobalConfig', { objectId: \"1\" }, { limit: 1 }).then(function (results) {\n        if (results.length != 1) {\n          // If there is no config in the database - return empty config.\n          return { response: { params: {} } };\n        }\n        var globalConfig = results[0];\n        return { response: { params: globalConfig.params } };\n      });\n    }\n  }, {\n    key: 'updateGlobalConfig',\n    value: function updateGlobalConfig(req) {\n      var params = req.body.params;\n      // Transform in dot notation to make sure it works\n      var update = Object.keys(params).reduce(function (acc, key) {\n        acc['params.' + key] = params[key];\n        return acc;\n      }, {});\n      return req.config.database.update('_GlobalConfig', { objectId: \"1\" }, update, { upsert: true }).then(function () {\n        return { response: { result: true } };\n      });\n    }\n  }, {\n    key: 'mountRoutes',\n    value: function mountRoutes() {\n      var _this2 = this;\n\n      this.route('GET', '/config', function (req) {\n        return _this2.getGlobalConfig(req);\n      });\n      this.route('PUT', '/config', middleware.promiseEnforceMasterKeyAccess, function (req) {\n        return _this2.updateGlobalConfig(req);\n      });\n    }\n  }]);\n\n  return GlobalConfigRouter;\n}(_PromiseRouter3.default);\n\nexports.default = GlobalConfigRouter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Files/GridStoreAdapter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GridStoreAdapter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mongodb = require('mongodb');\n\nvar _FilesAdapter2 = require('./FilesAdapter');\n\nvar _defaults = require('../../defaults');\n\nvar _defaults2 = _interopRequireDefault(_defaults);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                GridStoreAdapter\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Stores files in Mongo using GridStore\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Requires the database adapter to be based on mongoclient\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 weak\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\nvar GridStoreAdapter = exports.GridStoreAdapter = function (_FilesAdapter) {\n  _inherits(GridStoreAdapter, _FilesAdapter);\n\n  function GridStoreAdapter() {\n    var mongoDatabaseURI = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _defaults2.default.DefaultMongoURI;\n\n    _classCallCheck(this, GridStoreAdapter);\n\n    var _this = _possibleConstructorReturn(this, (GridStoreAdapter.__proto__ || Object.getPrototypeOf(GridStoreAdapter)).call(this));\n\n    _this._databaseURI = mongoDatabaseURI;\n    return _this;\n  }\n\n  _createClass(GridStoreAdapter, [{\n    key: '_connect',\n    value: function _connect() {\n      if (!this._connectionPromise) {\n        this._connectionPromise = _mongodb.MongoClient.connect(this._databaseURI);\n      }\n      return this._connectionPromise;\n    }\n\n    // For a given config object, filename, and data, store a file\n    // Returns a promise\n\n  }, {\n    key: 'createFile',\n    value: function createFile(filename, data) {\n      return this._connect().then(function (database) {\n        var gridStore = new _mongodb.GridStore(database, filename, 'w');\n        return gridStore.open();\n      }).then(function (gridStore) {\n        return gridStore.write(data);\n      }).then(function (gridStore) {\n        return gridStore.close();\n      });\n    }\n  }, {\n    key: 'deleteFile',\n    value: function deleteFile(filename) {\n      return this._connect().then(function (database) {\n        var gridStore = new _mongodb.GridStore(database, filename, 'r');\n        return gridStore.open();\n      }).then(function (gridStore) {\n        return gridStore.unlink();\n      }).then(function (gridStore) {\n        return gridStore.close();\n      });\n    }\n  }, {\n    key: 'getFileData',\n    value: function getFileData(filename) {\n      return this._connect().then(function (database) {\n        return _mongodb.GridStore.exist(database, filename).then(function () {\n          var gridStore = new _mongodb.GridStore(database, filename, 'r');\n          return gridStore.open();\n        });\n      }).then(function (gridStore) {\n        return gridStore.read();\n      });\n    }\n  }, {\n    key: 'getFileLocation',\n    value: function getFileLocation(config, filename) {\n      return config.mount + '/files/' + config.applicationId + '/' + encodeURIComponent(filename);\n    }\n  }, {\n    key: 'getFileStream',\n    value: function getFileStream(filename) {\n      return this._connect().then(function (database) {\n        return _mongodb.GridStore.exist(database, filename).then(function () {\n          var gridStore = new _mongodb.GridStore(database, filename, 'r');\n          return gridStore.open();\n        });\n      });\n    }\n  }]);\n\n  return GridStoreAdapter;\n}(_FilesAdapter2.FilesAdapter);\n\nexports.default = GridStoreAdapter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Controllers/HooksController.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HooksController = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**  weak */\n\nvar _triggers = require(\"../triggers\");\n\nvar triggers = _interopRequireWildcard(_triggers);\n\nvar _node = require(\"parse/node\");\n\nvar Parse = _interopRequireWildcard(_node);\n\nvar _request = require(\"request\");\n\nvar request = _interopRequireWildcard(_request);\n\nvar _logger = require(\"../logger\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DefaultHooksCollectionName = \"_Hooks\";\n\nvar HooksController = exports.HooksController = function () {\n  function HooksController(applicationId, databaseController, webhookKey) {\n    _classCallCheck(this, HooksController);\n\n    this._applicationId = applicationId;\n    this._webhookKey = webhookKey;\n    this.database = databaseController;\n  }\n\n  _createClass(HooksController, [{\n    key: \"load\",\n    value: function load() {\n      var _this = this;\n\n      return this._getHooks().then(function (hooks) {\n        hooks = hooks || [];\n        hooks.forEach(function (hook) {\n          _this.addHookToTriggers(hook);\n        });\n      });\n    }\n  }, {\n    key: \"getFunction\",\n    value: function getFunction(functionName) {\n      return this._getHooks({ functionName: functionName }, 1).then(function (results) {\n        return results[0];\n      });\n    }\n  }, {\n    key: \"getFunctions\",\n    value: function getFunctions() {\n      return this._getHooks({ functionName: { $exists: true } });\n    }\n  }, {\n    key: \"getTrigger\",\n    value: function getTrigger(className, triggerName) {\n      return this._getHooks({ className: className, triggerName: triggerName }, 1).then(function (results) {\n        return results[0];\n      });\n    }\n  }, {\n    key: \"getTriggers\",\n    value: function getTriggers() {\n      return this._getHooks({ className: { $exists: true }, triggerName: { $exists: true } });\n    }\n  }, {\n    key: \"deleteFunction\",\n    value: function deleteFunction(functionName) {\n      triggers.removeFunction(functionName, this._applicationId);\n      return this._removeHooks({ functionName: functionName });\n    }\n  }, {\n    key: \"deleteTrigger\",\n    value: function deleteTrigger(className, triggerName) {\n      triggers.removeTrigger(triggerName, className, this._applicationId);\n      return this._removeHooks({ className: className, triggerName: triggerName });\n    }\n  }, {\n    key: \"_getHooks\",\n    value: function _getHooks() {\n      var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return this.database.find(DefaultHooksCollectionName, query).then(function (results) {\n        return results.map(function (result) {\n          delete result.objectId;\n          return result;\n        });\n      });\n    }\n  }, {\n    key: \"_removeHooks\",\n    value: function _removeHooks(query) {\n      return this.database.destroy(DefaultHooksCollectionName, query).then(function () {\n        return Promise.resolve({});\n      });\n    }\n  }, {\n    key: \"saveHook\",\n    value: function saveHook(hook) {\n      var query;\n      if (hook.functionName && hook.url) {\n        query = { functionName: hook.functionName };\n      } else if (hook.triggerName && hook.className && hook.url) {\n        query = { className: hook.className, triggerName: hook.triggerName };\n      } else {\n        throw new Parse.Error(143, \"invalid hook declaration\");\n      }\n      return this.database.update(DefaultHooksCollectionName, query, hook, { upsert: true }).then(function () {\n        return Promise.resolve(hook);\n      });\n    }\n  }, {\n    key: \"addHookToTriggers\",\n    value: function addHookToTriggers(hook) {\n      var wrappedFunction = wrapToHTTPRequest(hook, this._webhookKey);\n      wrappedFunction.url = hook.url;\n      if (hook.className) {\n        triggers.addTrigger(hook.triggerName, hook.className, wrappedFunction, this._applicationId);\n      } else {\n        triggers.addFunction(hook.functionName, wrappedFunction, null, this._applicationId);\n      }\n    }\n  }, {\n    key: \"addHook\",\n    value: function addHook(hook) {\n      this.addHookToTriggers(hook);\n      return this.saveHook(hook);\n    }\n  }, {\n    key: \"createOrUpdateHook\",\n    value: function createOrUpdateHook(aHook) {\n      var hook;\n      if (aHook && aHook.functionName && aHook.url) {\n        hook = {};\n        hook.functionName = aHook.functionName;\n        hook.url = aHook.url;\n      } else if (aHook && aHook.className && aHook.url && aHook.triggerName && triggers.Types[aHook.triggerName]) {\n        hook = {};\n        hook.className = aHook.className;\n        hook.url = aHook.url;\n        hook.triggerName = aHook.triggerName;\n      } else {\n        throw new Parse.Error(143, \"invalid hook declaration\");\n      }\n\n      return this.addHook(hook);\n    }\n  }, {\n    key: \"createHook\",\n    value: function createHook(aHook) {\n      var _this2 = this;\n\n      if (aHook.functionName) {\n        return this.getFunction(aHook.functionName).then(function (result) {\n          if (result) {\n            throw new Parse.Error(143, \"function name: \" + aHook.functionName + \" already exits\");\n          } else {\n            return _this2.createOrUpdateHook(aHook);\n          }\n        });\n      } else if (aHook.className && aHook.triggerName) {\n        return this.getTrigger(aHook.className, aHook.triggerName).then(function (result) {\n          if (result) {\n            throw new Parse.Error(143, \"class \" + aHook.className + \" already has trigger \" + aHook.triggerName);\n          }\n          return _this2.createOrUpdateHook(aHook);\n        });\n      }\n\n      throw new Parse.Error(143, \"invalid hook declaration\");\n    }\n  }, {\n    key: \"updateHook\",\n    value: function updateHook(aHook) {\n      var _this3 = this;\n\n      if (aHook.functionName) {\n        return this.getFunction(aHook.functionName).then(function (result) {\n          if (result) {\n            return _this3.createOrUpdateHook(aHook);\n          }\n          throw new Parse.Error(143, \"no function named: \" + aHook.functionName + \" is defined\");\n        });\n      } else if (aHook.className && aHook.triggerName) {\n        return this.getTrigger(aHook.className, aHook.triggerName).then(function (result) {\n          if (result) {\n            return _this3.createOrUpdateHook(aHook);\n          }\n          throw new Parse.Error(143, \"class \" + aHook.className + \" does not exist\");\n        });\n      }\n      throw new Parse.Error(143, \"invalid hook declaration\");\n    }\n  }]);\n\n  return HooksController;\n}();\n\nfunction wrapToHTTPRequest(hook, key) {\n  return function (req, res) {\n    var jsonBody = {};\n    for (var i in req) {\n      jsonBody[i] = req[i];\n    }\n    if (req.object) {\n      jsonBody.object = req.object.toJSON();\n      jsonBody.object.className = req.object.className;\n    }\n    if (req.original) {\n      jsonBody.original = req.original.toJSON();\n      jsonBody.original.className = req.original.className;\n    }\n    var jsonRequest = {\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(jsonBody)\n    };\n\n    if (key) {\n      jsonRequest.headers['X-Parse-Webhook-Key'] = key;\n    } else {\n      _logger.logger.warn('Making outgoing webhook request without webhookKey being set!');\n    }\n\n    request.post(hook.url, jsonRequest, function (err, httpResponse, body) {\n      var result;\n      if (body) {\n        if (typeof body === \"string\") {\n          try {\n            body = JSON.parse(body);\n          } catch (e) {\n            err = { error: \"Malformed response\", code: -1 };\n          }\n        }\n        if (!err) {\n          result = body.success;\n          err = body.error;\n        }\n      }\n\n      if (err) {\n        return res.error(err);\n      } else if (hook.triggerName === 'beforeSave') {\n        if ((typeof result === \"undefined\" ? \"undefined\" : _typeof(result)) === 'object') {\n          delete result.createdAt;\n          delete result.updatedAt;\n        }\n        return res.success({ object: result });\n      } else {\n        return res.success(result);\n      }\n    });\n  };\n}\n\nexports.default = HooksController;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Routers/HooksRouter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HooksRouter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _node = require('parse/node');\n\nvar _PromiseRouter2 = require('../PromiseRouter');\n\nvar _PromiseRouter3 = _interopRequireDefault(_PromiseRouter2);\n\nvar _middlewares = require('../middlewares');\n\nvar middleware = _interopRequireWildcard(_middlewares);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar HooksRouter = exports.HooksRouter = function (_PromiseRouter) {\n  _inherits(HooksRouter, _PromiseRouter);\n\n  function HooksRouter() {\n    _classCallCheck(this, HooksRouter);\n\n    return _possibleConstructorReturn(this, (HooksRouter.__proto__ || Object.getPrototypeOf(HooksRouter)).apply(this, arguments));\n  }\n\n  _createClass(HooksRouter, [{\n    key: 'createHook',\n    value: function createHook(aHook, config) {\n      return config.hooksController.createHook(aHook).then(function (hook) {\n        return { response: hook };\n      });\n    }\n  }, {\n    key: 'updateHook',\n    value: function updateHook(aHook, config) {\n      return config.hooksController.updateHook(aHook).then(function (hook) {\n        return { response: hook };\n      });\n    }\n  }, {\n    key: 'handlePost',\n    value: function handlePost(req) {\n      return this.createHook(req.body, req.config);\n    }\n  }, {\n    key: 'handleGetFunctions',\n    value: function handleGetFunctions(req) {\n      var hooksController = req.config.hooksController;\n      if (req.params.functionName) {\n        return hooksController.getFunction(req.params.functionName).then(function (foundFunction) {\n          if (!foundFunction) {\n            throw new _node.Parse.Error(143, 'no function named: ' + req.params.functionName + ' is defined');\n          }\n          return Promise.resolve({ response: foundFunction });\n        });\n      }\n\n      return hooksController.getFunctions().then(function (functions) {\n        return { response: functions || [] };\n      }, function (err) {\n        throw err;\n      });\n    }\n  }, {\n    key: 'handleGetTriggers',\n    value: function handleGetTriggers(req) {\n      var hooksController = req.config.hooksController;\n      if (req.params.className && req.params.triggerName) {\n\n        return hooksController.getTrigger(req.params.className, req.params.triggerName).then(function (foundTrigger) {\n          if (!foundTrigger) {\n            throw new _node.Parse.Error(143, 'class ' + req.params.className + ' does not exist');\n          }\n          return Promise.resolve({ response: foundTrigger });\n        });\n      }\n\n      return hooksController.getTriggers().then(function (triggers) {\n        return { response: triggers || [] };\n      });\n    }\n  }, {\n    key: 'handleDelete',\n    value: function handleDelete(req) {\n      var hooksController = req.config.hooksController;\n      if (req.params.functionName) {\n        return hooksController.deleteFunction(req.params.functionName).then(function () {\n          return { response: {} };\n        });\n      } else if (req.params.className && req.params.triggerName) {\n        return hooksController.deleteTrigger(req.params.className, req.params.triggerName).then(function () {\n          return { response: {} };\n        });\n      }\n      return Promise.resolve({ response: {} });\n    }\n  }, {\n    key: 'handleUpdate',\n    value: function handleUpdate(req) {\n      var hook;\n      if (req.params.functionName && req.body.url) {\n        hook = {};\n        hook.functionName = req.params.functionName;\n        hook.url = req.body.url;\n      } else if (req.params.className && req.params.triggerName && req.body.url) {\n        hook = {};\n        hook.className = req.params.className;\n        hook.triggerName = req.params.triggerName;\n        hook.url = req.body.url;\n      } else {\n        throw new _node.Parse.Error(143, \"invalid hook declaration\");\n      }\n      return this.updateHook(hook, req.config);\n    }\n  }, {\n    key: 'handlePut',\n    value: function handlePut(req) {\n      var body = req.body;\n      if (body.__op == \"Delete\") {\n        return this.handleDelete(req);\n      } else {\n        return this.handleUpdate(req);\n      }\n    }\n  }, {\n    key: 'mountRoutes',\n    value: function mountRoutes() {\n      this.route('GET', '/hooks/functions', middleware.promiseEnforceMasterKeyAccess, this.handleGetFunctions.bind(this));\n      this.route('GET', '/hooks/triggers', middleware.promiseEnforceMasterKeyAccess, this.handleGetTriggers.bind(this));\n      this.route('GET', '/hooks/functions/:functionName', middleware.promiseEnforceMasterKeyAccess, this.handleGetFunctions.bind(this));\n      this.route('GET', '/hooks/triggers/:className/:triggerName', middleware.promiseEnforceMasterKeyAccess, this.handleGetTriggers.bind(this));\n      this.route('POST', '/hooks/functions', middleware.promiseEnforceMasterKeyAccess, this.handlePost.bind(this));\n      this.route('POST', '/hooks/triggers', middleware.promiseEnforceMasterKeyAccess, this.handlePost.bind(this));\n      this.route('PUT', '/hooks/functions/:functionName', middleware.promiseEnforceMasterKeyAccess, this.handlePut.bind(this));\n      this.route('PUT', '/hooks/triggers/:className/:triggerName', middleware.promiseEnforceMasterKeyAccess, this.handlePut.bind(this));\n    }\n  }]);\n\n  return HooksRouter;\n}(_PromiseRouter3.default);\n\nexports.default = HooksRouter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Routers/IAPValidationRouter.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IAPValidationRouter = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _PromiseRouter2 = require(\"../PromiseRouter\");\n\nvar _PromiseRouter3 = _interopRequireDefault(_PromiseRouter2);\n\nvar _node = require(\"parse/node\");\n\nvar _node2 = _interopRequireDefault(_node);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar request = require(\"request\");\nvar rest = require(\"../rest\");\n\n\n// TODO move validation logic in IAPValidationController\nvar IAP_SANDBOX_URL = \"https://sandbox.itunes.apple.com/verifyReceipt\";\nvar IAP_PRODUCTION_URL = \"https://buy.itunes.apple.com/verifyReceipt\";\n\nvar APP_STORE_ERRORS = {\n  21000: \"The App Store could not read the JSON object you provided.\",\n  21002: \"The data in the receipt-data property was malformed or missing.\",\n  21003: \"The receipt could not be authenticated.\",\n  21004: \"The shared secret you provided does not match the shared secret on file for your account.\",\n  21005: \"The receipt server is not currently available.\",\n  21006: \"This receipt is valid but the subscription has expired.\",\n  21007: \"This receipt is from the test environment, but it was sent to the production environment for verification. Send it to the test environment instead.\",\n  21008: \"This receipt is from the production environment, but it was sent to the test environment for verification. Send it to the production environment instead.\"\n};\n\nfunction appStoreError(status) {\n  status = parseInt(status);\n  var errorString = APP_STORE_ERRORS[status] || \"unknown error.\";\n  return { status: status, error: errorString };\n}\n\nfunction validateWithAppStore(url, receipt) {\n  return new Promise(function (fulfill, reject) {\n    request.post({\n      url: url,\n      body: { \"receipt-data\": receipt },\n      json: true\n    }, function (err, res, body) {\n      var status = body.status;\n      if (status == 0) {\n        // No need to pass anything, status is OK\n        return fulfill();\n      }\n      // receipt is from test and should go to test\n      return reject(body);\n    });\n  });\n}\n\nfunction getFileForProductIdentifier(productIdentifier, req) {\n  return rest.find(req.config, req.auth, '_Product', { productIdentifier: productIdentifier }, undefined, req.info.clientSDK).then(function (result) {\n    var products = result.results;\n    if (!products || products.length != 1) {\n      // Error not found or too many\n      throw new _node2.default.Error(_node2.default.Error.OBJECT_NOT_FOUND, 'Object not found.');\n    }\n\n    var download = products[0].download;\n    return Promise.resolve({ response: download });\n  });\n}\n\nvar IAPValidationRouter = exports.IAPValidationRouter = function (_PromiseRouter) {\n  _inherits(IAPValidationRouter, _PromiseRouter);\n\n  function IAPValidationRouter() {\n    _classCallCheck(this, IAPValidationRouter);\n\n    return _possibleConstructorReturn(this, (IAPValidationRouter.__proto__ || Object.getPrototypeOf(IAPValidationRouter)).apply(this, arguments));\n  }\n\n  _createClass(IAPValidationRouter, [{\n    key: \"handleRequest\",\n    value: function handleRequest(req) {\n      var receipt = req.body.receipt;\n      var productIdentifier = req.body.productIdentifier;\n\n      if (!receipt || !productIdentifier) {\n        // TODO: Error, malformed request\n        throw new _node2.default.Error(_node2.default.Error.INVALID_JSON, \"missing receipt or productIdentifier\");\n      }\n\n      // Transform the object if there\n      // otherwise assume it's in Base64 already\n      if ((typeof receipt === \"undefined\" ? \"undefined\" : _typeof(receipt)) == \"object\") {\n        if (receipt[\"__type\"] == \"Bytes\") {\n          receipt = receipt.base64;\n        }\n      }\n\n      if (process.env.NODE_ENV == \"test\" && req.body.bypassAppStoreValidation) {\n        return getFileForProductIdentifier(productIdentifier, req);\n      }\n\n      function successCallback() {\n        return getFileForProductIdentifier(productIdentifier, req);\n      }\n\n      function errorCallback(error) {\n        return Promise.resolve({ response: appStoreError(error.status) });\n      }\n\n      return validateWithAppStore(IAP_PRODUCTION_URL, receipt).then(function () {\n\n        return successCallback();\n      }, function (error) {\n        if (error.status == 21007) {\n          return validateWithAppStore(IAP_SANDBOX_URL, receipt).then(function () {\n            return successCallback();\n          }, function (error) {\n            return errorCallback(error);\n          });\n        }\n\n        return errorCallback(error);\n      });\n    }\n  }, {\n    key: \"mountRoutes\",\n    value: function mountRoutes() {\n      this.route(\"POST\", \"/validate_purchase\", this.handleRequest);\n    }\n  }]);\n\n  return IAPValidationRouter;\n}(_PromiseRouter3.default);","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Routers/InstallationsRouter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InstallationsRouter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _ClassesRouter2 = require('./ClassesRouter');\n\nvar _ClassesRouter3 = _interopRequireDefault(_ClassesRouter2);\n\nvar _rest = require('../rest');\n\nvar _rest2 = _interopRequireDefault(_rest);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // InstallationsRouter.js\n\nvar InstallationsRouter = exports.InstallationsRouter = function (_ClassesRouter) {\n  _inherits(InstallationsRouter, _ClassesRouter);\n\n  function InstallationsRouter() {\n    _classCallCheck(this, InstallationsRouter);\n\n    return _possibleConstructorReturn(this, (InstallationsRouter.__proto__ || Object.getPrototypeOf(InstallationsRouter)).apply(this, arguments));\n  }\n\n  _createClass(InstallationsRouter, [{\n    key: 'handleFind',\n    value: function handleFind(req) {\n      var body = Object.assign(req.body, _ClassesRouter3.default.JSONFromQuery(req.query));\n      var options = {};\n\n      if (body.skip) {\n        options.skip = Number(body.skip);\n      }\n      if (body.limit || body.limit === 0) {\n        options.limit = Number(body.limit);\n      }\n      if (body.order) {\n        options.order = String(body.order);\n      }\n      if (body.count) {\n        options.count = true;\n      }\n      if (body.include) {\n        options.include = String(body.include);\n      }\n\n      return _rest2.default.find(req.config, req.auth, '_Installation', body.where, options, req.info.clientSDK).then(function (response) {\n        return { response: response };\n      });\n    }\n  }, {\n    key: 'handleGet',\n    value: function handleGet(req) {\n      req.params.className = '_Installation';\n      return _get(InstallationsRouter.prototype.__proto__ || Object.getPrototypeOf(InstallationsRouter.prototype), 'handleGet', this).call(this, req);\n    }\n  }, {\n    key: 'handleCreate',\n    value: function handleCreate(req) {\n      req.params.className = '_Installation';\n      return _get(InstallationsRouter.prototype.__proto__ || Object.getPrototypeOf(InstallationsRouter.prototype), 'handleCreate', this).call(this, req);\n    }\n  }, {\n    key: 'handleUpdate',\n    value: function handleUpdate(req) {\n      req.params.className = '_Installation';\n      return _get(InstallationsRouter.prototype.__proto__ || Object.getPrototypeOf(InstallationsRouter.prototype), 'handleUpdate', this).call(this, req);\n    }\n  }, {\n    key: 'handleDelete',\n    value: function handleDelete(req) {\n      req.params.className = '_Installation';\n      return _get(InstallationsRouter.prototype.__proto__ || Object.getPrototypeOf(InstallationsRouter.prototype), 'handleDelete', this).call(this, req);\n    }\n  }, {\n    key: 'mountRoutes',\n    value: function mountRoutes() {\n      var _this2 = this;\n\n      this.route('GET', '/installations', function (req) {\n        return _this2.handleFind(req);\n      });\n      this.route('GET', '/installations/:objectId', function (req) {\n        return _this2.handleGet(req);\n      });\n      this.route('POST', '/installations', function (req) {\n        return _this2.handleCreate(req);\n      });\n      this.route('PUT', '/installations/:objectId', function (req) {\n        return _this2.handleUpdate(req);\n      });\n      this.route('DELETE', '/installations/:objectId', function (req) {\n        return _this2.handleDelete(req);\n      });\n    }\n  }]);\n\n  return InstallationsRouter;\n}(_ClassesRouter3.default);\n\nexports.default = InstallationsRouter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/AdapterLoader.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadAdapter = loadAdapter;\nfunction loadAdapter(adapter, defaultAdapter, options) {\n  if (!adapter) {\n    if (!defaultAdapter) {\n      return options;\n    }\n    // Load from the default adapter when no adapter is set\n    return loadAdapter(defaultAdapter, undefined, options);\n  } else if (typeof adapter === \"function\") {\n    try {\n      return adapter(options);\n    } catch (e) {\n      if (e.name === 'TypeError') {\n        var Adapter = adapter;\n        return new Adapter(options);\n      } else {\n        throw e;\n      }\n    }\n  } else if (typeof adapter === \"string\") {\n    /* eslint-disable */\n    adapter = require(adapter);\n    // If it's define as a module, get the default\n    if (adapter.default) {\n      adapter = adapter.default;\n    }\n    return loadAdapter(adapter, undefined, options);\n  } else if (adapter.module) {\n    return loadAdapter(adapter.module, undefined, adapter.options);\n  } else if (adapter.class) {\n    return loadAdapter(adapter.class, undefined, adapter.options);\n  } else if (adapter.adapter) {\n    return loadAdapter(adapter.adapter, undefined, adapter.options);\n  }\n  // return the adapter as provided\n  return adapter;\n}\n\nexports.default = loadAdapter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Controllers/LiveQueryController.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LiveQueryController = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _ParseCloudCodePublisher = require('../LiveQuery/ParseCloudCodePublisher');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar LiveQueryController = exports.LiveQueryController = function () {\n  function LiveQueryController(config) {\n    _classCallCheck(this, LiveQueryController);\n\n    // If config is empty, we just assume no classs needs to be registered as LiveQuery\n    if (!config || !config.classNames) {\n      this.classNames = new Set();\n    } else if (config.classNames instanceof Array) {\n      this.classNames = new Set(config.classNames);\n    } else {\n      throw 'liveQuery.classes should be an array of string';\n    }\n    this.liveQueryPublisher = new _ParseCloudCodePublisher.ParseCloudCodePublisher(config);\n  }\n\n  _createClass(LiveQueryController, [{\n    key: 'onAfterSave',\n    value: function onAfterSave(className, currentObject, originalObject) {\n      if (!this.hasLiveQuery(className)) {\n        return;\n      }\n      var req = this._makePublisherRequest(currentObject, originalObject);\n      this.liveQueryPublisher.onCloudCodeAfterSave(req);\n    }\n  }, {\n    key: 'onAfterDelete',\n    value: function onAfterDelete(className, currentObject, originalObject) {\n      if (!this.hasLiveQuery(className)) {\n        return;\n      }\n      var req = this._makePublisherRequest(currentObject, originalObject);\n      this.liveQueryPublisher.onCloudCodeAfterDelete(req);\n    }\n  }, {\n    key: 'hasLiveQuery',\n    value: function hasLiveQuery(className) {\n      return this.classNames.has(className);\n    }\n  }, {\n    key: '_makePublisherRequest',\n    value: function _makePublisherRequest(currentObject, originalObject) {\n      var req = {\n        object: currentObject\n      };\n      if (currentObject) {\n        req.original = originalObject;\n      }\n      return req;\n    }\n  }]);\n\n  return LiveQueryController;\n}();\n\nexports.default = LiveQueryController;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/LiveQuery/ParseCloudCodePublisher.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParseCloudCodePublisher = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _ParsePubSub = require('./ParsePubSub');\n\nvar _node = require('parse/node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _logger = require('../logger');\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ParseCloudCodePublisher = function () {\n\n  // config object of the publisher, right now it only contains the redisURL,\n  // but we may extend it later.\n  function ParseCloudCodePublisher() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ParseCloudCodePublisher);\n\n    this.parsePublisher = _ParsePubSub.ParsePubSub.createPublisher(config);\n  }\n\n  _createClass(ParseCloudCodePublisher, [{\n    key: 'onCloudCodeAfterSave',\n    value: function onCloudCodeAfterSave(request) {\n      this._onCloudCodeMessage(_node2.default.applicationId + 'afterSave', request);\n    }\n  }, {\n    key: 'onCloudCodeAfterDelete',\n    value: function onCloudCodeAfterDelete(request) {\n      this._onCloudCodeMessage(_node2.default.applicationId + 'afterDelete', request);\n    }\n\n    // Request is the request object from cloud code functions. request.object is a ParseObject.\n\n  }, {\n    key: '_onCloudCodeMessage',\n    value: function _onCloudCodeMessage(type, request) {\n      _logger2.default.verbose('Raw request from cloud code current : %j | original : %j', request.object, request.original);\n      // We need the full JSON which includes className\n      var message = {\n        currentParseObject: request.object._toFullJSON()\n      };\n      if (request.original) {\n        message.originalParseObject = request.original._toFullJSON();\n      }\n      this.parsePublisher.publish(type, JSON.stringify(message));\n    }\n  }]);\n\n  return ParseCloudCodePublisher;\n}();\n\nexports.ParseCloudCodePublisher = ParseCloudCodePublisher;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/LiveQuery/ParsePubSub.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParsePubSub = undefined;\n\nvar _AdapterLoader = require('../Adapters/AdapterLoader');\n\nvar _EventEmitterPubSub = require('../Adapters/PubSub/EventEmitterPubSub');\n\nvar _RedisPubSub = require('../Adapters/PubSub/RedisPubSub');\n\nvar ParsePubSub = {};\n\nfunction useRedis(config) {\n  var redisURL = config.redisURL;\n  return typeof redisURL !== 'undefined' && redisURL !== '';\n}\n\nParsePubSub.createPublisher = function (config) {\n  if (useRedis(config)) {\n    return _RedisPubSub.RedisPubSub.createPublisher(config);\n  } else {\n    var adapter = (0, _AdapterLoader.loadAdapter)(config.pubSubAdapter, _EventEmitterPubSub.EventEmitterPubSub, config);\n    if (typeof adapter.createPublisher !== 'function') {\n      throw 'pubSubAdapter should have createPublisher()';\n    }\n    return adapter.createPublisher(config);\n  }\n};\n\nParsePubSub.createSubscriber = function (config) {\n  if (useRedis(config)) {\n    return _RedisPubSub.RedisPubSub.createSubscriber(config);\n  } else {\n    var adapter = (0, _AdapterLoader.loadAdapter)(config.pubSubAdapter, _EventEmitterPubSub.EventEmitterPubSub, config);\n    if (typeof adapter.createSubscriber !== 'function') {\n      throw 'pubSubAdapter should have createSubscriber()';\n    }\n    return adapter.createSubscriber(config);\n  }\n};\n\nexports.ParsePubSub = ParsePubSub;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/PubSub/EventEmitterPubSub.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EventEmitterPubSub = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = require('events');\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar emitter = new _events2.default.EventEmitter();\n\nvar Publisher = function () {\n  function Publisher(emitter) {\n    _classCallCheck(this, Publisher);\n\n    this.emitter = emitter;\n  }\n\n  _createClass(Publisher, [{\n    key: 'publish',\n    value: function publish(channel, message) {\n      this.emitter.emit(channel, message);\n    }\n  }]);\n\n  return Publisher;\n}();\n\nvar Subscriber = function (_events$EventEmitter) {\n  _inherits(Subscriber, _events$EventEmitter);\n\n  function Subscriber(emitter) {\n    _classCallCheck(this, Subscriber);\n\n    var _this = _possibleConstructorReturn(this, (Subscriber.__proto__ || Object.getPrototypeOf(Subscriber)).call(this));\n\n    _this.emitter = emitter;\n    _this.subscriptions = new Map();\n    return _this;\n  }\n\n  _createClass(Subscriber, [{\n    key: 'subscribe',\n    value: function subscribe(channel) {\n      var _this2 = this;\n\n      var handler = function handler(message) {\n        _this2.emit('message', channel, message);\n      };\n      this.subscriptions.set(channel, handler);\n      this.emitter.on(channel, handler);\n    }\n  }, {\n    key: 'unsubscribe',\n    value: function unsubscribe(channel) {\n      if (!this.subscriptions.has(channel)) {\n        return;\n      }\n      this.emitter.removeListener(channel, this.subscriptions.get(channel));\n      this.subscriptions.delete(channel);\n    }\n  }]);\n\n  return Subscriber;\n}(_events2.default.EventEmitter);\n\nfunction createPublisher() {\n  return new Publisher(emitter);\n}\n\nfunction createSubscriber() {\n  return new Subscriber(emitter);\n}\n\nvar EventEmitterPubSub = {\n  createPublisher: createPublisher,\n  createSubscriber: createSubscriber\n};\n\nexports.EventEmitterPubSub = EventEmitterPubSub;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/PubSub/RedisPubSub.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RedisPubSub = undefined;\n\nvar _redis = require('redis');\n\nvar _redis2 = _interopRequireDefault(_redis);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction createPublisher(_ref) {\n  var redisURL = _ref.redisURL;\n\n  return _redis2.default.createClient(redisURL, { no_ready_check: true });\n}\n\nfunction createSubscriber(_ref2) {\n  var redisURL = _ref2.redisURL;\n\n  return _redis2.default.createClient(redisURL, { no_ready_check: true });\n}\n\nvar RedisPubSub = {\n  createPublisher: createPublisher,\n  createSubscriber: createSubscriber\n};\n\nexports.RedisPubSub = RedisPubSub;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Routers/LogsRouter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LogsRouter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _node = require('parse/node');\n\nvar _PromiseRouter2 = require('../PromiseRouter');\n\nvar _PromiseRouter3 = _interopRequireDefault(_PromiseRouter2);\n\nvar _middlewares = require('../middlewares');\n\nvar middleware = _interopRequireWildcard(_middlewares);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar LogsRouter = exports.LogsRouter = function (_PromiseRouter) {\n  _inherits(LogsRouter, _PromiseRouter);\n\n  function LogsRouter() {\n    _classCallCheck(this, LogsRouter);\n\n    return _possibleConstructorReturn(this, (LogsRouter.__proto__ || Object.getPrototypeOf(LogsRouter)).apply(this, arguments));\n  }\n\n  _createClass(LogsRouter, [{\n    key: 'mountRoutes',\n    value: function mountRoutes() {\n      var _this2 = this;\n\n      this.route('GET', '/scriptlog', middleware.promiseEnforceMasterKeyAccess, this.validateRequest, function (req) {\n        return _this2.handleGET(req);\n      });\n    }\n  }, {\n    key: 'validateRequest',\n    value: function validateRequest(req) {\n      if (!req.config || !req.config.loggerController) {\n        throw new _node.Parse.Error(_node.Parse.Error.PUSH_MISCONFIGURED, 'Logger adapter is not available');\n      }\n    }\n\n    // Returns a promise for a {response} object.\n    // query params:\n    // level (optional) Level of logging you want to query for (info || error)\n    // from (optional) Start time for the search. Defaults to 1 week ago.\n    // until (optional) End time for the search. Defaults to current time.\n    // order (optional) Direction of results returned, either asc or desc. Defaults to desc.\n    // size (optional) Number of rows returned by search. Defaults to 10\n    // n same as size, overrides size if set\n\n  }, {\n    key: 'handleGET',\n    value: function handleGET(req) {\n      var from = req.query.from;\n      var until = req.query.until;\n      var size = req.query.size;\n      if (req.query.n) {\n        size = req.query.n;\n      }\n\n      var order = req.query.order;\n      var level = req.query.level;\n      var options = {\n        from: from,\n        until: until,\n        size: size,\n        order: order,\n        level: level\n      };\n\n      return req.config.loggerController.getLogs(options).then(function (result) {\n        return Promise.resolve({\n          response: result\n        });\n      });\n    }\n  }]);\n\n  return LogsRouter;\n}(_PromiseRouter3.default);\n\nexports.default = LogsRouter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/LiveQuery/ParseLiveQueryServer.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParseLiveQueryServer = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _tv = require('tv4');\n\nvar _tv2 = _interopRequireDefault(_tv);\n\nvar _node = require('parse/node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _Subscription = require('./Subscription');\n\nvar _Client = require('./Client');\n\nvar _ParseWebSocketServer = require('./ParseWebSocketServer');\n\nvar _logger = require('../logger');\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nvar _RequestSchema = require('./RequestSchema');\n\nvar _RequestSchema2 = _interopRequireDefault(_RequestSchema);\n\nvar _QueryTools = require('./QueryTools');\n\nvar _ParsePubSub = require('./ParsePubSub');\n\nvar _SessionTokenCache = require('./SessionTokenCache');\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ParseLiveQueryServer = function () {\n  // className -> (queryHash -> subscription)\n  function ParseLiveQueryServer(server, config) {\n    var _this = this;\n\n    _classCallCheck(this, ParseLiveQueryServer);\n\n    this.clientId = 0;\n    this.clients = new Map();\n    this.subscriptions = new Map();\n\n    config = config || {};\n\n    // Store keys, convert obj to map\n    var keyPairs = config.keyPairs || {};\n    this.keyPairs = new Map();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = Object.keys(keyPairs)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var key = _step.value;\n\n        this.keyPairs.set(key, keyPairs[key]);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    _logger2.default.verbose('Support key pairs', this.keyPairs);\n\n    // Initialize Parse\n    _node2.default.Object.disableSingleInstance();\n\n    var serverURL = config.serverURL || _node2.default.serverURL;\n    _node2.default.serverURL = serverURL;\n    var appId = config.appId || _node2.default.applicationId;\n    var javascriptKey = _node2.default.javaScriptKey;\n    var masterKey = config.masterKey || _node2.default.masterKey;\n    _node2.default.initialize(appId, javascriptKey, masterKey);\n\n    // Initialize websocket server\n    this.parseWebSocketServer = new _ParseWebSocketServer.ParseWebSocketServer(server, function (parseWebsocket) {\n      return _this._onConnect(parseWebsocket);\n    }, config.websocketTimeout);\n\n    // Initialize subscriber\n    this.subscriber = _ParsePubSub.ParsePubSub.createSubscriber(config);\n    this.subscriber.subscribe(_node2.default.applicationId + 'afterSave');\n    this.subscriber.subscribe(_node2.default.applicationId + 'afterDelete');\n    // Register message handler for subscriber. When publisher get messages, it will publish message\n    // to the subscribers and the handler will be called.\n    this.subscriber.on('message', function (channel, messageStr) {\n      _logger2.default.verbose('Subscribe messsage %j', messageStr);\n      var message = void 0;\n      try {\n        message = JSON.parse(messageStr);\n      } catch (e) {\n        _logger2.default.error('unable to parse message', messageStr, e);\n        return;\n      }\n      _this._inflateParseObject(message);\n      if (channel === _node2.default.applicationId + 'afterSave') {\n        _this._onAfterSave(message);\n      } else if (channel === _node2.default.applicationId + 'afterDelete') {\n        _this._onAfterDelete(message);\n      } else {\n        _logger2.default.error('Get message %s from unknown channel %j', message, channel);\n      }\n    });\n\n    // Initialize sessionToken cache\n    this.sessionTokenCache = new _SessionTokenCache.SessionTokenCache(config.cacheTimeout);\n  }\n\n  // Message is the JSON object from publisher. Message.currentParseObject is the ParseObject JSON after changes.\n  // Message.originalParseObject is the original ParseObject JSON.\n\n  // The subscriber we use to get object update from publisher\n\n\n  _createClass(ParseLiveQueryServer, [{\n    key: '_inflateParseObject',\n    value: function _inflateParseObject(message) {\n      // Inflate merged object\n      var currentParseObject = message.currentParseObject;\n      var className = currentParseObject.className;\n      var parseObject = new _node2.default.Object(className);\n      parseObject._finishFetch(currentParseObject);\n      message.currentParseObject = parseObject;\n      // Inflate original object\n      var originalParseObject = message.originalParseObject;\n      if (originalParseObject) {\n        className = originalParseObject.className;\n        parseObject = new _node2.default.Object(className);\n        parseObject._finishFetch(originalParseObject);\n        message.originalParseObject = parseObject;\n      }\n    }\n\n    // Message is the JSON object from publisher after inflated. Message.currentParseObject is the ParseObject after changes.\n    // Message.originalParseObject is the original ParseObject.\n\n  }, {\n    key: '_onAfterDelete',\n    value: function _onAfterDelete(message) {\n      var _this2 = this;\n\n      _logger2.default.verbose(_node2.default.applicationId + 'afterDelete is triggered');\n\n      var deletedParseObject = message.currentParseObject.toJSON();\n      var className = deletedParseObject.className;\n      _logger2.default.verbose('ClassName: %j | ObjectId: %s', className, deletedParseObject.id);\n      _logger2.default.verbose('Current client number : %d', this.clients.size);\n\n      var classSubscriptions = this.subscriptions.get(className);\n      if (typeof classSubscriptions === 'undefined') {\n        _logger2.default.debug('Can not find subscriptions under this class ' + className);\n        return;\n      }\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = classSubscriptions.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var subscription = _step2.value;\n\n          var isSubscriptionMatched = this._matchesSubscription(deletedParseObject, subscription);\n          if (!isSubscriptionMatched) {\n            continue;\n          }\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            var _loop = function _loop() {\n              var _step3$value = _slicedToArray(_step3.value, 2),\n                  clientId = _step3$value[0],\n                  requestIds = _step3$value[1];\n\n              var client = _this2.clients.get(clientId);\n              if (typeof client === 'undefined') {\n                return 'continue';\n              }\n              var _iteratorNormalCompletion4 = true;\n              var _didIteratorError4 = false;\n              var _iteratorError4 = undefined;\n\n              try {\n                var _loop2 = function _loop2() {\n                  var requestId = _step4.value;\n\n                  var acl = message.currentParseObject.getACL();\n                  // Check ACL\n                  _this2._matchesACL(acl, client, requestId).then(function (isMatched) {\n                    if (!isMatched) {\n                      return null;\n                    }\n                    client.pushDelete(requestId, deletedParseObject);\n                  }, function (error) {\n                    _logger2.default.error('Matching ACL error : ', error);\n                  });\n                };\n\n                for (var _iterator4 = requestIds[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                  _loop2();\n                }\n              } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                    _iterator4.return();\n                  }\n                } finally {\n                  if (_didIteratorError4) {\n                    throw _iteratorError4;\n                  }\n                }\n              }\n            };\n\n            for (var _iterator3 = _lodash2.default.entries(subscription.clientRequestIds)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var _ret = _loop();\n\n              if (_ret === 'continue') continue;\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n\n    // Message is the JSON object from publisher after inflated. Message.currentParseObject is the ParseObject after changes.\n    // Message.originalParseObject is the original ParseObject.\n\n  }, {\n    key: '_onAfterSave',\n    value: function _onAfterSave(message) {\n      var _this3 = this;\n\n      _logger2.default.verbose(_node2.default.applicationId + 'afterSave is triggered');\n\n      var originalParseObject = null;\n      if (message.originalParseObject) {\n        originalParseObject = message.originalParseObject.toJSON();\n      }\n      var currentParseObject = message.currentParseObject.toJSON();\n      var className = currentParseObject.className;\n      _logger2.default.verbose('ClassName: %s | ObjectId: %s', className, currentParseObject.id);\n      _logger2.default.verbose('Current client number : %d', this.clients.size);\n\n      var classSubscriptions = this.subscriptions.get(className);\n      if (typeof classSubscriptions === 'undefined') {\n        _logger2.default.debug('Can not find subscriptions under this class ' + className);\n        return;\n      }\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        var _loop3 = function _loop3() {\n          var subscription = _step5.value;\n\n          var isOriginalSubscriptionMatched = _this3._matchesSubscription(originalParseObject, subscription);\n          var isCurrentSubscriptionMatched = _this3._matchesSubscription(currentParseObject, subscription);\n          var _iteratorNormalCompletion6 = true;\n          var _didIteratorError6 = false;\n          var _iteratorError6 = undefined;\n\n          try {\n            var _loop4 = function _loop4() {\n              var _step6$value = _slicedToArray(_step6.value, 2),\n                  clientId = _step6$value[0],\n                  requestIds = _step6$value[1];\n\n              var client = _this3.clients.get(clientId);\n              if (typeof client === 'undefined') {\n                return 'continue';\n              }\n              var _iteratorNormalCompletion7 = true;\n              var _didIteratorError7 = false;\n              var _iteratorError7 = undefined;\n\n              try {\n                var _loop5 = function _loop5() {\n                  var requestId = _step7.value;\n\n                  // Set orignal ParseObject ACL checking promise, if the object does not match\n                  // subscription, we do not need to check ACL\n                  var originalACLCheckingPromise = void 0;\n                  if (!isOriginalSubscriptionMatched) {\n                    originalACLCheckingPromise = _node2.default.Promise.as(false);\n                  } else {\n                    var originalACL = void 0;\n                    if (message.originalParseObject) {\n                      originalACL = message.originalParseObject.getACL();\n                    }\n                    originalACLCheckingPromise = _this3._matchesACL(originalACL, client, requestId);\n                  }\n                  // Set current ParseObject ACL checking promise, if the object does not match\n                  // subscription, we do not need to check ACL\n                  var currentACLCheckingPromise = void 0;\n                  if (!isCurrentSubscriptionMatched) {\n                    currentACLCheckingPromise = _node2.default.Promise.as(false);\n                  } else {\n                    var currentACL = message.currentParseObject.getACL();\n                    currentACLCheckingPromise = _this3._matchesACL(currentACL, client, requestId);\n                  }\n\n                  _node2.default.Promise.when(originalACLCheckingPromise, currentACLCheckingPromise).then(function (isOriginalMatched, isCurrentMatched) {\n                    _logger2.default.verbose('Original %j | Current %j | Match: %s, %s, %s, %s | Query: %s', originalParseObject, currentParseObject, isOriginalSubscriptionMatched, isCurrentSubscriptionMatched, isOriginalMatched, isCurrentMatched, subscription.hash);\n\n                    // Decide event type\n                    var type = void 0;\n                    if (isOriginalMatched && isCurrentMatched) {\n                      type = 'Update';\n                    } else if (isOriginalMatched && !isCurrentMatched) {\n                      type = 'Leave';\n                    } else if (!isOriginalMatched && isCurrentMatched) {\n                      if (originalParseObject) {\n                        type = 'Enter';\n                      } else {\n                        type = 'Create';\n                      }\n                    } else {\n                      return null;\n                    }\n                    var functionName = 'push' + type;\n                    client[functionName](requestId, currentParseObject);\n                  }, function (error) {\n                    _logger2.default.error('Matching ACL error : ', error);\n                  });\n                };\n\n                for (var _iterator7 = requestIds[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                  _loop5();\n                }\n              } catch (err) {\n                _didIteratorError7 = true;\n                _iteratorError7 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                    _iterator7.return();\n                  }\n                } finally {\n                  if (_didIteratorError7) {\n                    throw _iteratorError7;\n                  }\n                }\n              }\n            };\n\n            for (var _iterator6 = _lodash2.default.entries(subscription.clientRequestIds)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n              var _ret4 = _loop4();\n\n              if (_ret4 === 'continue') continue;\n            }\n          } catch (err) {\n            _didIteratorError6 = true;\n            _iteratorError6 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                _iterator6.return();\n              }\n            } finally {\n              if (_didIteratorError6) {\n                throw _iteratorError6;\n              }\n            }\n          }\n        };\n\n        for (var _iterator5 = classSubscriptions.values()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          _loop3();\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n    }\n  }, {\n    key: '_onConnect',\n    value: function _onConnect(parseWebsocket) {\n      var _this4 = this;\n\n      parseWebsocket.on('message', function (request) {\n        if (typeof request === 'string') {\n          try {\n            request = JSON.parse(request);\n          } catch (e) {\n            _logger2.default.error('unable to parse request', request, e);\n            return;\n          }\n        }\n        _logger2.default.verbose('Request: %j', request);\n\n        // Check whether this request is a valid request, return error directly if not\n        if (!_tv2.default.validate(request, _RequestSchema2.default['general']) || !_tv2.default.validate(request, _RequestSchema2.default[request.op])) {\n          _Client.Client.pushError(parseWebsocket, 1, _tv2.default.error.message);\n          _logger2.default.error('Connect message error %s', _tv2.default.error.message);\n          return;\n        }\n\n        switch (request.op) {\n          case 'connect':\n            _this4._handleConnect(parseWebsocket, request);\n            break;\n          case 'subscribe':\n            _this4._handleSubscribe(parseWebsocket, request);\n            break;\n          case 'update':\n            _this4._handleUpdateSubscription(parseWebsocket, request);\n            break;\n          case 'unsubscribe':\n            _this4._handleUnsubscribe(parseWebsocket, request);\n            break;\n          default:\n            _Client.Client.pushError(parseWebsocket, 3, 'Get unknown operation');\n            _logger2.default.error('Get unknown operation', request.op);\n        }\n      });\n\n      parseWebsocket.on('disconnect', function () {\n        _logger2.default.info('Client disconnect: %d', parseWebsocket.clientId);\n        var clientId = parseWebsocket.clientId;\n        if (!_this4.clients.has(clientId)) {\n          _logger2.default.error('Can not find client %d on disconnect', clientId);\n          return;\n        }\n\n        // Delete client\n        var client = _this4.clients.get(clientId);\n        _this4.clients.delete(clientId);\n\n        // Delete client from subscriptions\n        var _iteratorNormalCompletion8 = true;\n        var _didIteratorError8 = false;\n        var _iteratorError8 = undefined;\n\n        try {\n          for (var _iterator8 = _lodash2.default.entries(client.subscriptionInfos)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n            var _step8$value = _slicedToArray(_step8.value, 2),\n                _requestId = _step8$value[0],\n                subscriptionInfo = _step8$value[1];\n\n            var _subscription = subscriptionInfo.subscription;\n            _subscription.deleteClientSubscription(clientId, _requestId);\n\n            // If there is no client which is subscribing this subscription, remove it from subscriptions\n            var classSubscriptions = _this4.subscriptions.get(_subscription.className);\n            if (!_subscription.hasSubscribingClient()) {\n              classSubscriptions.delete(_subscription.hash);\n            }\n            // If there is no subscriptions under this class, remove it from subscriptions\n            if (classSubscriptions.size === 0) {\n              _this4.subscriptions.delete(_subscription.className);\n            }\n          }\n        } catch (err) {\n          _didIteratorError8 = true;\n          _iteratorError8 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion8 && _iterator8.return) {\n              _iterator8.return();\n            }\n          } finally {\n            if (_didIteratorError8) {\n              throw _iteratorError8;\n            }\n          }\n        }\n\n        _logger2.default.verbose('Current clients %d', _this4.clients.size);\n        _logger2.default.verbose('Current subscriptions %d', _this4.subscriptions.size);\n      });\n    }\n  }, {\n    key: '_matchesSubscription',\n    value: function _matchesSubscription(parseObject, subscription) {\n      // Object is undefined or null, not match\n      if (!parseObject) {\n        return false;\n      }\n      return (0, _QueryTools.matchesQuery)(parseObject, subscription.query);\n    }\n  }, {\n    key: '_matchesACL',\n    value: function _matchesACL(acl, client, requestId) {\n      var _this5 = this;\n\n      // If ACL is undefined or null, or ACL has public read access, return true directly\n      if (!acl || acl.getPublicReadAccess()) {\n        return _node2.default.Promise.as(true);\n      }\n      // Check subscription sessionToken matches ACL first\n      var subscriptionInfo = client.getSubscriptionInfo(requestId);\n      if (typeof subscriptionInfo === 'undefined') {\n        return _node2.default.Promise.as(false);\n      }\n\n      var subscriptionSessionToken = subscriptionInfo.sessionToken;\n      return this.sessionTokenCache.getUserId(subscriptionSessionToken).then(function (userId) {\n        return acl.getReadAccess(userId);\n      }).then(function (isSubscriptionSessionTokenMatched) {\n        if (isSubscriptionSessionTokenMatched) {\n          return _node2.default.Promise.as(true);\n        }\n\n        // Check if the user has any roles that match the ACL\n        return new _node2.default.Promise(function (resolve, reject) {\n\n          // Resolve false right away if the acl doesn't have any roles\n          var acl_has_roles = Object.keys(acl.permissionsById).some(function (key) {\n            return key.startsWith(\"role:\");\n          });\n          if (!acl_has_roles) {\n            return resolve(false);\n          }\n\n          _this5.sessionTokenCache.getUserId(subscriptionSessionToken).then(function (userId) {\n\n            // Pass along a null if there is no user id\n            if (!userId) {\n              return _node2.default.Promise.as(null);\n            }\n\n            // Prepare a user object to query for roles\n            // To eliminate a query for the user, create one locally with the id\n            var user = new _node2.default.User();\n            user.id = userId;\n            return user;\n          }).then(function (user) {\n\n            // Pass along an empty array (of roles) if no user\n            if (!user) {\n              return _node2.default.Promise.as([]);\n            }\n\n            // Then get the user's roles\n            var rolesQuery = new _node2.default.Query(_node2.default.Role);\n            rolesQuery.equalTo(\"users\", user);\n            return rolesQuery.find({ useMasterKey: true });\n          }).then(function (roles) {\n\n            // Finally, see if any of the user's roles allow them read access\n            var _iteratorNormalCompletion9 = true;\n            var _didIteratorError9 = false;\n            var _iteratorError9 = undefined;\n\n            try {\n              for (var _iterator9 = roles[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                var role = _step9.value;\n\n                if (acl.getRoleReadAccess(role)) {\n                  return resolve(true);\n                }\n              }\n            } catch (err) {\n              _didIteratorError9 = true;\n              _iteratorError9 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion9 && _iterator9.return) {\n                  _iterator9.return();\n                }\n              } finally {\n                if (_didIteratorError9) {\n                  throw _iteratorError9;\n                }\n              }\n            }\n\n            resolve(false);\n          }).catch(function (error) {\n            reject(error);\n          });\n        });\n      }).then(function (isRoleMatched) {\n\n        if (isRoleMatched) {\n          return _node2.default.Promise.as(true);\n        }\n\n        // Check client sessionToken matches ACL\n        var clientSessionToken = client.sessionToken;\n        return _this5.sessionTokenCache.getUserId(clientSessionToken).then(function (userId) {\n          return acl.getReadAccess(userId);\n        });\n      }).then(function (isMatched) {\n        return _node2.default.Promise.as(isMatched);\n      }, function () {\n        return _node2.default.Promise.as(false);\n      });\n    }\n  }, {\n    key: '_handleConnect',\n    value: function _handleConnect(parseWebsocket, request) {\n      if (!this._validateKeys(request, this.keyPairs)) {\n        _Client.Client.pushError(parseWebsocket, 4, 'Key in request is not valid');\n        _logger2.default.error('Key in request is not valid');\n        return;\n      }\n      var client = new _Client.Client(this.clientId, parseWebsocket);\n      parseWebsocket.clientId = this.clientId;\n      this.clientId += 1;\n      this.clients.set(parseWebsocket.clientId, client);\n      _logger2.default.info('Create new client: %d', parseWebsocket.clientId);\n      client.pushConnect();\n    }\n  }, {\n    key: '_validateKeys',\n    value: function _validateKeys(request, validKeyPairs) {\n      if (!validKeyPairs || validKeyPairs.size == 0) {\n        return true;\n      }\n      var isValid = false;\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = validKeyPairs[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var _step10$value = _slicedToArray(_step10.value, 2),\n              key = _step10$value[0],\n              secret = _step10$value[1];\n\n          if (!request[key] || request[key] !== secret) {\n            continue;\n          }\n          isValid = true;\n          break;\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n\n      return isValid;\n    }\n  }, {\n    key: '_handleSubscribe',\n    value: function _handleSubscribe(parseWebsocket, request) {\n      // If we can not find this client, return error to client\n      if (!parseWebsocket.hasOwnProperty('clientId')) {\n        _Client.Client.pushError(parseWebsocket, 2, 'Can not find this client, make sure you connect to server before subscribing');\n        _logger2.default.error('Can not find this client, make sure you connect to server before subscribing');\n        return;\n      }\n      var client = this.clients.get(parseWebsocket.clientId);\n\n      // Get subscription from subscriptions, create one if necessary\n      var subscriptionHash = (0, _QueryTools.queryHash)(request.query);\n      // Add className to subscriptions if necessary\n      var className = request.query.className;\n      if (!this.subscriptions.has(className)) {\n        this.subscriptions.set(className, new Map());\n      }\n      var classSubscriptions = this.subscriptions.get(className);\n      var subscription = void 0;\n      if (classSubscriptions.has(subscriptionHash)) {\n        subscription = classSubscriptions.get(subscriptionHash);\n      } else {\n        subscription = new _Subscription.Subscription(className, request.query.where, subscriptionHash);\n        classSubscriptions.set(subscriptionHash, subscription);\n      }\n\n      // Add subscriptionInfo to client\n      var subscriptionInfo = {\n        subscription: subscription\n      };\n      // Add selected fields and sessionToken for this subscription if necessary\n      if (request.query.fields) {\n        subscriptionInfo.fields = request.query.fields;\n      }\n      if (request.sessionToken) {\n        subscriptionInfo.sessionToken = request.sessionToken;\n      }\n      client.addSubscriptionInfo(request.requestId, subscriptionInfo);\n\n      // Add clientId to subscription\n      subscription.addClientSubscription(parseWebsocket.clientId, request.requestId);\n\n      client.pushSubscribe(request.requestId);\n\n      _logger2.default.verbose('Create client %d new subscription: %d', parseWebsocket.clientId, request.requestId);\n      _logger2.default.verbose('Current client number: %d', this.clients.size);\n    }\n  }, {\n    key: '_handleUpdateSubscription',\n    value: function _handleUpdateSubscription(parseWebsocket, request) {\n      this._handleUnsubscribe(parseWebsocket, request, false);\n      this._handleSubscribe(parseWebsocket, request);\n    }\n  }, {\n    key: '_handleUnsubscribe',\n    value: function _handleUnsubscribe(parseWebsocket, request) {\n      var notifyClient = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      // If we can not find this client, return error to client\n      if (!parseWebsocket.hasOwnProperty('clientId')) {\n        _Client.Client.pushError(parseWebsocket, 2, 'Can not find this client, make sure you connect to server before unsubscribing');\n        _logger2.default.error('Can not find this client, make sure you connect to server before unsubscribing');\n        return;\n      }\n      var requestId = request.requestId;\n      var client = this.clients.get(parseWebsocket.clientId);\n      if (typeof client === 'undefined') {\n        _Client.Client.pushError(parseWebsocket, 2, 'Cannot find client with clientId ' + parseWebsocket.clientId + '. Make sure you connect to live query server before unsubscribing.');\n        _logger2.default.error('Can not find this client ' + parseWebsocket.clientId);\n        return;\n      }\n\n      var subscriptionInfo = client.getSubscriptionInfo(requestId);\n      if (typeof subscriptionInfo === 'undefined') {\n        _Client.Client.pushError(parseWebsocket, 2, 'Cannot find subscription with clientId ' + parseWebsocket.clientId + ' subscriptionId ' + requestId + '. Make sure you subscribe to live query server before unsubscribing.');\n        _logger2.default.error('Can not find subscription with clientId ' + parseWebsocket.clientId + ' subscriptionId ' + requestId);\n        return;\n      }\n\n      // Remove subscription from client\n      client.deleteSubscriptionInfo(requestId);\n      // Remove client from subscription\n      var subscription = subscriptionInfo.subscription;\n      var className = subscription.className;\n      subscription.deleteClientSubscription(parseWebsocket.clientId, requestId);\n      // If there is no client which is subscribing this subscription, remove it from subscriptions\n      var classSubscriptions = this.subscriptions.get(className);\n      if (!subscription.hasSubscribingClient()) {\n        classSubscriptions.delete(subscription.hash);\n      }\n      // If there is no subscriptions under this class, remove it from subscriptions\n      if (classSubscriptions.size === 0) {\n        this.subscriptions.delete(className);\n      }\n\n      if (!notifyClient) {\n        return;\n      }\n\n      client.pushUnsubscribe(request.requestId);\n\n      _logger2.default.verbose('Delete client: %d | subscription: %d', parseWebsocket.clientId, request.requestId);\n    }\n  }]);\n\n  return ParseLiveQueryServer;\n}();\n\nexports.ParseLiveQueryServer = ParseLiveQueryServer;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/LiveQuery/Subscription.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subscription = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _logger = require('../logger');\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Subscription = function () {\n  // It is query condition eg query.where\n  function Subscription(className, query, queryHash) {\n    _classCallCheck(this, Subscription);\n\n    this.className = className;\n    this.query = query;\n    this.hash = queryHash;\n    this.clientRequestIds = new Map();\n  }\n\n  _createClass(Subscription, [{\n    key: 'addClientSubscription',\n    value: function addClientSubscription(clientId, requestId) {\n      if (!this.clientRequestIds.has(clientId)) {\n        this.clientRequestIds.set(clientId, []);\n      }\n      var requestIds = this.clientRequestIds.get(clientId);\n      requestIds.push(requestId);\n    }\n  }, {\n    key: 'deleteClientSubscription',\n    value: function deleteClientSubscription(clientId, requestId) {\n      var requestIds = this.clientRequestIds.get(clientId);\n      if (typeof requestIds === 'undefined') {\n        _logger2.default.error('Can not find client %d to delete', clientId);\n        return;\n      }\n\n      var index = requestIds.indexOf(requestId);\n      if (index < 0) {\n        _logger2.default.error('Can not find client %d subscription %d to delete', clientId, requestId);\n        return;\n      }\n      requestIds.splice(index, 1);\n      // Delete client reference if it has no subscription\n      if (requestIds.length == 0) {\n        this.clientRequestIds.delete(clientId);\n      }\n    }\n  }, {\n    key: 'hasSubscribingClient',\n    value: function hasSubscribingClient() {\n      return this.clientRequestIds.size > 0;\n    }\n  }]);\n\n  return Subscription;\n}();\n\nexports.Subscription = Subscription;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/LiveQuery/Client.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Client = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _logger = require('../logger');\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar dafaultFields = ['className', 'objectId', 'updatedAt', 'createdAt', 'ACL'];\n\nvar Client = function () {\n  function Client(id, parseWebSocket) {\n    _classCallCheck(this, Client);\n\n    this.id = id;\n    this.parseWebSocket = parseWebSocket;\n    this.roles = [];\n    this.subscriptionInfos = new Map();\n    this.pushConnect = this._pushEvent('connected');\n    this.pushSubscribe = this._pushEvent('subscribed');\n    this.pushUnsubscribe = this._pushEvent('unsubscribed');\n    this.pushCreate = this._pushEvent('create');\n    this.pushEnter = this._pushEvent('enter');\n    this.pushUpdate = this._pushEvent('update');\n    this.pushDelete = this._pushEvent('delete');\n    this.pushLeave = this._pushEvent('leave');\n  }\n\n  _createClass(Client, [{\n    key: 'addSubscriptionInfo',\n    value: function addSubscriptionInfo(requestId, subscriptionInfo) {\n      this.subscriptionInfos.set(requestId, subscriptionInfo);\n    }\n  }, {\n    key: 'getSubscriptionInfo',\n    value: function getSubscriptionInfo(requestId) {\n      return this.subscriptionInfos.get(requestId);\n    }\n  }, {\n    key: 'deleteSubscriptionInfo',\n    value: function deleteSubscriptionInfo(requestId) {\n      return this.subscriptionInfos.delete(requestId);\n    }\n  }, {\n    key: '_pushEvent',\n    value: function _pushEvent(type) {\n      return function (subscriptionId, parseObjectJSON) {\n        var response = {\n          'op': type,\n          'clientId': this.id\n        };\n        if (typeof subscriptionId !== 'undefined') {\n          response['requestId'] = subscriptionId;\n        }\n        if (typeof parseObjectJSON !== 'undefined') {\n          var fields = void 0;\n          if (this.subscriptionInfos.has(subscriptionId)) {\n            fields = this.subscriptionInfos.get(subscriptionId).fields;\n          }\n          response['object'] = this._toJSONWithFields(parseObjectJSON, fields);\n        }\n        Client.pushResponse(this.parseWebSocket, JSON.stringify(response));\n      };\n    }\n  }, {\n    key: '_toJSONWithFields',\n    value: function _toJSONWithFields(parseObjectJSON, fields) {\n      if (!fields) {\n        return parseObjectJSON;\n      }\n      var limitedParseObject = {};\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = dafaultFields[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var field = _step.value;\n\n          limitedParseObject[field] = parseObjectJSON[field];\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = fields[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _field = _step2.value;\n\n          if (_field in parseObjectJSON) {\n            limitedParseObject[_field] = parseObjectJSON[_field];\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return limitedParseObject;\n    }\n  }], [{\n    key: 'pushResponse',\n    value: function pushResponse(parseWebSocket, message) {\n      _logger2.default.verbose('Push Response : %j', message);\n      parseWebSocket.send(message);\n    }\n  }, {\n    key: 'pushError',\n    value: function pushError(parseWebSocket, code, error) {\n      var reconnect = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n      Client.pushResponse(parseWebSocket, JSON.stringify({\n        'op': 'error',\n        'error': error,\n        'code': code,\n        'reconnect': reconnect\n      }));\n    }\n  }]);\n\n  return Client;\n}();\n\nexports.Client = Client;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/LiveQuery/ParseWebSocketServer.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParseWebSocket = exports.ParseWebSocketServer = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _logger = require('../logger');\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar typeMap = new Map([['disconnect', 'close']]);\nvar getWS = function getWS() {\n  try {\n    return require('uws');\n  } catch (e) {\n    return require('ws');\n  }\n};\n\nvar ParseWebSocketServer = exports.ParseWebSocketServer = function ParseWebSocketServer(server, onConnect) {\n  var websocketTimeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10 * 1000;\n\n  _classCallCheck(this, ParseWebSocketServer);\n\n  var WebSocketServer = getWS().Server;\n  var wss = new WebSocketServer({ server: server });\n  wss.on('listening', function () {\n    _logger2.default.info('Parse LiveQuery Server starts running');\n  });\n  wss.on('connection', function (ws) {\n    onConnect(new ParseWebSocket(ws));\n    // Send ping to client periodically\n    var pingIntervalId = setInterval(function () {\n      if (ws.readyState == ws.OPEN) {\n        ws.ping();\n      } else {\n        clearInterval(pingIntervalId);\n      }\n    }, websocketTimeout);\n  });\n  this.server = wss;\n};\n\nvar ParseWebSocket = exports.ParseWebSocket = function () {\n  function ParseWebSocket(ws) {\n    _classCallCheck(this, ParseWebSocket);\n\n    this.ws = ws;\n  }\n\n  _createClass(ParseWebSocket, [{\n    key: 'on',\n    value: function on(type, callback) {\n      var wsType = typeMap.has(type) ? typeMap.get(type) : type;\n      this.ws.on(wsType, callback);\n    }\n  }, {\n    key: 'send',\n    value: function send(message) {\n      this.ws.send(message);\n    }\n  }]);\n\n  return ParseWebSocket;\n}();","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/LiveQuery/RequestSchema.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar general = {\n  'title': 'General request schema',\n  'type': 'object',\n  'properties': {\n    'op': {\n      'type': 'string',\n      'enum': ['connect', 'subscribe', 'unsubscribe', 'update']\n    }\n  }\n};\n\nvar connect = {\n  'title': 'Connect operation schema',\n  'type': 'object',\n  'properties': {\n    'op': 'connect',\n    'applicationId': {\n      'type': 'string'\n    },\n    'javascriptKey': {\n      type: 'string'\n    },\n    'masterKey': {\n      type: 'string'\n    },\n    'clientKey': {\n      type: 'string'\n    },\n    'windowsKey': {\n      type: 'string'\n    },\n    'restAPIKey': {\n      'type': 'string'\n    },\n    'sessionToken': {\n      'type': 'string'\n    }\n  },\n  'required': ['op', 'applicationId'],\n  \"additionalProperties\": false\n};\n\nvar subscribe = {\n  'title': 'Subscribe operation schema',\n  'type': 'object',\n  'properties': {\n    'op': 'subscribe',\n    'requestId': {\n      'type': 'number'\n    },\n    'query': {\n      'title': 'Query field schema',\n      'type': 'object',\n      'properties': {\n        'className': {\n          'type': 'string'\n        },\n        'where': {\n          'type': 'object'\n        },\n        'fields': {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"minItems\": 1,\n          \"uniqueItems\": true\n        }\n      },\n      'required': ['where', 'className'],\n      'additionalProperties': false\n    },\n    'sessionToken': {\n      'type': 'string'\n    }\n  },\n  'required': ['op', 'requestId', 'query'],\n  'additionalProperties': false\n};\n\nvar update = {\n  'title': 'Update operation schema',\n  'type': 'object',\n  'properties': {\n    'op': 'update',\n    'requestId': {\n      'type': 'number'\n    },\n    'query': {\n      'title': 'Query field schema',\n      'type': 'object',\n      'properties': {\n        'className': {\n          'type': 'string'\n        },\n        'where': {\n          'type': 'object'\n        },\n        'fields': {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"minItems\": 1,\n          \"uniqueItems\": true\n        }\n      },\n      'required': ['where', 'className'],\n      'additionalProperties': false\n    },\n    'sessionToken': {\n      'type': 'string'\n    }\n  },\n  'required': ['op', 'requestId', 'query'],\n  'additionalProperties': false\n};\n\nvar unsubscribe = {\n  'title': 'Unsubscribe operation schema',\n  'type': 'object',\n  'properties': {\n    'op': 'unsubscribe',\n    'requestId': {\n      'type': 'number'\n    }\n  },\n  'required': ['op', 'requestId'],\n  \"additionalProperties\": false\n};\n\nvar RequestSchema = {\n  'general': general,\n  'connect': connect,\n  'subscribe': subscribe,\n  'update': update,\n  'unsubscribe': unsubscribe\n};\n\nexports.default = RequestSchema;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/LiveQuery/QueryTools.js":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar equalObjects = require('./equalObjects');\nvar Id = require('./Id');\nvar Parse = require('parse/node');\n\n/**\n * Query Hashes are deterministic hashes for Parse Queries.\n * Any two queries that have the same set of constraints will produce the same\n * hash. This lets us reliably group components by the queries they depend upon,\n * and quickly determine if a query has changed.\n */\n\n/**\n * Convert $or queries into an array of where conditions\n */\nfunction flattenOrQueries(where) {\n  if (!where.hasOwnProperty('$or')) {\n    return where;\n  }\n  var accum = [];\n  for (var i = 0; i < where.$or.length; i++) {\n    accum = accum.concat(where.$or[i]);\n  }\n  return accum;\n}\n\n/**\n * Deterministically turns an object into a string. Disregards ordering\n */\nfunction stringify(object) {\n  if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object' || object === null) {\n    if (typeof object === 'string') {\n      return '\"' + object.replace(/\\|/g, '%|') + '\"';\n    }\n    return object + '';\n  }\n  if (Array.isArray(object)) {\n    var copy = object.map(stringify);\n    copy.sort();\n    return '[' + copy.join(',') + ']';\n  }\n  var sections = [];\n  var keys = Object.keys(object);\n  keys.sort();\n  for (var k = 0; k < keys.length; k++) {\n    sections.push(stringify(keys[k]) + ':' + stringify(object[keys[k]]));\n  }\n  return '{' + sections.join(',') + '}';\n}\n\n/**\n * Generate a hash from a query, with unique fields for columns, values, order,\n * skip, and limit.\n */\nfunction queryHash(query) {\n  if (query instanceof Parse.Query) {\n    query = {\n      className: query.className,\n      where: query._where\n    };\n  }\n  var where = flattenOrQueries(query.where || {});\n  var columns = [];\n  var values = [];\n  var i;\n  if (Array.isArray(where)) {\n    var uniqueColumns = {};\n    for (i = 0; i < where.length; i++) {\n      var subValues = {};\n      var keys = Object.keys(where[i]);\n      keys.sort();\n      for (var j = 0; j < keys.length; j++) {\n        subValues[keys[j]] = where[i][keys[j]];\n        uniqueColumns[keys[j]] = true;\n      }\n      values.push(subValues);\n    }\n    columns = Object.keys(uniqueColumns);\n    columns.sort();\n  } else {\n    columns = Object.keys(where);\n    columns.sort();\n    for (i = 0; i < columns.length; i++) {\n      values.push(where[columns[i]]);\n    }\n  }\n\n  var sections = [columns.join(','), stringify(values)];\n\n  return query.className + ':' + sections.join('|');\n}\n\n/**\n * matchesQuery -- Determines if an object would be returned by a Parse Query\n * It's a lightweight, where-clause only implementation of a full query engine.\n * Since we find queries that match objects, rather than objects that match\n * queries, we can avoid building a full-blown query tool.\n */\nfunction matchesQuery(object, query) {\n  if (query instanceof Parse.Query) {\n    var className = object.id instanceof Id ? object.id.className : object.className;\n    if (className !== query.className) {\n      return false;\n    }\n    return matchesQuery(object, query._where);\n  }\n  for (var field in query) {\n    if (!matchesKeyConstraints(object, field, query[field])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction equalObjectsGeneric(obj, compareTo, eqlFn) {\n  if (Array.isArray(obj)) {\n    for (var i = 0; i < obj.length; i++) {\n      if (eqlFn(obj[i], compareTo)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  return eqlFn(obj, compareTo);\n}\n\n/**\n * Determines whether an object matches a single key's constraints\n */\nfunction matchesKeyConstraints(object, key, constraints) {\n  if (constraints === null) {\n    return false;\n  }\n  if (key.indexOf(\".\") >= 0) {\n    // Key references a subobject\n    var keyComponents = key.split(\".\");\n    var subObjectKey = keyComponents[0];\n    var keyRemainder = keyComponents.slice(1).join(\".\");\n    return matchesKeyConstraints(object[subObjectKey] || {}, keyRemainder, constraints);\n  }\n  var i;\n  if (key === '$or') {\n    for (i = 0; i < constraints.length; i++) {\n      if (matchesQuery(object, constraints[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n  if (key === '$relatedTo') {\n    // Bail! We can't handle relational queries locally\n    return false;\n  }\n  // Equality (or Array contains) cases\n  if ((typeof constraints === 'undefined' ? 'undefined' : _typeof(constraints)) !== 'object') {\n    if (Array.isArray(object[key])) {\n      return object[key].indexOf(constraints) > -1;\n    }\n    return object[key] === constraints;\n  }\n  var compareTo;\n  if (constraints.__type) {\n    if (constraints.__type === 'Pointer') {\n      return equalObjectsGeneric(object[key], constraints, function (obj, ptr) {\n        return typeof obj !== 'undefined' && ptr.className === obj.className && ptr.objectId === obj.objectId;\n      });\n    }\n\n    return equalObjectsGeneric(object[key], Parse._decode(key, constraints), equalObjects);\n  }\n  // More complex cases\n  for (var condition in constraints) {\n    compareTo = constraints[condition];\n    if (compareTo.__type) {\n      compareTo = Parse._decode(key, compareTo);\n    }\n    switch (condition) {\n      case '$lt':\n        if (object[key] >= compareTo) {\n          return false;\n        }\n        break;\n      case '$lte':\n        if (object[key] > compareTo) {\n          return false;\n        }\n        break;\n      case '$gt':\n        if (object[key] <= compareTo) {\n          return false;\n        }\n        break;\n      case '$gte':\n        if (object[key] < compareTo) {\n          return false;\n        }\n        break;\n      case '$ne':\n        if (equalObjects(object[key], compareTo)) {\n          return false;\n        }\n        break;\n      case '$in':\n        if (compareTo.indexOf(object[key]) < 0) {\n          return false;\n        }\n        break;\n      case '$nin':\n        if (compareTo.indexOf(object[key]) > -1) {\n          return false;\n        }\n        break;\n      case '$all':\n        for (i = 0; i < compareTo.length; i++) {\n          if (object[key].indexOf(compareTo[i]) < 0) {\n            return false;\n          }\n        }\n        break;\n      case '$exists':\n        {\n          var propertyExists = typeof object[key] !== 'undefined';\n          var existenceIsRequired = constraints['$exists'];\n          if (typeof constraints['$exists'] !== 'boolean') {\n            // The SDK will never submit a non-boolean for $exists, but if someone\n            // tries to submit a non-boolean for $exits outside the SDKs, just ignore it.\n            break;\n          }\n          if (!propertyExists && existenceIsRequired || propertyExists && !existenceIsRequired) {\n            return false;\n          }\n          break;\n        }\n      case '$regex':\n        if ((typeof compareTo === 'undefined' ? 'undefined' : _typeof(compareTo)) === 'object') {\n          return compareTo.test(object[key]);\n        }\n        // JS doesn't support perl-style escaping\n        var expString = '';\n        var escapeEnd = -2;\n        var escapeStart = compareTo.indexOf('\\\\Q');\n        while (escapeStart > -1) {\n          // Add the unescaped portion\n          expString += compareTo.substring(escapeEnd + 2, escapeStart);\n          escapeEnd = compareTo.indexOf('\\\\E', escapeStart);\n          if (escapeEnd > -1) {\n            expString += compareTo.substring(escapeStart + 2, escapeEnd).replace(/\\\\\\\\\\\\\\\\E/g, '\\\\E').replace(/\\W/g, '\\\\$&');\n          }\n\n          escapeStart = compareTo.indexOf('\\\\Q', escapeEnd);\n        }\n        expString += compareTo.substring(Math.max(escapeStart, escapeEnd + 2));\n        var exp = new RegExp(expString, constraints.$options || '');\n        if (!exp.test(object[key])) {\n          return false;\n        }\n        break;\n      case '$nearSphere':\n        var distance = compareTo.radiansTo(object[key]);\n        var max = constraints.$maxDistance || Infinity;\n        return distance <= max;\n      case '$within':\n        var southWest = compareTo.$box[0];\n        var northEast = compareTo.$box[1];\n        if (southWest.latitude > northEast.latitude || southWest.longitude > northEast.longitude) {\n          // Invalid box, crosses the date line\n          return false;\n        }\n        return object[key].latitude > southWest.latitude && object[key].latitude < northEast.latitude && object[key].longitude > southWest.longitude && object[key].longitude < northEast.longitude;\n      case '$options':\n        // Not a query type, but a way to add options to $regex. Ignore and\n        // avoid the default\n        break;\n      case '$maxDistance':\n        // Not a query type, but a way to add a cap to $nearSphere. Ignore and\n        // avoid the default\n        break;\n      case '$select':\n        return false;\n      case '$dontSelect':\n        return false;\n      default:\n        return false;\n    }\n  }\n  return true;\n}\n\nvar QueryTools = {\n  queryHash: queryHash,\n  matchesQuery: matchesQuery\n};\n\nmodule.exports = QueryTools;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/LiveQuery/equalObjects.js":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determines whether two objects represent the same primitive, special Parse\n * type, or full Parse Object.\n */\nfunction equalObjects(a, b) {\n  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) !== (typeof b === 'undefined' ? 'undefined' : _typeof(b))) {\n    return false;\n  }\n  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) !== 'object') {\n    return a === b;\n  }\n  if (a === b) {\n    return true;\n  }\n  if (toString.call(a) === '[object Date]') {\n    if (toString.call(b) === '[object Date]') {\n      return +a === +b;\n    }\n    return false;\n  }\n  if (Array.isArray(a)) {\n    if (Array.isArray(b)) {\n      if (a.length !== b.length) {\n        return false;\n      }\n      for (var i = 0; i < a.length; i++) {\n        if (!equalObjects(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (var key in a) {\n    if (!equalObjects(a[key], b[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = equalObjects;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/LiveQuery/Id.js":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Id = function () {\n  function Id(className, objectId) {\n    _classCallCheck(this, Id);\n\n    this.className = className;\n    this.objectId = objectId;\n  }\n\n  _createClass(Id, [{\n    key: 'toString',\n    value: function toString() {\n      return this.className + ':' + this.objectId;\n    }\n  }], [{\n    key: 'fromString',\n    value: function fromString(str) {\n      var split = str.split(':');\n      if (split.length !== 2) {\n        throw new TypeError('Cannot create Id object from this string');\n      }\n      return new Id(split[0], split[1]);\n    }\n  }]);\n\n  return Id;\n}();\n\nmodule.exports = Id;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/LiveQuery/SessionTokenCache.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SessionTokenCache = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _node = require('parse/node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _lruCache = require('lru-cache');\n\nvar _lruCache2 = _interopRequireDefault(_lruCache);\n\nvar _logger = require('../logger');\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction userForSessionToken(sessionToken) {\n  var q = new _node2.default.Query(\"_Session\");\n  q.equalTo(\"sessionToken\", sessionToken);\n  return q.first({ useMasterKey: true }).then(function (session) {\n    if (!session) {\n      return _node2.default.Promise.error(\"No session found for session token\");\n    }\n    return session.get(\"user\");\n  });\n}\n\nvar SessionTokenCache = function () {\n  function SessionTokenCache() {\n    var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30 * 24 * 60 * 60 * 1000;\n    var maxSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;\n\n    _classCallCheck(this, SessionTokenCache);\n\n    this.cache = new _lruCache2.default({\n      max: maxSize,\n      maxAge: timeout\n    });\n  }\n\n  _createClass(SessionTokenCache, [{\n    key: 'getUserId',\n    value: function getUserId(sessionToken) {\n      var _this = this;\n\n      if (!sessionToken) {\n        return _node2.default.Promise.error('Empty sessionToken');\n      }\n      var userId = this.cache.get(sessionToken);\n      if (userId) {\n        _logger2.default.verbose('Fetch userId %s of sessionToken %s from Cache', userId, sessionToken);\n        return _node2.default.Promise.as(userId);\n      }\n      return userForSessionToken(sessionToken).then(function (user) {\n        _logger2.default.verbose('Fetch userId %s of sessionToken %s from Parse', user.id, sessionToken);\n        var userId = user.id;\n        _this.cache.set(sessionToken, userId);\n        return _node2.default.Promise.as(userId);\n      }, function (error) {\n        _logger2.default.error('Can not fetch userId for sessionToken %j, error %j', sessionToken, error);\n        return _node2.default.Promise.error(error);\n      });\n    }\n  }]);\n\n  return SessionTokenCache;\n}();\n\nexports.SessionTokenCache = SessionTokenCache;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Routers/PublicAPIRouter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PublicAPIRouter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _PromiseRouter2 = require('../PromiseRouter');\n\nvar _PromiseRouter3 = _interopRequireDefault(_PromiseRouter2);\n\nvar _Config = require('../Config');\n\nvar _Config2 = _interopRequireDefault(_Config);\n\nvar _express = require('express');\n\nvar _express2 = _interopRequireDefault(_express);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _querystring = require('querystring');\n\nvar _querystring2 = _interopRequireDefault(_querystring);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar public_html = _path2.default.resolve(__dirname, \"../../public_html\");\nvar views = _path2.default.resolve(__dirname, '../../views');\n\nvar PublicAPIRouter = exports.PublicAPIRouter = function (_PromiseRouter) {\n  _inherits(PublicAPIRouter, _PromiseRouter);\n\n  function PublicAPIRouter() {\n    _classCallCheck(this, PublicAPIRouter);\n\n    return _possibleConstructorReturn(this, (PublicAPIRouter.__proto__ || Object.getPrototypeOf(PublicAPIRouter)).apply(this, arguments));\n  }\n\n  _createClass(PublicAPIRouter, [{\n    key: 'verifyEmail',\n    value: function verifyEmail(req) {\n      var _this2 = this;\n\n      var _req$query = req.query,\n          token = _req$query.token,\n          username = _req$query.username;\n\n      var appId = req.params.appId;\n      var config = new _Config2.default(appId);\n\n      if (!config.publicServerURL) {\n        return this.missingPublicServerURL();\n      }\n\n      if (!token || !username) {\n        return this.invalidLink(req);\n      }\n\n      var userController = config.userController;\n      return userController.verifyEmail(username, token).then(function () {\n        var params = _querystring2.default.stringify({ username: username });\n        return Promise.resolve({\n          status: 302,\n          location: config.verifyEmailSuccessURL + '?' + params\n        });\n      }, function () {\n        return _this2.invalidLink(req);\n      });\n    }\n  }, {\n    key: 'changePassword',\n    value: function changePassword(req) {\n      return new Promise(function (resolve, reject) {\n        var config = new _Config2.default(req.query.id);\n        if (!config.publicServerURL) {\n          return resolve({\n            status: 404,\n            text: 'Not found.'\n          });\n        }\n        // Should we keep the file in memory or leave like that?\n        _fs2.default.readFile(_path2.default.resolve(views, \"choose_password\"), 'utf-8', function (err, data) {\n          if (err) {\n            return reject(err);\n          }\n          data = data.replace(\"PARSE_SERVER_URL\", '\\'' + config.publicServerURL + '\\'');\n          resolve({\n            text: data\n          });\n        });\n      });\n    }\n  }, {\n    key: 'requestResetPassword',\n    value: function requestResetPassword(req) {\n      var _this3 = this;\n\n      var config = req.config;\n\n      if (!config.publicServerURL) {\n        return this.missingPublicServerURL();\n      }\n\n      var _req$query2 = req.query,\n          username = _req$query2.username,\n          token = _req$query2.token;\n\n\n      if (!username || !token) {\n        return this.invalidLink(req);\n      }\n\n      return config.userController.checkResetTokenValidity(username, token).then(function () {\n        var params = _querystring2.default.stringify({ token: token, id: config.applicationId, username: username, app: config.appName });\n        return Promise.resolve({\n          status: 302,\n          location: config.choosePasswordURL + '?' + params\n        });\n      }, function () {\n        return _this3.invalidLink(req);\n      });\n    }\n  }, {\n    key: 'resetPassword',\n    value: function resetPassword(req) {\n\n      var config = req.config;\n\n      if (!config.publicServerURL) {\n        return this.missingPublicServerURL();\n      }\n\n      var _req$body = req.body,\n          username = _req$body.username,\n          token = _req$body.token,\n          new_password = _req$body.new_password;\n\n\n      if (!username || !token || !new_password) {\n        return this.invalidLink(req);\n      }\n\n      return config.userController.updatePassword(username, token, new_password).then(function () {\n        var params = _querystring2.default.stringify({ username: username });\n        return Promise.resolve({\n          status: 302,\n          location: config.passwordResetSuccessURL + '?' + params\n        });\n      }, function (err) {\n        var params = _querystring2.default.stringify({ username: username, token: token, id: config.applicationId, error: err, app: config.appName });\n        return Promise.resolve({\n          status: 302,\n          location: config.choosePasswordURL + '?' + params\n        });\n      });\n    }\n  }, {\n    key: 'invalidLink',\n    value: function invalidLink(req) {\n      return Promise.resolve({\n        status: 302,\n        location: req.config.invalidLinkURL\n      });\n    }\n  }, {\n    key: 'missingPublicServerURL',\n    value: function missingPublicServerURL() {\n      return Promise.resolve({\n        text: 'Not found.',\n        status: 404\n      });\n    }\n  }, {\n    key: 'setConfig',\n    value: function setConfig(req) {\n      req.config = new _Config2.default(req.params.appId);\n      return Promise.resolve();\n    }\n  }, {\n    key: 'mountRoutes',\n    value: function mountRoutes() {\n      var _this4 = this;\n\n      this.route('GET', '/apps/:appId/verify_email', function (req) {\n        _this4.setConfig(req);\n      }, function (req) {\n        return _this4.verifyEmail(req);\n      });\n\n      this.route('GET', '/apps/choose_password', function (req) {\n        return _this4.changePassword(req);\n      });\n\n      this.route('POST', '/apps/:appId/request_password_reset', function (req) {\n        _this4.setConfig(req);\n      }, function (req) {\n        return _this4.resetPassword(req);\n      });\n\n      this.route('GET', '/apps/:appId/request_password_reset', function (req) {\n        _this4.setConfig(req);\n      }, function (req) {\n        return _this4.requestResetPassword(req);\n      });\n    }\n  }, {\n    key: 'expressRouter',\n    value: function expressRouter() {\n      var router = _express2.default.Router();\n      router.use(\"/apps\", _express2.default.static(public_html));\n      router.use(\"/\", _get(PublicAPIRouter.prototype.__proto__ || Object.getPrototypeOf(PublicAPIRouter.prototype), 'expressRouter', this).call(this));\n      return router;\n    }\n  }]);\n\n  return PublicAPIRouter;\n}(_PromiseRouter3.default);\n\nexports.default = PublicAPIRouter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Controllers/PushController.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PushController = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _node = require('parse/node');\n\nvar _deepcopy = require('deepcopy');\n\nvar _deepcopy2 = _interopRequireDefault(_deepcopy);\n\nvar _RestQuery = require('../RestQuery');\n\nvar _RestQuery2 = _interopRequireDefault(_RestQuery);\n\nvar _RestWrite = require('../RestWrite');\n\nvar _RestWrite2 = _interopRequireDefault(_RestWrite);\n\nvar _Auth = require('../Auth');\n\nvar _StatusHandler = require('../StatusHandler');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PushController = exports.PushController = function () {\n  function PushController() {\n    _classCallCheck(this, PushController);\n  }\n\n  _createClass(PushController, [{\n    key: 'sendPush',\n    value: function sendPush() {\n      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var where = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var config = arguments[2];\n      var auth = arguments[3];\n      var onPushStatusSaved = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {};\n\n      if (!config.hasPushSupport) {\n        throw new _node.Parse.Error(_node.Parse.Error.PUSH_MISCONFIGURED, 'Missing push configuration');\n      }\n      // Replace the expiration_time with a valid Unix epoch milliseconds time\n      body['expiration_time'] = PushController.getExpirationTime(body);\n      // TODO: If the req can pass the checking, we return immediately instead of waiting\n      // pushes to be sent. We probably change this behaviour in the future.\n      var badgeUpdate = function badgeUpdate() {\n        return Promise.resolve();\n      };\n      if (body.data && body.data.badge) {\n        var badge = body.data.badge;\n        var restUpdate = {};\n        if (typeof badge == 'string' && badge.toLowerCase() === 'increment') {\n          restUpdate = { badge: { __op: 'Increment', amount: 1 } };\n        } else if (Number(badge)) {\n          restUpdate = { badge: badge };\n        } else {\n          throw \"Invalid value for badge, expected number or 'Increment'\";\n        }\n        var updateWhere = (0, _deepcopy2.default)(where);\n\n        badgeUpdate = function badgeUpdate() {\n          updateWhere.deviceType = 'ios';\n          // Build a real RestQuery so we can use it in RestWrite\n          var restQuery = new _RestQuery2.default(config, (0, _Auth.master)(config), '_Installation', updateWhere);\n          return restQuery.buildRestWhere().then(function () {\n            var write = new _RestWrite2.default(config, (0, _Auth.master)(config), '_Installation', restQuery.restWhere, restUpdate);\n            write.runOptions.many = true;\n            return write.execute();\n          });\n        };\n      }\n      var pushStatus = (0, _StatusHandler.pushStatusHandler)(config);\n      return Promise.resolve().then(function () {\n        return pushStatus.setInitial(body, where);\n      }).then(function () {\n        onPushStatusSaved(pushStatus.objectId);\n        return badgeUpdate();\n      }).then(function () {\n        return config.pushControllerQueue.enqueue(body, where, config, auth, pushStatus);\n      }).catch(function (err) {\n        return pushStatus.fail(err).then(function () {\n          throw err;\n        });\n      });\n    }\n\n    /**\n     * Get expiration time from the request body.\n     * @param {Object} request A request object\n     * @returns {Number|undefined} The expiration time if it exists in the request\n     */\n\n  }], [{\n    key: 'getExpirationTime',\n    value: function getExpirationTime() {\n      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var hasExpirationTime = !!body['expiration_time'];\n      if (!hasExpirationTime) {\n        return;\n      }\n      var expirationTimeParam = body['expiration_time'];\n      var expirationTime;\n      if (typeof expirationTimeParam === 'number') {\n        expirationTime = new Date(expirationTimeParam * 1000);\n      } else if (typeof expirationTimeParam === 'string') {\n        expirationTime = new Date(expirationTimeParam);\n      } else {\n        throw new _node.Parse.Error(_node.Parse.Error.PUSH_MISCONFIGURED, body['expiration_time'] + ' is not valid time.');\n      }\n      // Check expirationTime is valid or not, if it is not valid, expirationTime is NaN\n      if (!isFinite(expirationTime)) {\n        throw new _node.Parse.Error(_node.Parse.Error.PUSH_MISCONFIGURED, body['expiration_time'] + ' is not valid time.');\n      }\n      return expirationTime.valueOf();\n    }\n  }]);\n\n  return PushController;\n}();\n\nexports.default = PushController;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Push/PushQueue.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PushQueue = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _ParseMessageQueue = require('../ParseMessageQueue');\n\nvar _rest = require('../rest');\n\nvar _rest2 = _interopRequireDefault(_rest);\n\nvar _utils = require('./utils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PUSH_CHANNEL = 'parse-server-push';\nvar DEFAULT_BATCH_SIZE = 100;\n\nvar PushQueue = exports.PushQueue = function () {\n\n  // config object of the publisher, right now it only contains the redisURL,\n  // but we may extend it later.\n  function PushQueue() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, PushQueue);\n\n    this.channel = config.channel || PUSH_CHANNEL;\n    this.batchSize = config.batchSize || DEFAULT_BATCH_SIZE;\n    this.parsePublisher = _ParseMessageQueue.ParseMessageQueue.createPublisher(config);\n  }\n\n  _createClass(PushQueue, [{\n    key: 'enqueue',\n    value: function enqueue(body, where, config, auth, pushStatus) {\n      var _this = this;\n\n      var limit = this.batchSize;\n      // Order by badge (because the payload is badge dependant)\n      // and createdAt to fix the order\n      var order = (0, _utils.isPushIncrementing)(body) ? 'badge,createdAt' : 'createdAt';\n\n      return Promise.resolve().then(function () {\n        return _rest2.default.find(config, auth, '_Installation', where, { limit: 0, count: true });\n      }).then(function (_ref) {\n        var results = _ref.results,\n            count = _ref.count;\n\n        if (!results) {\n          return Promise.reject({ error: 'PushController: no results in query' });\n        }\n        pushStatus.setRunning(count);\n        var skip = 0;\n        while (skip < count) {\n          var query = { where: where,\n            limit: limit,\n            skip: skip,\n            order: order };\n\n          var pushWorkItem = {\n            body: body,\n            query: query,\n            pushStatus: { objectId: pushStatus.objectId },\n            applicationId: config.applicationId\n          };\n          _this.parsePublisher.publish(_this.channel, JSON.stringify(pushWorkItem));\n          skip += limit;\n        }\n      });\n    }\n  }], [{\n    key: 'defaultPushChannel',\n    value: function defaultPushChannel() {\n      return PUSH_CHANNEL;\n    }\n  }]);\n\n  return PushQueue;\n}();","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/ParseMessageQueue.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParseMessageQueue = undefined;\n\nvar _AdapterLoader = require('./Adapters/AdapterLoader');\n\nvar _EventEmitterMQ = require('./Adapters/MessageQueue/EventEmitterMQ');\n\nvar ParseMessageQueue = {};\n\nParseMessageQueue.createPublisher = function (config) {\n  var adapter = (0, _AdapterLoader.loadAdapter)(config.messageQueueAdapter, _EventEmitterMQ.EventEmitterMQ, config);\n  if (typeof adapter.createPublisher !== 'function') {\n    throw 'pubSubAdapter should have createPublisher()';\n  }\n  return adapter.createPublisher(config);\n};\n\nParseMessageQueue.createSubscriber = function (config) {\n  var adapter = (0, _AdapterLoader.loadAdapter)(config.messageQueueAdapter, _EventEmitterMQ.EventEmitterMQ, config);\n  if (typeof adapter.createSubscriber !== 'function') {\n    throw 'messageQueueAdapter should have createSubscriber()';\n  }\n  return adapter.createSubscriber(config);\n};\n\nexports.ParseMessageQueue = ParseMessageQueue;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/MessageQueue/EventEmitterMQ.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EventEmitterMQ = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = require('events');\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar emitter = new _events2.default.EventEmitter();\nvar subscriptions = new Map();\n\nfunction _unsubscribe(channel) {\n  if (!subscriptions.has(channel)) {\n    //console.log('No channel to unsub from');\n    return;\n  }\n  //console.log('unsub ', channel);\n  emitter.removeListener(channel, subscriptions.get(channel));\n  subscriptions.delete(channel);\n}\n\nvar Publisher = function () {\n  function Publisher(emitter) {\n    _classCallCheck(this, Publisher);\n\n    this.emitter = emitter;\n  }\n\n  _createClass(Publisher, [{\n    key: 'publish',\n    value: function publish(channel, message) {\n      this.emitter.emit(channel, message);\n    }\n  }]);\n\n  return Publisher;\n}();\n\nvar Consumer = function (_events$EventEmitter) {\n  _inherits(Consumer, _events$EventEmitter);\n\n  function Consumer(emitter) {\n    _classCallCheck(this, Consumer);\n\n    var _this = _possibleConstructorReturn(this, (Consumer.__proto__ || Object.getPrototypeOf(Consumer)).call(this));\n\n    _this.emitter = emitter;\n    return _this;\n  }\n\n  _createClass(Consumer, [{\n    key: 'subscribe',\n    value: function subscribe(channel) {\n      var _this2 = this;\n\n      _unsubscribe(channel);\n      var handler = function handler(message) {\n        _this2.emit('message', channel, message);\n      };\n      subscriptions.set(channel, handler);\n      this.emitter.on(channel, handler);\n    }\n  }, {\n    key: 'unsubscribe',\n    value: function unsubscribe(channel) {\n      _unsubscribe(channel);\n    }\n  }]);\n\n  return Consumer;\n}(_events2.default.EventEmitter);\n\nfunction createPublisher() {\n  return new Publisher(emitter);\n}\n\nfunction createSubscriber() {\n  return new Consumer(emitter);\n}\n\nvar EventEmitterMQ = {\n  createPublisher: createPublisher,\n  createSubscriber: createSubscriber\n};\n\nexports.EventEmitterMQ = EventEmitterMQ;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Push/utils.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isPushIncrementing = isPushIncrementing;\nexports.validatePushType = validatePushType;\n\nvar _node = require('parse/node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isPushIncrementing(body) {\n  return body.data && body.data.badge && typeof body.data.badge == 'string' && body.data.badge.toLowerCase() == \"increment\";\n}\n\n/**\n * Check whether the deviceType parameter in qury condition is valid or not.\n * @param {Object} where A query condition\n * @param {Array} validPushTypes An array of valid push types(string)\n */\nfunction validatePushType() {\n  var where = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var validPushTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  var deviceTypeField = where.deviceType || {};\n  var deviceTypes = [];\n  if (typeof deviceTypeField === 'string') {\n    deviceTypes.push(deviceTypeField);\n  } else if (Array.isArray(deviceTypeField['$in'])) {\n    deviceTypes.concat(deviceTypeField['$in']);\n  }\n  for (var i = 0; i < deviceTypes.length; i++) {\n    var deviceType = deviceTypes[i];\n    if (validPushTypes.indexOf(deviceType) < 0) {\n      throw new _node2.default.Error(_node2.default.Error.PUSH_MISCONFIGURED, deviceType + ' is not supported push type.');\n    }\n  }\n}","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Push/PushWorker.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PushWorker = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _deepcopy = require('deepcopy');\n\nvar _deepcopy2 = _interopRequireDefault(_deepcopy);\n\nvar _AdaptableController = require('../Controllers/AdaptableController');\n\nvar _AdaptableController2 = _interopRequireDefault(_AdaptableController);\n\nvar _Auth = require('../Auth');\n\nvar _Config = require('../Config');\n\nvar _Config2 = _interopRequireDefault(_Config);\n\nvar _PushAdapter = require('../Adapters/Push/PushAdapter');\n\nvar _rest = require('../rest');\n\nvar _rest2 = _interopRequireDefault(_rest);\n\nvar _StatusHandler = require('../StatusHandler');\n\nvar _utils = require('./utils');\n\nvar _ParseMessageQueue = require('../ParseMessageQueue');\n\nvar _PushQueue = require('./PushQueue');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar UNSUPPORTED_BADGE_KEY = \"unsupported\";\n\nfunction groupByBadge(installations) {\n  return installations.reduce(function (map, installation) {\n    var badge = installation.badge + '';\n    if (installation.deviceType != \"ios\") {\n      badge = UNSUPPORTED_BADGE_KEY;\n    }\n    map[badge] = map[badge] || [];\n    map[badge].push(installation);\n    return map;\n  }, {});\n}\n\nvar PushWorker = exports.PushWorker = function () {\n  function PushWorker(pushAdapter) {\n    var _this = this;\n\n    var subscriberConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, PushWorker);\n\n    _AdaptableController2.default.validateAdapter(pushAdapter, this, _PushAdapter.PushAdapter);\n    this.adapter = pushAdapter;\n\n    this.channel = subscriberConfig.channel || _PushQueue.PushQueue.defaultPushChannel();\n    this.subscriber = _ParseMessageQueue.ParseMessageQueue.createSubscriber(subscriberConfig);\n    if (this.subscriber) {\n      var subscriber = this.subscriber;\n      subscriber.subscribe(this.channel);\n      subscriber.on('message', function (channel, messageStr) {\n        var workItem = JSON.parse(messageStr);\n        _this.run(workItem);\n      });\n    }\n  }\n\n  _createClass(PushWorker, [{\n    key: 'unsubscribe',\n    value: function unsubscribe() {\n      if (this.subscriber) {\n        this.subscriber.unsubscribe(this.channel);\n      }\n    }\n  }, {\n    key: 'run',\n    value: function run(_ref) {\n      var _this2 = this;\n\n      var body = _ref.body,\n          query = _ref.query,\n          pushStatus = _ref.pushStatus,\n          applicationId = _ref.applicationId;\n\n      var config = new _Config2.default(applicationId);\n      var auth = (0, _Auth.master)(config);\n      var where = query.where;\n      delete query.where;\n      return _rest2.default.find(config, auth, '_Installation', where, query).then(function (_ref2) {\n        var results = _ref2.results;\n\n        if (results.length == 0) {\n          return;\n        }\n        return _this2.sendToAdapter(body, results, pushStatus, config);\n      }, function (err) {\n        throw err;\n      });\n    }\n  }, {\n    key: 'sendToAdapter',\n    value: function sendToAdapter(body, installations, pushStatus, config) {\n      var _this3 = this;\n\n      pushStatus = (0, _StatusHandler.pushStatusHandler)(config, pushStatus.objectId);\n      if (!(0, _utils.isPushIncrementing)(body)) {\n        return this.adapter.send(body, installations, pushStatus.objectId).then(function (results) {\n          return pushStatus.trackSent(results);\n        });\n      }\n\n      // Collect the badges to reduce the # of calls\n      var badgeInstallationsMap = groupByBadge(installations);\n\n      // Map the on the badges count and return the send result\n      var promises = Object.keys(badgeInstallationsMap).map(function (badge) {\n        var payload = (0, _deepcopy2.default)(body);\n        if (badge == UNSUPPORTED_BADGE_KEY) {\n          delete payload.data.badge;\n        } else {\n          payload.data.badge = parseInt(badge);\n        }\n        var installations = badgeInstallationsMap[badge];\n        return _this3.sendToAdapter(payload, installations, pushStatus, config);\n      });\n      return Promise.all(promises);\n    }\n  }]);\n\n  return PushWorker;\n}();\n\nexports.default = PushWorker;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Push/PushAdapter.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*eslint no-unused-vars: \"off\"*/\n// Push Adapter\n//\n// Allows you to change the push notification mechanism.\n//\n// Adapter classes must implement the following functions:\n// * getValidPushTypes()\n// * send(devices, installations, pushStatus)\n//\n// Default is ParsePushAdapter, which uses GCM for\n// android push and APNS for ios push.\n\nvar PushAdapter = exports.PushAdapter = function () {\n  function PushAdapter() {\n    _classCallCheck(this, PushAdapter);\n  }\n\n  _createClass(PushAdapter, [{\n    key: \"send\",\n    value: function send(body, installations, pushStatus) {}\n\n    /**\n     * Get an array of valid push types.\n     * @returns {Array} An array of valid push types\n     */\n\n  }, {\n    key: \"getValidPushTypes\",\n    value: function getValidPushTypes() {\n      return [];\n    }\n  }]);\n\n  return PushAdapter;\n}();\n\nexports.default = PushAdapter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Routers/PushRouter.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PushRouter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _PromiseRouter2 = require(\"../PromiseRouter\");\n\nvar _PromiseRouter3 = _interopRequireDefault(_PromiseRouter2);\n\nvar _middlewares = require(\"../middlewares\");\n\nvar middleware = _interopRequireWildcard(_middlewares);\n\nvar _node = require(\"parse/node\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar PushRouter = exports.PushRouter = function (_PromiseRouter) {\n  _inherits(PushRouter, _PromiseRouter);\n\n  function PushRouter() {\n    _classCallCheck(this, PushRouter);\n\n    return _possibleConstructorReturn(this, (PushRouter.__proto__ || Object.getPrototypeOf(PushRouter)).apply(this, arguments));\n  }\n\n  _createClass(PushRouter, [{\n    key: \"mountRoutes\",\n    value: function mountRoutes() {\n      this.route(\"POST\", \"/push\", middleware.promiseEnforceMasterKeyAccess, PushRouter.handlePOST);\n    }\n  }], [{\n    key: \"handlePOST\",\n    value: function handlePOST(req) {\n      var pushController = req.config.pushController;\n      if (!pushController) {\n        throw new _node.Parse.Error(_node.Parse.Error.PUSH_MISCONFIGURED, 'Push controller is not set');\n      }\n\n      var where = PushRouter.getQueryCondition(req);\n      var resolve = void 0;\n      var promise = new Promise(function (_resolve) {\n        resolve = _resolve;\n      });\n      pushController.sendPush(req.body, where, req.config, req.auth, function (pushStatusId) {\n        resolve({\n          headers: {\n            'X-Parse-Push-Status-Id': pushStatusId\n          },\n          response: {\n            result: true\n          }\n        });\n      });\n      return promise;\n    }\n\n    /**\n     * Get query condition from the request body.\n     * @param {Object} req A request object\n     * @returns {Object} The query condition, the where field in a query api call\n     */\n\n  }, {\n    key: \"getQueryCondition\",\n    value: function getQueryCondition(req) {\n      var body = req.body || {};\n      var hasWhere = typeof body.where !== 'undefined';\n      var hasChannels = typeof body.channels !== 'undefined';\n\n      var where = void 0;\n      if (hasWhere && hasChannels) {\n        throw new _node.Parse.Error(_node.Parse.Error.PUSH_MISCONFIGURED, 'Channels and query can not be set at the same time.');\n      } else if (hasWhere) {\n        where = body.where;\n      } else if (hasChannels) {\n        where = {\n          \"channels\": {\n            \"$in\": body.channels\n          }\n        };\n      } else {\n        throw new _node.Parse.Error(_node.Parse.Error.PUSH_MISCONFIGURED, 'Sending a push requires either \"channels\" or a \"where\" query.');\n      }\n      return where;\n    }\n  }]);\n\n  return PushRouter;\n}(_PromiseRouter3.default);\n\nexports.default = PushRouter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Routers/CloudCodeRouter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CloudCodeRouter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _PromiseRouter2 = require('../PromiseRouter');\n\nvar _PromiseRouter3 = _interopRequireDefault(_PromiseRouter2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar triggers = require('../triggers');\n\nvar CloudCodeRouter = exports.CloudCodeRouter = function (_PromiseRouter) {\n  _inherits(CloudCodeRouter, _PromiseRouter);\n\n  function CloudCodeRouter() {\n    _classCallCheck(this, CloudCodeRouter);\n\n    return _possibleConstructorReturn(this, (CloudCodeRouter.__proto__ || Object.getPrototypeOf(CloudCodeRouter)).apply(this, arguments));\n  }\n\n  _createClass(CloudCodeRouter, [{\n    key: 'mountRoutes',\n    value: function mountRoutes() {\n      this.route('GET', '/cloud_code/jobs', CloudCodeRouter.getJobs);\n    }\n  }], [{\n    key: 'getJobs',\n    value: function getJobs(req) {\n      var config = req.config;\n      var jobs = triggers.getJobs(config.applicationId) || {};\n      return Promise.resolve({\n        response: Object.keys(jobs).map(function (jobName) {\n          return {\n            jobName: jobName\n          };\n        })\n      });\n    }\n  }]);\n\n  return CloudCodeRouter;\n}(_PromiseRouter3.default);","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Routers/RolesRouter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RolesRouter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _ClassesRouter2 = require('./ClassesRouter');\n\nvar _ClassesRouter3 = _interopRequireDefault(_ClassesRouter2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar RolesRouter = exports.RolesRouter = function (_ClassesRouter) {\n  _inherits(RolesRouter, _ClassesRouter);\n\n  function RolesRouter() {\n    _classCallCheck(this, RolesRouter);\n\n    return _possibleConstructorReturn(this, (RolesRouter.__proto__ || Object.getPrototypeOf(RolesRouter)).apply(this, arguments));\n  }\n\n  _createClass(RolesRouter, [{\n    key: 'handleFind',\n    value: function handleFind(req) {\n      req.params.className = '_Role';\n      return _get(RolesRouter.prototype.__proto__ || Object.getPrototypeOf(RolesRouter.prototype), 'handleFind', this).call(this, req);\n    }\n  }, {\n    key: 'handleGet',\n    value: function handleGet(req) {\n      req.params.className = '_Role';\n      return _get(RolesRouter.prototype.__proto__ || Object.getPrototypeOf(RolesRouter.prototype), 'handleGet', this).call(this, req);\n    }\n  }, {\n    key: 'handleCreate',\n    value: function handleCreate(req) {\n      req.params.className = '_Role';\n      return _get(RolesRouter.prototype.__proto__ || Object.getPrototypeOf(RolesRouter.prototype), 'handleCreate', this).call(this, req);\n    }\n  }, {\n    key: 'handleUpdate',\n    value: function handleUpdate(req) {\n      req.params.className = '_Role';\n      return _get(RolesRouter.prototype.__proto__ || Object.getPrototypeOf(RolesRouter.prototype), 'handleUpdate', this).call(this, req);\n    }\n  }, {\n    key: 'handleDelete',\n    value: function handleDelete(req) {\n      req.params.className = '_Role';\n      return _get(RolesRouter.prototype.__proto__ || Object.getPrototypeOf(RolesRouter.prototype), 'handleDelete', this).call(this, req);\n    }\n  }, {\n    key: 'mountRoutes',\n    value: function mountRoutes() {\n      var _this2 = this;\n\n      this.route('GET', '/roles', function (req) {\n        return _this2.handleFind(req);\n      });\n      this.route('GET', '/roles/:objectId', function (req) {\n        return _this2.handleGet(req);\n      });\n      this.route('POST', '/roles', function (req) {\n        return _this2.handleCreate(req);\n      });\n      this.route('PUT', '/roles/:objectId', function (req) {\n        return _this2.handleUpdate(req);\n      });\n      this.route('DELETE', '/roles/:objectId', function (req) {\n        return _this2.handleDelete(req);\n      });\n    }\n  }]);\n\n  return RolesRouter;\n}(_ClassesRouter3.default);\n\nexports.default = RolesRouter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Routers/SchemasRouter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SchemasRouter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _PromiseRouter2 = require('../PromiseRouter');\n\nvar _PromiseRouter3 = _interopRequireDefault(_PromiseRouter2);\n\nvar _middlewares = require('../middlewares');\n\nvar middleware = _interopRequireWildcard(_middlewares);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// schemas.js\n\nvar Parse = require('parse/node').Parse,\n    SchemaController = require('../Controllers/SchemaController');\n\nfunction classNameMismatchResponse(bodyClass, pathClass) {\n  throw new Parse.Error(Parse.Error.INVALID_CLASS_NAME, 'Class name mismatch between ' + bodyClass + ' and ' + pathClass + '.');\n}\n\nfunction getAllSchemas(req) {\n  return req.config.database.loadSchema({ clearCache: true }).then(function (schemaController) {\n    return schemaController.getAllClasses(true);\n  }).then(function (schemas) {\n    return { response: { results: schemas } };\n  });\n}\n\nfunction getOneSchema(req) {\n  var className = req.params.className;\n  return req.config.database.loadSchema({ clearCache: true }).then(function (schemaController) {\n    return schemaController.getOneSchema(className, true);\n  }).then(function (schema) {\n    return { response: schema };\n  }).catch(function (error) {\n    if (error === undefined) {\n      throw new Parse.Error(Parse.Error.INVALID_CLASS_NAME, 'Class ' + className + ' does not exist.');\n    } else {\n      throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, 'Database adapter error.');\n    }\n  });\n}\n\nfunction createSchema(req) {\n  if (req.params.className && req.body.className) {\n    if (req.params.className != req.body.className) {\n      return classNameMismatchResponse(req.body.className, req.params.className);\n    }\n  }\n\n  var className = req.params.className || req.body.className;\n  if (!className) {\n    throw new Parse.Error(135, 'POST ' + req.path + ' needs a class name.');\n  }\n\n  return req.config.database.loadSchema({ clearCache: true }).then(function (schema) {\n    return schema.addClassIfNotExists(className, req.body.fields, req.body.classLevelPermissions);\n  }).then(function (schema) {\n    return { response: schema };\n  });\n}\n\nfunction modifySchema(req) {\n  if (req.body.className && req.body.className != req.params.className) {\n    return classNameMismatchResponse(req.body.className, req.params.className);\n  }\n\n  var submittedFields = req.body.fields || {};\n  var className = req.params.className;\n\n  return req.config.database.loadSchema({ clearCache: true }).then(function (schema) {\n    return schema.updateClass(className, submittedFields, req.body.classLevelPermissions, req.config.database);\n  }).then(function (result) {\n    return { response: result };\n  });\n}\n\nvar deleteSchema = function deleteSchema(req) {\n  if (!SchemaController.classNameIsValid(req.params.className)) {\n    throw new Parse.Error(Parse.Error.INVALID_CLASS_NAME, SchemaController.invalidClassNameMessage(req.params.className));\n  }\n  return req.config.database.deleteSchema(req.params.className).then(function () {\n    return { response: {} };\n  });\n};\n\nvar SchemasRouter = exports.SchemasRouter = function (_PromiseRouter) {\n  _inherits(SchemasRouter, _PromiseRouter);\n\n  function SchemasRouter() {\n    _classCallCheck(this, SchemasRouter);\n\n    return _possibleConstructorReturn(this, (SchemasRouter.__proto__ || Object.getPrototypeOf(SchemasRouter)).apply(this, arguments));\n  }\n\n  _createClass(SchemasRouter, [{\n    key: 'mountRoutes',\n    value: function mountRoutes() {\n      this.route('GET', '/schemas', middleware.promiseEnforceMasterKeyAccess, getAllSchemas);\n      this.route('GET', '/schemas/:className', middleware.promiseEnforceMasterKeyAccess, getOneSchema);\n      this.route('POST', '/schemas', middleware.promiseEnforceMasterKeyAccess, createSchema);\n      this.route('POST', '/schemas/:className', middleware.promiseEnforceMasterKeyAccess, createSchema);\n      this.route('PUT', '/schemas/:className', middleware.promiseEnforceMasterKeyAccess, modifySchema);\n      this.route('DELETE', '/schemas/:className', middleware.promiseEnforceMasterKeyAccess, deleteSchema);\n    }\n  }]);\n\n  return SchemasRouter;\n}(_PromiseRouter3.default);","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Routers/SessionsRouter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SessionsRouter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _ClassesRouter2 = require('./ClassesRouter');\n\nvar _ClassesRouter3 = _interopRequireDefault(_ClassesRouter2);\n\nvar _node = require('parse/node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _rest = require('../rest');\n\nvar _rest2 = _interopRequireDefault(_rest);\n\nvar _Auth = require('../Auth');\n\nvar _Auth2 = _interopRequireDefault(_Auth);\n\nvar _RestWrite = require('../RestWrite');\n\nvar _RestWrite2 = _interopRequireDefault(_RestWrite);\n\nvar _cryptoUtils = require('../cryptoUtils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar SessionsRouter = exports.SessionsRouter = function (_ClassesRouter) {\n  _inherits(SessionsRouter, _ClassesRouter);\n\n  function SessionsRouter() {\n    _classCallCheck(this, SessionsRouter);\n\n    return _possibleConstructorReturn(this, (SessionsRouter.__proto__ || Object.getPrototypeOf(SessionsRouter)).apply(this, arguments));\n  }\n\n  _createClass(SessionsRouter, [{\n    key: 'handleFind',\n    value: function handleFind(req) {\n      req.params.className = '_Session';\n      return _get(SessionsRouter.prototype.__proto__ || Object.getPrototypeOf(SessionsRouter.prototype), 'handleFind', this).call(this, req);\n    }\n  }, {\n    key: 'handleGet',\n    value: function handleGet(req) {\n      req.params.className = '_Session';\n      return _get(SessionsRouter.prototype.__proto__ || Object.getPrototypeOf(SessionsRouter.prototype), 'handleGet', this).call(this, req);\n    }\n  }, {\n    key: 'handleCreate',\n    value: function handleCreate(req) {\n      req.params.className = '_Session';\n      return _get(SessionsRouter.prototype.__proto__ || Object.getPrototypeOf(SessionsRouter.prototype), 'handleCreate', this).call(this, req);\n    }\n  }, {\n    key: 'handleUpdate',\n    value: function handleUpdate(req) {\n      req.params.className = '_Session';\n      return _get(SessionsRouter.prototype.__proto__ || Object.getPrototypeOf(SessionsRouter.prototype), 'handleUpdate', this).call(this, req);\n    }\n  }, {\n    key: 'handleDelete',\n    value: function handleDelete(req) {\n      req.params.className = '_Session';\n      return _get(SessionsRouter.prototype.__proto__ || Object.getPrototypeOf(SessionsRouter.prototype), 'handleDelete', this).call(this, req);\n    }\n  }, {\n    key: 'handleMe',\n    value: function handleMe(req) {\n      // TODO: Verify correct behavior\n      if (!req.info || !req.info.sessionToken) {\n        throw new _node2.default.Error(_node2.default.Error.INVALID_SESSION_TOKEN, 'Session token required.');\n      }\n      return _rest2.default.find(req.config, _Auth2.default.master(req.config), '_Session', { sessionToken: req.info.sessionToken }, undefined, req.info.clientSDK).then(function (response) {\n        if (!response.results || response.results.length == 0) {\n          throw new _node2.default.Error(_node2.default.Error.INVALID_SESSION_TOKEN, 'Session token not found.');\n        }\n        return {\n          response: response.results[0]\n        };\n      });\n    }\n  }, {\n    key: 'handleUpdateToRevocableSession',\n    value: function handleUpdateToRevocableSession(req) {\n      var config = req.config;\n      var masterAuth = _Auth2.default.master(config);\n      var user = req.auth.user;\n      // Issue #2720\n      // Calling without a session token would result in a not found user\n      if (!user) {\n        throw new _node2.default.Error(_node2.default.Error.OBJECT_NOT_FOUND, 'invalid session');\n      }\n      var expiresAt = config.generateSessionExpiresAt();\n      var sessionData = {\n        sessionToken: 'r:' + (0, _cryptoUtils.newToken)(),\n        user: {\n          __type: 'Pointer',\n          className: '_User',\n          objectId: user.id\n        },\n        createdWith: {\n          'action': 'upgrade'\n        },\n        restricted: false,\n        installationId: req.auth.installationId,\n        expiresAt: _node2.default._encode(expiresAt)\n      };\n      var create = new _RestWrite2.default(config, masterAuth, '_Session', null, sessionData);\n      return create.execute().then(function () {\n        // delete the session token, use the db to skip beforeSave\n        return config.database.update('_User', {\n          objectId: user.id\n        }, {\n          sessionToken: { __op: 'Delete' }\n        });\n      }).then(function () {\n        return Promise.resolve({ response: sessionData });\n      });\n    }\n  }, {\n    key: 'mountRoutes',\n    value: function mountRoutes() {\n      var _this2 = this;\n\n      this.route('GET', '/sessions/me', function (req) {\n        return _this2.handleMe(req);\n      });\n      this.route('GET', '/sessions', function (req) {\n        return _this2.handleFind(req);\n      });\n      this.route('GET', '/sessions/:objectId', function (req) {\n        return _this2.handleGet(req);\n      });\n      this.route('POST', '/sessions', function (req) {\n        return _this2.handleCreate(req);\n      });\n      this.route('PUT', '/sessions/:objectId', function (req) {\n        return _this2.handleUpdate(req);\n      });\n      this.route('DELETE', '/sessions/:objectId', function (req) {\n        return _this2.handleDelete(req);\n      });\n      this.route('POST', '/upgradeToRevocableSession', function (req) {\n        return _this2.handleUpdateToRevocableSession(req);\n      });\n    }\n  }]);\n\n  return SessionsRouter;\n}(_ClassesRouter3.default);\n\nexports.default = SessionsRouter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Controllers/UserController.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UserController = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _cryptoUtils = require('../cryptoUtils');\n\nvar _triggers = require('../triggers');\n\nvar _AdaptableController2 = require('./AdaptableController');\n\nvar _AdaptableController3 = _interopRequireDefault(_AdaptableController2);\n\nvar _MailAdapter = require('../Adapters/Email/MailAdapter');\n\nvar _MailAdapter2 = _interopRequireDefault(_MailAdapter);\n\nvar _rest = require('../rest');\n\nvar _rest2 = _interopRequireDefault(_rest);\n\nvar _node = require('parse/node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar RestQuery = require('../RestQuery');\nvar Auth = require('../Auth');\n\nvar UserController = exports.UserController = function (_AdaptableController) {\n  _inherits(UserController, _AdaptableController);\n\n  function UserController(adapter, appId) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, UserController);\n\n    return _possibleConstructorReturn(this, (UserController.__proto__ || Object.getPrototypeOf(UserController)).call(this, adapter, appId, options));\n  }\n\n  _createClass(UserController, [{\n    key: 'validateAdapter',\n    value: function validateAdapter(adapter) {\n      // Allow no adapter\n      if (!adapter && !this.shouldVerifyEmails) {\n        return;\n      }\n      _get(UserController.prototype.__proto__ || Object.getPrototypeOf(UserController.prototype), 'validateAdapter', this).call(this, adapter);\n    }\n  }, {\n    key: 'expectedAdapterType',\n    value: function expectedAdapterType() {\n      return _MailAdapter2.default;\n    }\n  }, {\n    key: 'setEmailVerifyToken',\n    value: function setEmailVerifyToken(user) {\n      if (this.shouldVerifyEmails) {\n        user._email_verify_token = (0, _cryptoUtils.randomString)(25);\n        user.emailVerified = false;\n\n        if (this.config.emailVerifyTokenValidityDuration) {\n          user._email_verify_token_expires_at = _node2.default._encode(this.config.generateEmailVerifyTokenExpiresAt());\n        }\n      }\n    }\n  }, {\n    key: 'verifyEmail',\n    value: function verifyEmail(username, token) {\n      if (!this.shouldVerifyEmails) {\n        // Trying to verify email when not enabled\n        // TODO: Better error here.\n        throw undefined;\n      }\n\n      var query = { username: username, _email_verify_token: token };\n      var updateFields = { emailVerified: true, _email_verify_token: { __op: 'Delete' } };\n\n      // if the email verify token needs to be validated then\n      // add additional query params and additional fields that need to be updated\n      if (this.config.emailVerifyTokenValidityDuration) {\n        query.emailVerified = false;\n        query._email_verify_token_expires_at = { $gt: _node2.default._encode(new Date()) };\n\n        updateFields._email_verify_token_expires_at = { __op: 'Delete' };\n      }\n\n      return this.config.database.update('_User', query, updateFields).then(function (document) {\n        if (!document) {\n          throw undefined;\n        }\n        return Promise.resolve(document);\n      });\n    }\n  }, {\n    key: 'checkResetTokenValidity',\n    value: function checkResetTokenValidity(username, token) {\n      var _this2 = this;\n\n      return this.config.database.find('_User', {\n        username: username,\n        _perishable_token: token\n      }, { limit: 1 }).then(function (results) {\n        if (results.length != 1) {\n          throw undefined;\n        }\n\n        if (_this2.config.passwordPolicy && _this2.config.passwordPolicy.resetTokenValidityDuration) {\n          var expiresDate = results[0]._perishable_token_expires_at;\n          if (expiresDate && expiresDate.__type == 'Date') {\n            expiresDate = new Date(expiresDate.iso);\n          }\n          if (expiresDate < new Date()) throw 'The password reset link has expired';\n        }\n\n        return results[0];\n      });\n    }\n  }, {\n    key: 'getUserIfNeeded',\n    value: function getUserIfNeeded(user) {\n      if (user.username && user.email) {\n        return Promise.resolve(user);\n      }\n      var where = {};\n      if (user.username) {\n        where.username = user.username;\n      }\n      if (user.email) {\n        where.email = user.email;\n      }\n\n      var query = new RestQuery(this.config, Auth.master(this.config), '_User', where);\n      return query.execute().then(function (result) {\n        if (result.results.length != 1) {\n          throw undefined;\n        }\n        return result.results[0];\n      });\n    }\n  }, {\n    key: 'sendVerificationEmail',\n    value: function sendVerificationEmail(user) {\n      var _this3 = this;\n\n      if (!this.shouldVerifyEmails) {\n        return;\n      }\n      var token = encodeURIComponent(user._email_verify_token);\n      // We may need to fetch the user in case of update email\n      this.getUserIfNeeded(user).then(function (user) {\n        var username = encodeURIComponent(user.username);\n\n        var link = buildEmailLink(_this3.config.verifyEmailURL, username, token, _this3.config);\n        var options = {\n          appName: _this3.config.appName,\n          link: link,\n          user: (0, _triggers.inflate)('_User', user)\n        };\n        if (_this3.adapter.sendVerificationEmail) {\n          _this3.adapter.sendVerificationEmail(options);\n        } else {\n          _this3.adapter.sendMail(_this3.defaultVerificationEmail(options));\n        }\n      });\n    }\n  }, {\n    key: 'setPasswordResetToken',\n    value: function setPasswordResetToken(email) {\n      var token = { _perishable_token: (0, _cryptoUtils.randomString)(25) };\n\n      if (this.config.passwordPolicy && this.config.passwordPolicy.resetTokenValidityDuration) {\n        token._perishable_token_expires_at = _node2.default._encode(this.config.generatePasswordResetTokenExpiresAt());\n      }\n\n      return this.config.database.update('_User', { $or: [{ email: email }, { username: email, email: { $exists: false } }] }, token, {}, true);\n    }\n  }, {\n    key: 'sendPasswordResetEmail',\n    value: function sendPasswordResetEmail(email) {\n      var _this4 = this;\n\n      if (!this.adapter) {\n        throw \"Trying to send a reset password but no adapter is set\";\n        //  TODO: No adapter?\n      }\n\n      return this.setPasswordResetToken(email).then(function (user) {\n        var token = encodeURIComponent(user._perishable_token);\n        var username = encodeURIComponent(user.username);\n\n        var link = buildEmailLink(_this4.config.requestResetPasswordURL, username, token, _this4.config);\n        var options = {\n          appName: _this4.config.appName,\n          link: link,\n          user: (0, _triggers.inflate)('_User', user)\n        };\n\n        if (_this4.adapter.sendPasswordResetEmail) {\n          _this4.adapter.sendPasswordResetEmail(options);\n        } else {\n          _this4.adapter.sendMail(_this4.defaultResetPasswordEmail(options));\n        }\n\n        return Promise.resolve(user);\n      });\n    }\n  }, {\n    key: 'updatePassword',\n    value: function updatePassword(username, token, password) {\n      var _this5 = this;\n\n      return this.checkResetTokenValidity(username, token).then(function (user) {\n        return updateUserPassword(user.objectId, password, _this5.config);\n      })\n      // clear reset password token\n      .then(function () {\n        return _this5.config.database.update('_User', { username: username }, {\n          _perishable_token: { __op: 'Delete' },\n          _perishable_token_expires_at: { __op: 'Delete' }\n        });\n      }).catch(function (error) {\n        if (error.message) {\n          // in case of Parse.Error, fail with the error message only\n          return Promise.reject(error.message);\n        } else {\n          return Promise.reject(error);\n        }\n      });\n    }\n  }, {\n    key: 'defaultVerificationEmail',\n    value: function defaultVerificationEmail(_ref) {\n      var link = _ref.link,\n          user = _ref.user,\n          appName = _ref.appName;\n\n      var text = \"Hi,\\n\\n\" + \"You are being asked to confirm the e-mail address \" + user.get(\"email\") + \" with \" + appName + \"\\n\\n\" + \"\" + \"Click here to confirm it:\\n\" + link;\n      var to = user.get(\"email\");\n      var subject = 'Please verify your e-mail for ' + appName;\n      return { text: text, to: to, subject: subject };\n    }\n  }, {\n    key: 'defaultResetPasswordEmail',\n    value: function defaultResetPasswordEmail(_ref2) {\n      var link = _ref2.link,\n          user = _ref2.user,\n          appName = _ref2.appName;\n\n      var text = \"Hi,\\n\\n\" + \"You requested to reset your password for \" + appName + \".\\n\\n\" + \"\" + \"Click here to reset it:\\n\" + link;\n      var to = user.get(\"email\") || user.get('username');\n      var subject = 'Password Reset for ' + appName;\n      return { text: text, to: to, subject: subject };\n    }\n  }, {\n    key: 'shouldVerifyEmails',\n    get: function get() {\n      return this.options.verifyUserEmails;\n    }\n  }]);\n\n  return UserController;\n}(_AdaptableController3.default);\n\n// Mark this private\n\n\nfunction updateUserPassword(userId, password, config) {\n  return _rest2.default.update(config, Auth.master(config), '_User', userId, {\n    password: password\n  });\n}\n\nfunction buildEmailLink(destination, username, token, config) {\n  var usernameAndToken = 'token=' + token + '&username=' + username;\n\n  if (config.parseFrameURL) {\n    var destinationWithoutHost = destination.replace(config.publicServerURL, '');\n\n    return config.parseFrameURL + '?link=' + encodeURIComponent(destinationWithoutHost) + '&' + usernameAndToken;\n  } else {\n    return destination + '?' + usernameAndToken;\n  }\n}\n\nexports.default = UserController;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Email/MailAdapter.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*eslint no-unused-vars: \"off\"*/\n/*\n  Mail Adapter prototype\n  A MailAdapter should implement at least sendMail()\n */\nvar MailAdapter = exports.MailAdapter = function () {\n  function MailAdapter() {\n    _classCallCheck(this, MailAdapter);\n  }\n\n  _createClass(MailAdapter, [{\n    key: \"sendMail\",\n\n    /*\n     * A method for sending mail\n     * @param options would have the parameters\n     * - to: the recipient\n     * - text: the raw text of the message\n     * - subject: the subject of the email\n     */\n    value: function sendMail(options) {}\n\n    /* You can implement those methods if you want\n     * to provide HTML templates etc...\n     */\n    // sendVerificationEmail({ link, appName, user }) {}\n    // sendPasswordResetEmail({ link, appName, user }) {}\n\n  }]);\n\n  return MailAdapter;\n}();\n\nexports.default = MailAdapter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Routers/UsersRouter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UsersRouter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _deepcopy = require('deepcopy');\n\nvar _deepcopy2 = _interopRequireDefault(_deepcopy);\n\nvar _node = require('parse/node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _Config = require('../Config');\n\nvar _Config2 = _interopRequireDefault(_Config);\n\nvar _AccountLockout = require('../AccountLockout');\n\nvar _AccountLockout2 = _interopRequireDefault(_AccountLockout);\n\nvar _ClassesRouter2 = require('./ClassesRouter');\n\nvar _ClassesRouter3 = _interopRequireDefault(_ClassesRouter2);\n\nvar _rest = require('../rest');\n\nvar _rest2 = _interopRequireDefault(_rest);\n\nvar _Auth = require('../Auth');\n\nvar _Auth2 = _interopRequireDefault(_Auth);\n\nvar _password = require('../password');\n\nvar _password2 = _interopRequireDefault(_password);\n\nvar _RestWrite = require('../RestWrite');\n\nvar _RestWrite2 = _interopRequireDefault(_RestWrite);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // These methods handle the User-related routes.\n\nvar cryptoUtils = require('../cryptoUtils');\n\nvar UsersRouter = exports.UsersRouter = function (_ClassesRouter) {\n  _inherits(UsersRouter, _ClassesRouter);\n\n  function UsersRouter() {\n    _classCallCheck(this, UsersRouter);\n\n    return _possibleConstructorReturn(this, (UsersRouter.__proto__ || Object.getPrototypeOf(UsersRouter)).apply(this, arguments));\n  }\n\n  _createClass(UsersRouter, [{\n    key: 'handleFind',\n    value: function handleFind(req) {\n      req.params.className = '_User';\n      return _get(UsersRouter.prototype.__proto__ || Object.getPrototypeOf(UsersRouter.prototype), 'handleFind', this).call(this, req);\n    }\n  }, {\n    key: 'handleGet',\n    value: function handleGet(req) {\n      req.params.className = '_User';\n      return _get(UsersRouter.prototype.__proto__ || Object.getPrototypeOf(UsersRouter.prototype), 'handleGet', this).call(this, req);\n    }\n  }, {\n    key: 'handleCreate',\n    value: function handleCreate(req) {\n      var data = (0, _deepcopy2.default)(req.body);\n      req.body = data;\n      req.params.className = '_User';\n\n      return _get(UsersRouter.prototype.__proto__ || Object.getPrototypeOf(UsersRouter.prototype), 'handleCreate', this).call(this, req);\n    }\n  }, {\n    key: 'handleUpdate',\n    value: function handleUpdate(req) {\n      req.params.className = '_User';\n      return _get(UsersRouter.prototype.__proto__ || Object.getPrototypeOf(UsersRouter.prototype), 'handleUpdate', this).call(this, req);\n    }\n  }, {\n    key: 'handleDelete',\n    value: function handleDelete(req) {\n      req.params.className = '_User';\n      return _get(UsersRouter.prototype.__proto__ || Object.getPrototypeOf(UsersRouter.prototype), 'handleDelete', this).call(this, req);\n    }\n  }, {\n    key: 'handleMe',\n    value: function handleMe(req) {\n      if (!req.info || !req.info.sessionToken) {\n        throw new _node2.default.Error(_node2.default.Error.INVALID_SESSION_TOKEN, 'invalid session token');\n      }\n      var sessionToken = req.info.sessionToken;\n      return _rest2.default.find(req.config, _Auth2.default.master(req.config), '_Session', { sessionToken: sessionToken }, { include: 'user' }, req.info.clientSDK).then(function (response) {\n        if (!response.results || response.results.length == 0 || !response.results[0].user) {\n          throw new _node2.default.Error(_node2.default.Error.INVALID_SESSION_TOKEN, 'invalid session token');\n        } else {\n          var user = response.results[0].user;\n          // Send token back on the login, because SDKs expect that.\n          user.sessionToken = sessionToken;\n          return { response: user };\n        }\n      });\n    }\n  }, {\n    key: 'handleLogIn',\n    value: function handleLogIn(req) {\n      // Use query parameters instead if provided in url\n      if (!req.body.username && req.query.username) {\n        req.body = req.query;\n      }\n\n      // TODO: use the right error codes / descriptions.\n      if (!req.body.username) {\n        throw new _node2.default.Error(_node2.default.Error.USERNAME_MISSING, 'username is required.');\n      }\n      if (!req.body.password) {\n        throw new _node2.default.Error(_node2.default.Error.PASSWORD_MISSING, 'password is required.');\n      }\n      if (typeof req.body.username !== 'string' || typeof req.body.password !== 'string') {\n        throw new _node2.default.Error(_node2.default.Error.OBJECT_NOT_FOUND, 'Invalid username/password.');\n      }\n\n      var user = void 0;\n      var isValidPassword = false;\n\n      return req.config.database.find('_User', { username: req.body.username }).then(function (results) {\n        if (!results.length) {\n          throw new _node2.default.Error(_node2.default.Error.OBJECT_NOT_FOUND, 'Invalid username/password.');\n        }\n        user = results[0];\n\n        if (req.config.verifyUserEmails && req.config.preventLoginWithUnverifiedEmail && !user.emailVerified) {\n          throw new _node2.default.Error(_node2.default.Error.EMAIL_NOT_FOUND, 'User email is not verified.');\n        }\n        return _password2.default.compare(req.body.password, user.password);\n      }).then(function (correct) {\n        isValidPassword = correct;\n        var accountLockoutPolicy = new _AccountLockout2.default(user, req.config);\n        return accountLockoutPolicy.handleLoginAttempt(isValidPassword);\n      }).then(function () {\n        if (!isValidPassword) {\n          throw new _node2.default.Error(_node2.default.Error.OBJECT_NOT_FOUND, 'Invalid username/password.');\n        }\n\n        // handle password expiry policy\n        if (req.config.passwordPolicy && req.config.passwordPolicy.maxPasswordAge) {\n          var changedAt = user._password_changed_at;\n\n          if (!changedAt) {\n            // password was created before expiry policy was enabled.\n            // simply update _User object so that it will start enforcing from now\n            changedAt = new Date();\n            req.config.database.update('_User', { username: user.username }, { _password_changed_at: _node2.default._encode(changedAt) });\n          } else {\n            // check whether the password has expired\n            if (changedAt.__type == 'Date') {\n              changedAt = new Date(changedAt.iso);\n            }\n            // Calculate the expiry time.\n            var _expiresAt = new Date(changedAt.getTime() + 86400000 * req.config.passwordPolicy.maxPasswordAge);\n            if (_expiresAt < new Date()) // fail of current time is past password expiry time\n              throw new _node2.default.Error(_node2.default.Error.OBJECT_NOT_FOUND, 'Your password has expired. Please reset your password.');\n          }\n        }\n\n        var token = 'r:' + cryptoUtils.newToken();\n        user.sessionToken = token;\n        delete user.password;\n\n        // Sometimes the authData still has null on that keys\n        // https://github.com/ParsePlatform/parse-server/issues/935\n        if (user.authData) {\n          Object.keys(user.authData).forEach(function (provider) {\n            if (user.authData[provider] === null) {\n              delete user.authData[provider];\n            }\n          });\n          if (Object.keys(user.authData).length == 0) {\n            delete user.authData;\n          }\n        }\n\n        req.config.filesController.expandFilesInObject(req.config, user);\n\n        var expiresAt = req.config.generateSessionExpiresAt();\n        var sessionData = {\n          sessionToken: token,\n          user: {\n            __type: 'Pointer',\n            className: '_User',\n            objectId: user.objectId\n          },\n          createdWith: {\n            'action': 'login',\n            'authProvider': 'password'\n          },\n          restricted: false,\n          expiresAt: _node2.default._encode(expiresAt)\n        };\n\n        if (req.info.installationId) {\n          sessionData.installationId = req.info.installationId;\n        }\n\n        var create = new _RestWrite2.default(req.config, _Auth2.default.master(req.config), '_Session', null, sessionData);\n        return create.execute();\n      }).then(function () {\n        return { response: user };\n      });\n    }\n  }, {\n    key: 'handleLogOut',\n    value: function handleLogOut(req) {\n      var success = { response: {} };\n      if (req.info && req.info.sessionToken) {\n        return _rest2.default.find(req.config, _Auth2.default.master(req.config), '_Session', { sessionToken: req.info.sessionToken }, undefined, req.info.clientSDK).then(function (records) {\n          if (records.results && records.results.length) {\n            return _rest2.default.del(req.config, _Auth2.default.master(req.config), '_Session', records.results[0].objectId).then(function () {\n              return Promise.resolve(success);\n            });\n          }\n          return Promise.resolve(success);\n        });\n      }\n      return Promise.resolve(success);\n    }\n  }, {\n    key: '_throwOnBadEmailConfig',\n    value: function _throwOnBadEmailConfig(req) {\n      try {\n        _Config2.default.validateEmailConfiguration({\n          emailAdapter: req.config.userController.adapter,\n          appName: req.config.appName,\n          publicServerURL: req.config.publicServerURL,\n          emailVerifyTokenValidityDuration: req.config.emailVerifyTokenValidityDuration\n        });\n      } catch (e) {\n        if (typeof e === 'string') {\n          // Maybe we need a Bad Configuration error, but the SDKs won't understand it. For now, Internal Server Error.\n          throw new _node2.default.Error(_node2.default.Error.INTERNAL_SERVER_ERROR, 'An appName, publicServerURL, and emailAdapter are required for password reset and email verification functionality.');\n        } else {\n          throw e;\n        }\n      }\n    }\n  }, {\n    key: 'handleResetRequest',\n    value: function handleResetRequest(req) {\n      this._throwOnBadEmailConfig(req);\n\n      var email = req.body.email;\n\n      if (!email) {\n        throw new _node2.default.Error(_node2.default.Error.EMAIL_MISSING, \"you must provide an email\");\n      }\n      if (typeof email !== 'string') {\n        throw new _node2.default.Error(_node2.default.Error.INVALID_EMAIL_ADDRESS, 'you must provide a valid email string');\n      }\n      var userController = req.config.userController;\n      return userController.sendPasswordResetEmail(email).then(function () {\n        return Promise.resolve({\n          response: {}\n        });\n      }, function (err) {\n        if (err.code === _node2.default.Error.OBJECT_NOT_FOUND) {\n          throw new _node2.default.Error(_node2.default.Error.EMAIL_NOT_FOUND, 'No user found with email ' + email + '.');\n        } else {\n          throw err;\n        }\n      });\n    }\n  }, {\n    key: 'handleVerificationEmailRequest',\n    value: function handleVerificationEmailRequest(req) {\n      this._throwOnBadEmailConfig(req);\n\n      var email = req.body.email;\n\n      if (!email) {\n        throw new _node2.default.Error(_node2.default.Error.EMAIL_MISSING, 'you must provide an email');\n      }\n      if (typeof email !== 'string') {\n        throw new _node2.default.Error(_node2.default.Error.INVALID_EMAIL_ADDRESS, 'you must provide a valid email string');\n      }\n\n      return req.config.database.find('_User', { email: email }).then(function (results) {\n        if (!results.length || results.length < 1) {\n          throw new _node2.default.Error(_node2.default.Error.EMAIL_NOT_FOUND, 'No user found with email ' + email);\n        }\n        var user = results[0];\n\n        if (user.emailVerified) {\n          throw new _node2.default.Error(_node2.default.Error.OTHER_CAUSE, 'Email ' + email + ' is already verified.');\n        }\n\n        var userController = req.config.userController;\n        userController.sendVerificationEmail(user);\n        return { response: {} };\n      });\n    }\n  }, {\n    key: 'mountRoutes',\n    value: function mountRoutes() {\n      var _this2 = this;\n\n      this.route('GET', '/users', function (req) {\n        return _this2.handleFind(req);\n      });\n      this.route('POST', '/users', function (req) {\n        return _this2.handleCreate(req);\n      });\n      this.route('GET', '/users/me', function (req) {\n        return _this2.handleMe(req);\n      });\n      this.route('GET', '/users/:objectId', function (req) {\n        return _this2.handleGet(req);\n      });\n      this.route('PUT', '/users/:objectId', function (req) {\n        return _this2.handleUpdate(req);\n      });\n      this.route('DELETE', '/users/:objectId', function (req) {\n        return _this2.handleDelete(req);\n      });\n      this.route('GET', '/login', function (req) {\n        return _this2.handleLogIn(req);\n      });\n      this.route('POST', '/logout', function (req) {\n        return _this2.handleLogOut(req);\n      });\n      this.route('POST', '/requestPasswordReset', function (req) {\n        return _this2.handleResetRequest(req);\n      });\n      this.route('POST', '/verificationEmailRequest', function (req) {\n        return _this2.handleVerificationEmailRequest(req);\n      });\n    }\n  }]);\n\n  return UsersRouter;\n}(_ClassesRouter3.default);\n\nexports.default = UsersRouter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/AccountLockout.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AccountLockout = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // This class handles the Account Lockout Policy settings.\n\n\nvar _node = require('parse/node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar AccountLockout = exports.AccountLockout = function () {\n  function AccountLockout(user, config) {\n    _classCallCheck(this, AccountLockout);\n\n    this._user = user;\n    this._config = config;\n  }\n\n  /**\n   * set _failed_login_count to value\n   */\n\n\n  _createClass(AccountLockout, [{\n    key: '_setFailedLoginCount',\n    value: function _setFailedLoginCount(value) {\n      var query = {\n        username: this._user.username\n      };\n\n      var updateFields = {\n        _failed_login_count: value\n      };\n\n      return this._config.database.update('_User', query, updateFields);\n    }\n\n    /**\n     * check if the _failed_login_count field has been set\n     */\n\n  }, {\n    key: '_isFailedLoginCountSet',\n    value: function _isFailedLoginCountSet() {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        var query = {\n          username: _this._user.username,\n          _failed_login_count: { $exists: true }\n        };\n\n        _this._config.database.find('_User', query).then(function (users) {\n          if (Array.isArray(users) && users.length > 0) {\n            resolve(true);\n          } else {\n            resolve(false);\n          }\n        }).catch(function (err) {\n          reject(err);\n        });\n      });\n    }\n\n    /**\n     * if _failed_login_count is NOT set then set it to 0\n     * else do nothing\n     */\n\n  }, {\n    key: '_initFailedLoginCount',\n    value: function _initFailedLoginCount() {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n\n        _this2._isFailedLoginCountSet().then(function (failedLoginCountIsSet) {\n          if (!failedLoginCountIsSet) {\n            return _this2._setFailedLoginCount(0);\n          } else {\n            return Promise.resolve();\n          }\n        }).then(function () {\n          resolve();\n        }).catch(function (err) {\n          reject(err);\n        });\n      });\n    }\n\n    /**\n     * increment _failed_login_count by 1\n     */\n\n  }, {\n    key: '_incrementFailedLoginCount',\n    value: function _incrementFailedLoginCount() {\n      var query = {\n        username: this._user.username\n      };\n\n      var updateFields = { _failed_login_count: { __op: 'Increment', amount: 1 } };\n\n      return this._config.database.update('_User', query, updateFields);\n    }\n\n    /**\n     * if the failed login count is greater than the threshold\n     * then sets lockout expiration to 'currenttime + accountPolicy.duration', i.e., account is locked out for the next 'accountPolicy.duration' minutes\n     * else do nothing\n     */\n\n  }, {\n    key: '_setLockoutExpiration',\n    value: function _setLockoutExpiration() {\n      var _this3 = this;\n\n      return new Promise(function (resolve, reject) {\n        var query = {\n          username: _this3._user.username,\n          _failed_login_count: { $gte: _this3._config.accountLockout.threshold }\n        };\n\n        var now = new Date();\n\n        var updateFields = {\n          _account_lockout_expires_at: _node2.default._encode(new Date(now.getTime() + _this3._config.accountLockout.duration * 60 * 1000))\n        };\n\n        _this3._config.database.update('_User', query, updateFields).then(function () {\n          resolve();\n        }).catch(function (err) {\n          if (err && err.code && err.message && err.code === 101 && err.message === 'Object not found.') {\n            resolve(); // nothing to update so we are good\n          } else {\n            reject(err); // unknown error\n          }\n        });\n      });\n    }\n\n    /**\n     * if _account_lockout_expires_at > current_time and _failed_login_count > threshold\n     *   reject with account locked error\n     * else\n     *   resolve\n     */\n\n  }, {\n    key: '_notLocked',\n    value: function _notLocked() {\n      var _this4 = this;\n\n      return new Promise(function (resolve, reject) {\n        var query = {\n          username: _this4._user.username,\n          _account_lockout_expires_at: { $gt: _node2.default._encode(new Date()) },\n          _failed_login_count: { $gte: _this4._config.accountLockout.threshold }\n        };\n\n        _this4._config.database.find('_User', query).then(function (users) {\n          if (Array.isArray(users) && users.length > 0) {\n            reject(new _node2.default.Error(_node2.default.Error.OBJECT_NOT_FOUND, 'Your account is locked due to multiple failed login attempts. Please try again after ' + _this4._config.accountLockout.duration + ' minute(s)'));\n          } else {\n            resolve();\n          }\n        }).catch(function (err) {\n          reject(err);\n        });\n      });\n    }\n\n    /**\n     * set and/or increment _failed_login_count\n     * if _failed_login_count > threshold\n     *   set the _account_lockout_expires_at to current_time + accountPolicy.duration\n     * else\n     *   do nothing\n     */\n\n  }, {\n    key: '_handleFailedLoginAttempt',\n    value: function _handleFailedLoginAttempt() {\n      var _this5 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this5._initFailedLoginCount().then(function () {\n          return _this5._incrementFailedLoginCount();\n        }).then(function () {\n          return _this5._setLockoutExpiration();\n        }).then(function () {\n          resolve();\n        }).catch(function (err) {\n          reject(err);\n        });\n      });\n    }\n\n    /**\n     * handle login attempt if the Account Lockout Policy is enabled\n     */\n\n  }, {\n    key: 'handleLoginAttempt',\n    value: function handleLoginAttempt(loginSuccessful) {\n      var _this6 = this;\n\n      if (!this._config.accountLockout) {\n        return Promise.resolve();\n      }\n\n      return new Promise(function (resolve, reject) {\n        _this6._notLocked().then(function () {\n          if (loginSuccessful) {\n            return _this6._setFailedLoginCount(0);\n          } else {\n            return _this6._handleFailedLoginAttempt();\n          }\n        }).then(function () {\n          resolve();\n        }).catch(function (err) {\n          reject(err);\n        });\n      });\n    }\n  }]);\n\n  return AccountLockout;\n}();\n\nexports.default = AccountLockout;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Routers/PurgeRouter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PurgeRouter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _PromiseRouter2 = require('../PromiseRouter');\n\nvar _PromiseRouter3 = _interopRequireDefault(_PromiseRouter2);\n\nvar _middlewares = require('../middlewares');\n\nvar middleware = _interopRequireWildcard(_middlewares);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar PurgeRouter = exports.PurgeRouter = function (_PromiseRouter) {\n  _inherits(PurgeRouter, _PromiseRouter);\n\n  function PurgeRouter() {\n    _classCallCheck(this, PurgeRouter);\n\n    return _possibleConstructorReturn(this, (PurgeRouter.__proto__ || Object.getPrototypeOf(PurgeRouter)).apply(this, arguments));\n  }\n\n  _createClass(PurgeRouter, [{\n    key: 'handlePurge',\n    value: function handlePurge(req) {\n      return req.config.database.purgeCollection(req.params.className).then(function () {\n        var cacheAdapter = req.config.cacheController;\n        if (req.params.className == '_Session') {\n          cacheAdapter.user.clear();\n        } else if (req.params.className == '_Role') {\n          cacheAdapter.role.clear();\n        }\n        return { response: {} };\n      });\n    }\n  }, {\n    key: 'mountRoutes',\n    value: function mountRoutes() {\n      var _this2 = this;\n\n      this.route('DELETE', '/purge/:className', middleware.promiseEnforceMasterKeyAccess, function (req) {\n        return _this2.handlePurge(req);\n      });\n    }\n  }]);\n\n  return PurgeRouter;\n}(_PromiseRouter3.default);\n\nexports.default = PurgeRouter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server-push-adapter/lib/index.js":"\"use strict\";\n// ParsePushAdapter is the default implementation of\n// PushAdapter, it uses GCM for android push and APNS\n// for ios push.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.utils = exports.GCM = exports.APNS = exports.ParsePushAdapter = undefined;\n\nvar _npmlog = require('npmlog');\n\nvar _npmlog2 = _interopRequireDefault(_npmlog);\n\nvar _ParsePushAdapter = require('./ParsePushAdapter');\n\nvar _ParsePushAdapter2 = _interopRequireDefault(_ParsePushAdapter);\n\nvar _GCM = require('./GCM');\n\nvar _GCM2 = _interopRequireDefault(_GCM);\n\nvar _APNS = require('./APNS');\n\nvar _APNS2 = _interopRequireDefault(_APNS);\n\nvar _PushAdapterUtils = require('./PushAdapterUtils');\n\nvar utils = _interopRequireWildcard(_PushAdapterUtils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nif (process.env.VERBOSE || process.env.VERBOSE_PARSE_SERVER_PUSH_ADAPTER) {\n  _npmlog2.default.level = 'verbose';\n}exports.default = _ParsePushAdapter2.default;\nexports.ParsePushAdapter = _ParsePushAdapter2.default;\nexports.APNS = _APNS2.default;\nexports.GCM = _GCM2.default;\nexports.utils = utils;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server-push-adapter/node_modules/npmlog/log.js":"'use strict'\nvar Progress = require('are-we-there-yet')\nvar Gauge = require('gauge')\nvar EE = require('events').EventEmitter\nvar log = exports = module.exports = new EE\nvar util = require('util')\n\nvar ansi = require('ansi')\nlog.cursor = ansi(process.stderr)\nlog.stream = process.stderr\n\n// by default, let ansi decide based on tty-ness.\nvar colorEnabled = undefined\nlog.enableColor = function () {\n  colorEnabled = true\n  this.cursor.enabled = true\n}\nlog.disableColor = function () {\n  colorEnabled = false\n  this.cursor.enabled = false\n}\n\n// default level\nlog.level = 'info'\n\nlog.gauge = new Gauge(log.cursor)\nlog.tracker = new Progress.TrackerGroup()\n\n// no progress bars unless asked\nlog.progressEnabled = false\n\nvar gaugeTheme = undefined\n\nlog.enableUnicode = function () {\n  gaugeTheme = Gauge.unicode\n  log.gauge.setTheme(gaugeTheme)\n}\n\nlog.disableUnicode = function () {\n  gaugeTheme = Gauge.ascii\n  log.gauge.setTheme(gaugeTheme)\n}\n\nvar gaugeTemplate = undefined\nlog.setGaugeTemplate = function (template) {\n  gaugeTemplate = template\n  log.gauge.setTemplate(gaugeTemplate)\n}\n\nlog.enableProgress = function () {\n  if (this.progressEnabled) return\n  this.progressEnabled = true\n  if (this._pause) return\n  this.tracker.on('change', this.showProgress)\n  this.gauge.enable()\n  this.showProgress()\n}\n\nlog.disableProgress = function () {\n  if (!this.progressEnabled) return\n  this.clearProgress()\n  this.progressEnabled = false\n  this.tracker.removeListener('change', this.showProgress)\n  this.gauge.disable()\n}\n\nvar trackerConstructors = ['newGroup', 'newItem', 'newStream']\n\nvar mixinLog = function (tracker) {\n  // mixin the public methods from log into the tracker\n  // (except: conflicts and one's we handle specially)\n  Object.keys(log).forEach(function (P) {\n    if (P[0] === '_') return\n    if (trackerConstructors.filter(function (C) { return C === P }).length) return\n    if (tracker[P]) return\n    if (typeof log[P] !== 'function') return\n    var func = log[P]\n    tracker[P] = function () {\n      return func.apply(log, arguments)\n    }\n  })\n  // if the new tracker is a group, make sure any subtrackers get\n  // mixed in too\n  if (tracker instanceof Progress.TrackerGroup) {\n    trackerConstructors.forEach(function (C) {\n      var func = tracker[C]\n      tracker[C] = function () { return mixinLog(func.apply(tracker, arguments)) }\n    })\n  }\n  return tracker\n}\n\n// Add tracker constructors to the top level log object\ntrackerConstructors.forEach(function (C) {\n  log[C] = function () { return mixinLog(this.tracker[C].apply(this.tracker, arguments)) }\n})\n\nlog.clearProgress = function () {\n  if (!this.progressEnabled) return\n  this.gauge.hide()\n}\n\nlog.showProgress = function (name, completed) {\n  if (!this.progressEnabled) return\n  if (completed == null) completed = this.tracker.completed()\n  this.gauge.show(name, completed)\n}.bind(log) // bind for use in tracker's on-change listener\n\n// temporarily stop emitting, but don't drop\nlog.pause = function () {\n  this._paused = true\n}\n\nlog.resume = function () {\n  if (!this._paused) return\n  this._paused = false\n\n  var b = this._buffer\n  this._buffer = []\n  b.forEach(function (m) {\n    this.emitLog(m)\n  }, this)\n  if (this.progressEnabled) this.enableProgress()\n}\n\nlog._buffer = []\n\nvar id = 0\nlog.record = []\nlog.maxRecordSize = 10000\nlog.log = function (lvl, prefix, message) {\n  var l = this.levels[lvl]\n  if (l === undefined) {\n    return this.emit('error', new Error(util.format(\n      'Undefined log level: %j', lvl)))\n  }\n\n  var a = new Array(arguments.length - 2)\n  var stack = null\n  for (var i = 2; i < arguments.length; i ++) {\n    var arg = a[i-2] = arguments[i]\n\n    // resolve stack traces to a plain string.\n    if (typeof arg === 'object' && arg &&\n        (arg instanceof Error) && arg.stack) {\n      arg.stack = stack = arg.stack + ''\n    }\n  }\n  if (stack) a.unshift(stack + '\\n')\n  message = util.format.apply(util, a)\n\n  var m = { id: id++,\n            level: lvl,\n            prefix: String(prefix || ''),\n            message: message,\n            messageRaw: a }\n\n  this.emit('log', m)\n  this.emit('log.' + lvl, m)\n  if (m.prefix) this.emit(m.prefix, m)\n\n  this.record.push(m)\n  var mrs = this.maxRecordSize\n  var n = this.record.length - mrs\n  if (n > mrs / 10) {\n    var newSize = Math.floor(mrs * 0.9)\n    this.record = this.record.slice(-1 * newSize)\n  }\n\n  this.emitLog(m)\n}.bind(log)\n\nlog.emitLog = function (m) {\n  if (this._paused) {\n    this._buffer.push(m)\n    return\n  }\n  if (this.progressEnabled) this.gauge.pulse(m.prefix)\n  var l = this.levels[m.level]\n  if (l === undefined) return\n  if (l < this.levels[this.level]) return\n  if (l > 0 && !isFinite(l)) return\n\n  var style = log.style[m.level]\n  var disp = log.disp[m.level] || m.level\n  this.clearProgress()\n  m.message.split(/\\r?\\n/).forEach(function (line) {\n    if (this.heading) {\n      this.write(this.heading, this.headingStyle)\n      this.write(' ')\n    }\n    this.write(disp, log.style[m.level])\n    var p = m.prefix || ''\n    if (p) this.write(' ')\n    this.write(p, this.prefixStyle)\n    this.write(' ' + line + '\\n')\n  }, this)\n  this.showProgress()\n}\n\nlog.write = function (msg, style) {\n  if (!this.cursor) return\n  if (this.stream !== this.cursor.stream) {\n    this.cursor = ansi(this.stream, { enabled: colorEnabled })\n    var options = {}\n    if (gaugeTheme != null) options.theme = gaugeTheme\n    if (gaugeTemplate != null) options.template = gaugeTemplate\n    this.gauge = new Gauge(options, this.cursor)\n  }\n\n  style = style || {}\n  if (style.fg) this.cursor.fg[style.fg]()\n  if (style.bg) this.cursor.bg[style.bg]()\n  if (style.bold) this.cursor.bold()\n  if (style.underline) this.cursor.underline()\n  if (style.inverse) this.cursor.inverse()\n  if (style.beep) this.cursor.beep()\n  this.cursor.write(msg).reset()\n}\n\nlog.addLevel = function (lvl, n, style, disp) {\n  if (!disp) disp = lvl\n  this.levels[lvl] = n\n  this.style[lvl] = style\n  if (!this[lvl]) this[lvl] = function () {\n    var a = new Array(arguments.length + 1)\n    a[0] = lvl\n    for (var i = 0; i < arguments.length; i ++) {\n      a[i + 1] = arguments[i]\n    }\n    return this.log.apply(this, a)\n  }.bind(this)\n  this.disp[lvl] = disp\n}\n\nlog.prefixStyle = { fg: 'magenta' }\nlog.headingStyle = { fg: 'white', bg: 'black' }\n\nlog.style = {}\nlog.levels = {}\nlog.disp = {}\nlog.addLevel('silly', -Infinity, { inverse: true }, 'sill')\nlog.addLevel('verbose', 1000, { fg: 'blue', bg: 'black' }, 'verb')\nlog.addLevel('info', 2000, { fg: 'green' })\nlog.addLevel('http', 3000, { fg: 'green', bg: 'black' })\nlog.addLevel('warn', 4000, { fg: 'black', bg: 'yellow' }, 'WARN')\nlog.addLevel('error', 5000, { fg: 'red', bg: 'black' }, 'ERR!')\nlog.addLevel('silent', Infinity)\n\n// allow 'error' prefix\nlog.on('error', function(){})\n","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server-push-adapter/node_modules/gauge/progress-bar.js":"\"use strict\"\nvar hasUnicode = require(\"has-unicode\")\nvar ansi = require(\"ansi\")\nvar align = {\n  center: require(\"lodash.pad\"),\n  left:   require(\"lodash.padend\"),\n  right:  require(\"lodash.padstart\")\n}\nvar defaultStream = process.stderr\nfunction isTTY() {\n  return process.stderr.isTTY\n}\nfunction getWritableTTYColumns() {\n  // Writing to the final column wraps the line\n  // We have to use stdout here, because Node's magic SIGWINCH handler only\n  // updates process.stdout, not process.stderr\n  return process.stdout.columns - 1\n}\n\nvar ProgressBar = module.exports = function (options, cursor) {\n  if (! options) options = {}\n  if (! cursor && options.write) {\n    cursor = options\n    options = {}\n  }\n  if (! cursor) {\n    cursor = ansi(defaultStream)\n  }\n  this.cursor = cursor\n  this.showing = false\n  this.theme = options.theme || (hasUnicode() ? ProgressBar.unicode : ProgressBar.ascii)\n  this.template = options.template || [\n    {type: \"name\", separated: true, length: 25},\n    {type: \"spinner\", separated: true},\n    {type: \"startgroup\"},\n    {type: \"completionbar\"},\n    {type: \"endgroup\"}\n  ]\n  this.updatefreq = options.maxUpdateFrequency == null ? 50 : options.maxUpdateFrequency\n  this.lastName = \"\"\n  this.lastCompleted = 0\n  this.spun = 0\n  this.last = new Date(0)\n\n  var self = this\n  this._handleSizeChange = function () {\n    if (!self.showing) return\n    self.hide()\n    self.show()\n  }\n}\nProgressBar.prototype = {}\n\nProgressBar.unicode = {\n  startgroup: \"\",\n  endgroup: \"\",\n  complete: \"\",\n  incomplete: \"\",\n  spinner: \"\",\n  subsection: \"\"\n}\n\nProgressBar.ascii = {\n  startgroup: \"|\",\n  endgroup: \"|\",\n  complete: \"#\",\n  incomplete: \"-\",\n  spinner: \"-\\\\|/\",\n  subsection: \"->\"\n}\n\nProgressBar.prototype.setTheme = function(theme) {\n  this.theme = theme\n}\n\nProgressBar.prototype.setTemplate = function(template) {\n  this.template = template\n}\n\nProgressBar.prototype._enableResizeEvents = function() {\n  process.stdout.on('resize', this._handleSizeChange)\n}\n\nProgressBar.prototype._disableResizeEvents = function() {\n  process.stdout.removeListener('resize', this._handleSizeChange)\n}\n\nProgressBar.prototype.disable = function() {\n  this.hide()\n  this.disabled = true\n}\n\nProgressBar.prototype.enable = function() {\n  this.disabled = false\n  this.show()\n}\n\nProgressBar.prototype.hide = function() {\n  if (!isTTY()) return\n  if (this.disabled) return\n  this.cursor.show()\n  if (this.showing) this.cursor.up(1)\n  this.cursor.horizontalAbsolute(0).eraseLine()\n  this.showing = false\n}\n\nvar repeat = function (str, count) {\n  var out = \"\"\n  for (var ii=0; ii<count; ++ii) out += str\n  return out\n}\n\nProgressBar.prototype.pulse = function(name) {\n  ++ this.spun\n  if (! this.showing) return\n  if (this.disabled) return\n\n  var baseName = this.lastName\n  name = name\n       ? ( baseName\n         ? baseName + \" \" + this.theme.subsection + \" \" + name\n         : null )\n       : baseName\n  this.show(name)\n  this.lastName = baseName\n}\n\nProgressBar.prototype.show = function(name, completed) {\n  name = this.lastName = name || this.lastName\n  completed = this.lastCompleted = completed || this.lastCompleted\n\n  if (!isTTY()) return\n  if (this.disabled) return\n  if (! this.spun && ! completed) return\n  if (this.tryAgain) return\n  var self = this\n\n  if (this.showing && new Date() - this.last < this.updatefreq) {\n    this.tryAgain = setTimeout(function () {\n      self.tryAgain = null\n      if (self.disabled) return\n      if (! self.spun && ! completed) return\n      drawBar()\n    }, this.updatefreq - (new Date() - this.last))\n    return\n  }\n\n  return drawBar()\n\n  function drawBar() {\n    var values = {\n      name: name,\n      spinner: self.spun,\n      completed: completed\n    }\n\n    self.last = new Date()\n\n    var statusline = self.renderTemplate(self.theme, self.template, values)\n\n    if (self.showing) self.cursor.up(1)\n    self.cursor\n        .hide()\n        .horizontalAbsolute(0)\n        .write(statusline.substr(0, getWritableTTYColumns()) + \"\\n\")\n        .show()\n\n    self.showing = true\n  }\n}\n\nProgressBar.prototype.renderTemplate = function (theme, template, values) {\n  values.startgroup = theme.startgroup\n  values.endgroup = theme.endgroup\n  values.spinner = values.spinner\n    ? theme.spinner.substr(values.spinner % theme.spinner.length,1)\n    : \"\"\n\n  var output = {prebar: \"\", postbar: \"\"}\n  var status = \"prebar\"\n  var self = this\n  template.forEach(function(T) {\n    if (typeof T === \"string\") {\n      output[status] += T\n      return\n    }\n    if (T.type === \"completionbar\") {\n      status = \"postbar\"\n      return\n    }\n    if (!values.hasOwnProperty(T.type)) throw new Error(\"Unknown template value '\"+T.type+\"'\")\n    var value = self.renderValue(T, values[T.type])\n    if (value === \"\") return\n    var sofar = output[status].length\n    var lastChar = sofar ? output[status][sofar-1] : null\n    if (T.separated && sofar && lastChar !== \" \") {\n      output[status] += \" \"\n    }\n    output[status] += value\n    if (T.separated) output[status] += \" \"\n  })\n\n  var bar = \"\"\n  if (status === \"postbar\") {\n    var nonBarLen = output.prebar.length + output.postbar.length\n\n    var barLen = getWritableTTYColumns() - nonBarLen\n    var sofar = Math.round(barLen * Math.max(0,Math.min(1,values.completed||0)))\n    var rest = barLen - sofar\n    bar = repeat(theme.complete, sofar)\n        + repeat(theme.incomplete, rest)\n  }\n\n  return output.prebar + bar + output.postbar\n}\nProgressBar.prototype.renderValue = function (template, value) {\n  if (value == null || value === \"\") return \"\"\n  var maxLength = template.maxLength || template.length\n  var minLength = template.minLength || template.length\n  var alignWith = align[template.align] || align.left\n//  if (maxLength) value = value.substr(-1 * maxLength)\n  if (maxLength) value = value.substr(0, maxLength)\n  if (minLength) value = alignWith(value, minLength)\n  return value\n}\n","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server-push-adapter/lib/ParsePushAdapter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParsePushAdapter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _parse = require('parse');\n\nvar _parse2 = _interopRequireDefault(_parse);\n\nvar _npmlog = require('npmlog');\n\nvar _npmlog2 = _interopRequireDefault(_npmlog);\n\nvar _APNS = require('./APNS');\n\nvar _APNS2 = _interopRequireDefault(_APNS);\n\nvar _GCM = require('./GCM');\n\nvar _GCM2 = _interopRequireDefault(_GCM);\n\nvar _PushAdapterUtils = require('./PushAdapterUtils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar LOG_PREFIX = 'parse-server-push-adapter';\n\nvar ParsePushAdapter = exports.ParsePushAdapter = function () {\n  function ParsePushAdapter() {\n    var pushConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ParsePushAdapter);\n\n    this.supportsPushTracking = true;\n\n    this.validPushTypes = ['ios', 'osx', 'tvos', 'android', 'fcm'];\n    this.senderMap = {};\n    // used in PushController for Dashboard Features\n    this.feature = {\n      immediatePush: true\n    };\n    var pushTypes = Object.keys(pushConfig);\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = pushTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var pushType = _step.value;\n\n        if (this.validPushTypes.indexOf(pushType) < 0) {\n          throw new _parse2.default.Error(_parse2.default.Error.PUSH_MISCONFIGURED, 'Push to ' + pushTypes + ' is not supported');\n        }\n        switch (pushType) {\n          case 'ios':\n          case 'tvos':\n          case 'osx':\n            this.senderMap[pushType] = new _APNS2.default(pushConfig[pushType]);\n            break;\n          case 'android':\n          case 'fcm':\n            this.senderMap[pushType] = new _GCM2.default(pushConfig[pushType]);\n            break;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  _createClass(ParsePushAdapter, [{\n    key: 'getValidPushTypes',\n    value: function getValidPushTypes() {\n      return this.validPushTypes;\n    }\n  }, {\n    key: 'send',\n    value: function send(data, installations) {\n      var _this = this;\n\n      var deviceMap = (0, _PushAdapterUtils.classifyInstallations)(installations, this.validPushTypes);\n      var sendPromises = [];\n\n      var _loop = function _loop(pushType) {\n        var sender = _this.senderMap[pushType];\n        var devices = deviceMap[pushType];\n\n        if (Array.isArray(devices) && devices.length > 0) {\n          if (!sender) {\n            _npmlog2.default.verbose(LOG_PREFIX, 'Can not find sender for push type ' + pushType + ', ' + data);\n            var results = devices.map(function (device) {\n              return Promise.resolve({\n                device: device,\n                transmitted: false,\n                response: { 'error': 'Can not find sender for push type ' + pushType + ', ' + data }\n              });\n            });\n            sendPromises.push(Promise.all(results));\n          } else {\n            sendPromises.push(sender.send(data, devices));\n          }\n        }\n      };\n\n      for (var pushType in deviceMap) {\n        _loop(pushType);\n      }\n      return Promise.all(sendPromises).then(function (promises) {\n        // flatten all\n        return [].concat.apply([], promises);\n      });\n    }\n  }], [{\n    key: 'classifyInstallations',\n    value: function classifyInstallations(installations, validTypes) {\n      return (0, _PushAdapterUtils.classifyInstallations)(installations, validTypes);\n    }\n  }]);\n\n  return ParsePushAdapter;\n}();\n\nexports.default = ParsePushAdapter;\n\nmodule.exports = ParsePushAdapter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server-push-adapter/lib/APNS.js":"\"use strict\";\n\n// TODO: apn does not support the new HTTP/2 protocal. It is fine to use it in V1,\n// but probably we will replace it in the future.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _apn = require('apn');\n\nvar _apn2 = _interopRequireDefault(_apn);\n\nvar _parse = require('parse');\n\nvar _parse2 = _interopRequireDefault(_parse);\n\nvar _npmlog = require('npmlog');\n\nvar _npmlog2 = _interopRequireDefault(_npmlog);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar LOG_PREFIX = 'parse-server-push-adapter APNS';\n\n/**\n * Create a new connection to the APN service.\n * @constructor\n * @param {Object|Array} args An argument or a list of arguments to config APNS connection\n * @param {String} args.cert The filename of the connection certificate to load from disk\n * @param {String} args.key The filename of the connection key to load from disk\n * @param {String} args.pfx The filename for private key, certificate and CA certs in PFX or PKCS12 format, it will overwrite cert and key\n * @param {String} args.passphrase The passphrase for the connection key, if required\n * @param {String} args.bundleId The bundleId for cert\n * @param {Boolean} args.production Specifies which environment to connect to: Production (if true) or Sandbox\n */\nfunction APNS(args) {\n  var _this = this;\n\n  // typePushConfig can be an array.\n  var apnsArgsList = [];\n  if (Array.isArray(args)) {\n    apnsArgsList = apnsArgsList.concat(args);\n  } else if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object') {\n    apnsArgsList.push(args);\n  } else {\n    throw new _parse2.default.Error(_parse2.default.Error.PUSH_MISCONFIGURED, 'APNS Configuration is invalid');\n  }\n\n  this.conns = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    var _loop = function _loop() {\n      var apnsArgs = _step.value;\n\n      var conn = new _apn2.default.Connection(apnsArgs);\n      if (!apnsArgs.bundleId) {\n        throw new _parse2.default.Error(_parse2.default.Error.PUSH_MISCONFIGURED, 'BundleId is mssing for %j', apnsArgs);\n      }\n      conn.bundleId = apnsArgs.bundleId;\n      // Set the priority of the conns, prod cert has higher priority\n      if (apnsArgs.production) {\n        conn.priority = 0;\n      } else {\n        conn.priority = 1;\n      }\n\n      // Set apns client callbacks\n      conn.on('connected', function () {\n        _npmlog2.default.verbose(LOG_PREFIX, 'APNS Connection %d Connected', conn.index);\n      });\n\n      conn.on('transmissionError', function (errCode, notification, apnDevice) {\n        handleTransmissionError(_this.conns, errCode, notification, apnDevice);\n      });\n\n      conn.on('timeout', function () {\n        _npmlog2.default.verbose(LOG_PREFIX, 'APNS Connection %d Timeout', conn.index);\n      });\n\n      conn.on('disconnected', function () {\n        _npmlog2.default.verbose(LOG_PREFIX, 'APNS Connection %d Disconnected', conn.index);\n      });\n\n      conn.on('socketError', function () {\n        _npmlog2.default.verbose(LOG_PREFIX, 'APNS Connection %d Socket Error', conn.index);\n      });\n\n      conn.on('transmitted', function (notification, device) {\n        if (device.callback) {\n          device.callback({\n            notification: notification,\n            transmitted: true,\n            device: {\n              deviceType: device.deviceType,\n              deviceToken: device.token.toString('hex')\n            }\n          });\n        }\n        _npmlog2.default.verbose(LOG_PREFIX, 'APNS Connection %d Notification transmitted to %s', conn.index, device.token.toString('hex'));\n      });\n\n      _this.conns.push(conn);\n    };\n\n    for (var _iterator = apnsArgsList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      _loop();\n    }\n    // Sort the conn based on priority ascending, high pri first\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  this.conns.sort(function (s1, s2) {\n    return s1.priority - s2.priority;\n  });\n  // Set index of conns\n  for (var index = 0; index < this.conns.length; index++) {\n    this.conns[index].index = index;\n  }\n}\n\n/**\n * Send apns request.\n * @param {Object} data The data we need to send, the format is the same with api request body\n * @param {Array} devices A array of devices\n * @returns {Object} A promise which is resolved immediately\n */\nAPNS.prototype.send = function (data, devices) {\n  var _this2 = this;\n\n  var coreData = data.data;\n  var expirationTime = data['expiration_time'];\n  var notification = generateNotification(coreData, expirationTime);\n  var allPromises = [];\n  var devicesPerConnIndex = {};\n  // Start by clustering the devices per connections\n  devices.forEach(function (device) {\n    var qualifiedConnIndexs = chooseConns(_this2.conns, device);\n    if (qualifiedConnIndexs.length == 0) {\n      _npmlog2.default.error(LOG_PREFIX, 'no qualified connections for %s %s', device.appIdentifier, device.deviceToken);\n      var promise = Promise.resolve({\n        transmitted: false,\n        device: {\n          deviceToken: device.deviceToken,\n          deviceType: device.deviceType\n        },\n        result: { error: 'No connection available' }\n      });\n      allPromises.push(promise);\n    } else {\n      var apnDevice = new _apn2.default.Device(device.deviceToken);\n      apnDevice.connIndex = qualifiedConnIndexs[0];\n      if (device.appIdentifier) {\n        apnDevice.appIdentifier = device.appIdentifier;\n      }\n      devicesPerConnIndex[apnDevice.connIndex] = devicesPerConnIndex[apnDevice.connIndex] || [];\n      devicesPerConnIndex[apnDevice.connIndex].push(apnDevice);\n    }\n  });\n\n  allPromises = Object.keys(devicesPerConnIndex).reduce(function (memo, connIndex) {\n    var devices = devicesPerConnIndex[connIndex];\n    // Create a promise, attach the callback\n    var promises = devices.map(function (apnDevice) {\n      return new Promise(function (resolve, reject) {\n        apnDevice.callback = resolve;\n      });\n    });\n    var conn = _this2.conns[connIndex];\n    conn.pushNotification(notification, devices);\n    return memo.concat(promises);\n  }, allPromises);\n\n  return Promise.all(allPromises);\n};\n\nfunction handleTransmissionError(conns, errCode, notification, apnDevice) {\n  // This means the error notification is not in the cache anymore or the recepient is missing,\n  // we just ignore this case\n  if (!notification || !apnDevice) {\n    return;\n  }\n\n  // If currentConn can not send the push notification, we try to use the next available conn.\n  // Since conns is sorted by priority, the next conn means the next low pri conn.\n  // If there is no conn available, we give up on sending the notification to that device.\n  var qualifiedConnIndexs = chooseConns(conns, apnDevice);\n  var currentConnIndex = apnDevice.connIndex;\n\n  var newConnIndex = -1;\n  // Find the next element of currentConnIndex in qualifiedConnIndexs\n  for (var index = 0; index < qualifiedConnIndexs.length - 1; index++) {\n    if (qualifiedConnIndexs[index] === currentConnIndex) {\n      newConnIndex = qualifiedConnIndexs[index + 1];\n      break;\n    }\n  }\n  // There is no more available conns, we give up in this case\n  if (newConnIndex < 0 || newConnIndex >= conns.length) {\n    if (apnDevice.callback) {\n      _npmlog2.default.error(LOG_PREFIX, 'cannot find vaild connection for ' + apnDevice.token.toString('hex'));\n      apnDevice.callback({\n        response: { error: 'APNS can not find vaild connection for ' + apnDevice.token.toString('hex'), code: errCode },\n        status: errCode,\n        transmitted: false,\n        device: {\n          deviceType: apnDevice.deviceType,\n          deviceToken: apnDevice.token.toString('hex')\n        }\n      });\n    }\n    return;\n  }\n\n  var newConn = conns[newConnIndex];\n  // Update device conn info\n  apnDevice.connIndex = newConnIndex;\n  // Use the new conn to send the notification\n  newConn.pushNotification(notification, apnDevice);\n}\n\nfunction chooseConns(conns, device) {\n  // If device does not have appIdentifier, all conns maybe proper connections.\n  // Otherwise we try to match the appIdentifier with bundleId\n  var qualifiedConns = [];\n  for (var index = 0; index < conns.length; index++) {\n    var _conn = conns[index];\n    // If the device we need to send to does not have\n    // appIdentifier, any conn could be a qualified connection\n    if (!device.appIdentifier || device.appIdentifier === '') {\n      qualifiedConns.push(index);\n      continue;\n    }\n    if (device.appIdentifier === _conn.bundleId) {\n      qualifiedConns.push(index);\n    }\n  }\n  return qualifiedConns;\n}\n\n/**\n * Generate the apns notification from the data we get from api request.\n * @param {Object} coreData The data field under api request body\n * @param {number} expirationTime The expiration time in milliseconds since Jan 1 1970\n * @returns {Object} A apns notification\n */\nfunction generateNotification(coreData, expirationTime) {\n  var notification = new _apn2.default.notification();\n  var payload = {};\n  for (var key in coreData) {\n    switch (key) {\n      case 'alert':\n        notification.setAlertText(coreData.alert);\n        break;\n      case 'badge':\n        notification.badge = coreData.badge;\n        break;\n      case 'sound':\n        notification.sound = coreData.sound;\n        break;\n      case 'content-available':\n        notification.setNewsstandAvailable(true);\n        var isAvailable = coreData['content-available'] === 1;\n        notification.setContentAvailable(isAvailable);\n        break;\n      case 'mutable-content':\n        var isMutable = coreData['mutable-content'] === 1;\n        notification.setMutableContent(isMutable);\n        break;\n      case 'category':\n        notification.category = coreData.category;\n        break;\n      default:\n        payload[key] = coreData[key];\n        break;\n    }\n  }\n  notification.payload = payload;\n  notification.expiry = expirationTime / 1000;\n  return notification;\n}\n\nAPNS.generateNotification = generateNotification;\n\nif (process.env.TESTING) {\n  APNS.chooseConns = chooseConns;\n  APNS.handleTransmissionError = handleTransmissionError;\n}\nmodule.exports = APNS;\nexports.default = APNS;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server-push-adapter/lib/GCM.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _parse = require('parse');\n\nvar _parse2 = _interopRequireDefault(_parse);\n\nvar _npmlog = require('npmlog');\n\nvar _npmlog2 = _interopRequireDefault(_npmlog);\n\nvar _nodeGcm = require('node-gcm');\n\nvar _nodeGcm2 = _interopRequireDefault(_nodeGcm);\n\nvar _PushAdapterUtils = require('./PushAdapterUtils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar LOG_PREFIX = 'parse-server-push-adapter GCM';\nvar GCMTimeToLiveMax = 4 * 7 * 24 * 60 * 60; // GCM allows a max of 4 weeks\nvar GCMRegistrationTokensMax = 1000;\n\nfunction GCM(args) {\n  if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) !== 'object' || !args.apiKey) {\n    throw new _parse2.default.Error(_parse2.default.Error.PUSH_MISCONFIGURED, 'GCM Configuration is invalid');\n  }\n  this.sender = new _nodeGcm2.default.Sender(args.apiKey);\n}\n\n/**\n * Send gcm request.\n * @param {Object} data The data we need to send, the format is the same with api request body\n * @param {Array} devices A array of devices\n * @returns {Object} A promise which is resolved after we get results from gcm\n */\nGCM.prototype.send = function (data, devices) {\n  var _this = this;\n\n  var pushId = (0, _PushAdapterUtils.randomString)(10);\n  // Make a new array\n  devices = devices.slice(0);\n  var timestamp = Date.now();\n  // For android, we can only have 1000 recepients per send, so we need to slice devices to\n  // chunk if necessary\n  var slices = sliceDevices(devices, GCMRegistrationTokensMax);\n  if (slices.length > 1) {\n    _npmlog2.default.verbose(LOG_PREFIX, 'the number of devices exceeds ' + GCMRegistrationTokensMax);\n    // Make 1 send per slice\n    var _promises = slices.reduce(function (memo, slice) {\n      var promise = _this.send(data, slice, timestamp);\n      memo.push(promise);\n      return memo;\n    }, []);\n    return _parse2.default.Promise.when(_promises).then(function (results) {\n      var allResults = results.reduce(function (memo, result) {\n        return memo.concat(result);\n      }, []);\n      return _parse2.default.Promise.as(allResults);\n    });\n  }\n  // get the devices back...\n  devices = slices[0];\n\n  var expirationTime = void 0;\n  // We handle the expiration_time convertion in push.js, so expiration_time is a valid date\n  // in Unix epoch time in milliseconds here\n  if (data['expiration_time']) {\n    expirationTime = data['expiration_time'];\n  }\n  // Generate gcm payload\n  // PushId is not a formal field of GCM, but Parse Android SDK uses this field to deduplicate push notifications\n  var gcmPayload = generateGCMPayload(data, pushId, timestamp, expirationTime);\n  // Make and send gcm request\n  var message = new _nodeGcm2.default.Message(gcmPayload);\n\n  // Build a device map\n  var devicesMap = devices.reduce(function (memo, device) {\n    memo[device.deviceToken] = device;\n    return memo;\n  }, {});\n\n  var deviceTokens = Object.keys(devicesMap);\n\n  var promises = deviceTokens.map(function () {\n    return new _parse2.default.Promise();\n  });\n  var registrationTokens = deviceTokens;\n  var length = registrationTokens.length;\n  _npmlog2.default.verbose(LOG_PREFIX, 'sending to ' + length + ' ' + (length > 1 ? 'devices' : 'device'));\n  this.sender.send(message, { registrationTokens: registrationTokens }, 5, function (error, response) {\n    // example response:\n    /*\n    {  \"multicast_id\":7680139367771848000,\n      \"success\":0,\n      \"failure\":4,\n      \"canonical_ids\":0,\n      \"results\":[ {\"error\":\"InvalidRegistration\"},\n        {\"error\":\"InvalidRegistration\"},\n        {\"error\":\"InvalidRegistration\"},\n        {\"error\":\"InvalidRegistration\"}] }\n    */\n    if (error) {\n      _npmlog2.default.error(LOG_PREFIX, 'send errored: %s', JSON.stringify(error, null, 4));\n    } else {\n      _npmlog2.default.verbose(LOG_PREFIX, 'GCM Response: %s', JSON.stringify(response, null, 4));\n    }\n\n    var _ref = response || {},\n        results = _ref.results,\n        multicast_id = _ref.multicast_id;\n\n    registrationTokens.forEach(function (token, index) {\n      var promise = promises[index];\n      var result = results ? results[index] : undefined;\n      var device = devicesMap[token];\n      device.deviceType = 'android';\n      var resolution = {\n        device: device,\n        multicast_id: multicast_id,\n        response: error || result\n      };\n      if (!result || result.error) {\n        resolution.transmitted = false;\n      } else {\n        resolution.transmitted = true;\n      }\n      promise.resolve(resolution);\n    });\n  });\n  return _parse2.default.Promise.when(promises);\n};\n\n/**\n * Generate the gcm payload from the data we get from api request.\n * @param {Object} requestData The request body\n * @param {String} pushId A random string\n * @param {Number} timeStamp A number whose format is the Unix Epoch\n * @param {Number|undefined} expirationTime A number whose format is the Unix Epoch or undefined\n * @returns {Object} A promise which is resolved after we get results from gcm\n */\nfunction generateGCMPayload(requestData, pushId, timeStamp, expirationTime) {\n  var payload = {\n    priority: 'high'\n  };\n  payload.data = {\n    data: requestData.data,\n    push_id: pushId,\n    time: new Date(timeStamp).toISOString()\n  };\n  if (requestData.content_available) {\n    payload.content_available = requestData.content_available;\n  }\n  if (requestData.notification) {\n    payload.notification = requestData.notification;\n  }\n  if (expirationTime) {\n    // The timeStamp and expiration is in milliseconds but gcm requires second\n    var timeToLive = Math.floor((expirationTime - timeStamp) / 1000);\n    if (timeToLive < 0) {\n      timeToLive = 0;\n    }\n    if (timeToLive >= GCMTimeToLiveMax) {\n      timeToLive = GCMTimeToLiveMax;\n    }\n    payload.timeToLive = timeToLive;\n  }\n  return payload;\n}\n\n/**\n * Slice a list of devices to several list of devices with fixed chunk size.\n * @param {Array} devices An array of devices\n * @param {Number} chunkSize The size of the a chunk\n * @returns {Array} An array which contaisn several arries of devices with fixed chunk size\n */\nfunction sliceDevices(devices, chunkSize) {\n  var chunkDevices = [];\n  while (devices.length > 0) {\n    chunkDevices.push(devices.splice(0, chunkSize));\n  }\n  return chunkDevices;\n}\n\nGCM.generateGCMPayload = generateGCMPayload;\n\nif (process.env.TESTING) {\n  GCM.sliceDevices = sliceDevices;\n}\n\nmodule.exports = GCM;\nexports.default = GCM;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server-push-adapter/lib/PushAdapterUtils.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.classifyInstallations = classifyInstallations;\nexports.randomString = randomString;\n\nvar _crypto = require('crypto');\n\n/**g\n   * Classify the device token of installations based on its device type.\n   * @param {Object} installations An array of installations\n   * @param {Array} validPushTypes An array of valid push types(string)\n   * @returns {Object} A map whose key is device type and value is an array of device\n   */\nfunction classifyInstallations(installations, validPushTypes) {\n  // Init deviceTokenMap, create a empty array for each valid pushType\n  var deviceMap = {};\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = validPushTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var validPushType = _step.value;\n\n      deviceMap[validPushType] = [];\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = installations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var installation = _step2.value;\n\n      // No deviceToken, ignore\n      if (!installation.deviceToken) {\n        continue;\n      }\n      var devices = deviceMap[installation.pushType] || deviceMap[installation.deviceType] || null;\n      if (Array.isArray(devices)) {\n        devices.push({\n          deviceToken: installation.deviceToken,\n          deviceType: installation.deviceType,\n          appIdentifier: installation.appIdentifier\n        });\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return deviceMap;\n}\n\nfunction randomString(size) {\n  if (size === 0) {\n    throw new Error('Zero-length randomString is useless.');\n  }\n  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789';\n  var objectId = '';\n  var bytes = (0, _crypto.randomBytes)(size);\n  for (var i = 0; i < bytes.length; ++i) {\n    objectId += chars[bytes.readUInt8(i) % chars.length];\n  }\n  return objectId;\n}","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Storage/Mongo/MongoStorageAdapter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MongoStorageAdapter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _MongoCollection = require('./MongoCollection');\n\nvar _MongoCollection2 = _interopRequireDefault(_MongoCollection);\n\nvar _MongoSchemaCollection = require('./MongoSchemaCollection');\n\nvar _MongoSchemaCollection2 = _interopRequireDefault(_MongoSchemaCollection);\n\nvar _mongodbUrl = require('../../../vendor/mongodbUrl');\n\nvar _MongoTransform = require('./MongoTransform');\n\nvar _node = require('parse/node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _defaults = require('../../../defaults');\n\nvar _defaults2 = _interopRequireDefault(_defaults);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nvar mongodb = require('mongodb');\nvar MongoClient = mongodb.MongoClient;\n\nvar MongoSchemaCollectionName = '_SCHEMA';\n\nvar storageAdapterAllCollections = function storageAdapterAllCollections(mongoAdapter) {\n  return mongoAdapter.connect().then(function () {\n    return mongoAdapter.database.collections();\n  }).then(function (collections) {\n    return collections.filter(function (collection) {\n      if (collection.namespace.match(/\\.system\\./)) {\n        return false;\n      }\n      // TODO: If you have one app with a collection prefix that happens to be a prefix of another\n      // apps prefix, this will go very very badly. We should fix that somehow.\n      return collection.collectionName.indexOf(mongoAdapter._collectionPrefix) == 0;\n    });\n  });\n};\n\nvar convertParseSchemaToMongoSchema = function convertParseSchemaToMongoSchema(_ref) {\n  var schema = _objectWithoutProperties(_ref, []);\n\n  delete schema.fields._rperm;\n  delete schema.fields._wperm;\n\n  if (schema.className === '_User') {\n    // Legacy mongo adapter knows about the difference between password and _hashed_password.\n    // Future database adapters will only know about _hashed_password.\n    // Note: Parse Server will bring back password with injectDefaultSchema, so we don't need\n    // to add _hashed_password back ever.\n    delete schema.fields._hashed_password;\n  }\n\n  return schema;\n};\n\n// Returns { code, error } if invalid, or { result }, an object\n// suitable for inserting into _SCHEMA collection, otherwise.\nvar mongoSchemaFromFieldsAndClassNameAndCLP = function mongoSchemaFromFieldsAndClassNameAndCLP(fields, className, classLevelPermissions) {\n  var mongoObject = {\n    _id: className,\n    objectId: 'string',\n    updatedAt: 'string',\n    createdAt: 'string'\n  };\n\n  for (var fieldName in fields) {\n    mongoObject[fieldName] = _MongoSchemaCollection2.default.parseFieldTypeToMongoFieldType(fields[fieldName]);\n  }\n\n  if (typeof classLevelPermissions !== 'undefined') {\n    mongoObject._metadata = mongoObject._metadata || {};\n    if (!classLevelPermissions) {\n      delete mongoObject._metadata.class_permissions;\n    } else {\n      mongoObject._metadata.class_permissions = classLevelPermissions;\n    }\n  }\n\n  return mongoObject;\n};\n\nvar MongoStorageAdapter = exports.MongoStorageAdapter = function () {\n  // Public\n  function MongoStorageAdapter(_ref2) {\n    var _ref2$uri = _ref2.uri,\n        uri = _ref2$uri === undefined ? _defaults2.default.DefaultMongoURI : _ref2$uri,\n        _ref2$collectionPrefi = _ref2.collectionPrefix,\n        collectionPrefix = _ref2$collectionPrefi === undefined ? '' : _ref2$collectionPrefi,\n        _ref2$mongoOptions = _ref2.mongoOptions,\n        mongoOptions = _ref2$mongoOptions === undefined ? {} : _ref2$mongoOptions;\n\n    _classCallCheck(this, MongoStorageAdapter);\n\n    this._uri = uri;\n    this._collectionPrefix = collectionPrefix;\n    this._mongoOptions = mongoOptions;\n\n    // MaxTimeMS is not a global MongoDB client option, it is applied per operation.\n    this._maxTimeMS = mongoOptions.maxTimeMS;\n    process.on('SIGTERM', this.handleShutdown(this));\n    process.on('SIGINT', this.handleShutdown(this));\n  }\n  // Private\n\n\n  _createClass(MongoStorageAdapter, [{\n    key: 'handleShutdown',\n    value: function handleShutdown(storageAdapter) {\n      return function () {\n        if (!storageAdapter.database) {\n          return;\n        }\n        storageAdapter.database.close(false);\n      };\n    }\n  }, {\n    key: 'connect',\n    value: function connect() {\n      var _this = this;\n\n      if (this.connectionPromise) {\n        return this.connectionPromise;\n      }\n\n      // parsing and re-formatting causes the auth value (if there) to get URI\n      // encoded\n      var encodedUri = (0, _mongodbUrl.format)((0, _mongodbUrl.parse)(this._uri));\n\n      this.connectionPromise = MongoClient.connect(encodedUri, this._mongoOptions).then(function (database) {\n        if (!database) {\n          delete _this.connectionPromise;\n          return;\n        }\n        database.on('error', function () {\n          delete _this.connectionPromise;\n        });\n        database.on('close', function () {\n          delete _this.connectionPromise;\n        });\n        _this.database = database;\n      }).catch(function (err) {\n        delete _this.connectionPromise;\n        return Promise.reject(err);\n      });\n\n      return this.connectionPromise;\n    }\n  }, {\n    key: '_adaptiveCollection',\n    value: function _adaptiveCollection(name) {\n      var _this2 = this;\n\n      return this.connect().then(function () {\n        return _this2.database.collection(_this2._collectionPrefix + name);\n      }).then(function (rawCollection) {\n        return new _MongoCollection2.default(rawCollection);\n      });\n    }\n  }, {\n    key: '_schemaCollection',\n    value: function _schemaCollection() {\n      var _this3 = this;\n\n      return this.connect().then(function () {\n        return _this3._adaptiveCollection(MongoSchemaCollectionName);\n      }).then(function (collection) {\n        return new _MongoSchemaCollection2.default(collection);\n      });\n    }\n  }, {\n    key: 'classExists',\n    value: function classExists(name) {\n      var _this4 = this;\n\n      return this.connect().then(function () {\n        return _this4.database.listCollections({ name: _this4._collectionPrefix + name }).toArray();\n      }).then(function (collections) {\n        return collections.length > 0;\n      });\n    }\n  }, {\n    key: 'setClassLevelPermissions',\n    value: function setClassLevelPermissions(className, CLPs) {\n      return this._schemaCollection().then(function (schemaCollection) {\n        return schemaCollection.updateSchema(className, {\n          $set: { _metadata: { class_permissions: CLPs } }\n        });\n      });\n    }\n  }, {\n    key: 'createClass',\n    value: function createClass(className, schema) {\n      schema = convertParseSchemaToMongoSchema(schema);\n      var mongoObject = mongoSchemaFromFieldsAndClassNameAndCLP(schema.fields, className, schema.classLevelPermissions);\n      mongoObject._id = className;\n      return this._schemaCollection().then(function (schemaCollection) {\n        return schemaCollection._collection.insertOne(mongoObject);\n      }).then(function (result) {\n        return _MongoSchemaCollection2.default._TESTmongoSchemaToParseSchema(result.ops[0]);\n      }).catch(function (error) {\n        if (error.code === 11000) {\n          //Mongo's duplicate key error\n          throw new _node2.default.Error(_node2.default.Error.DUPLICATE_VALUE, 'Class already exists.');\n        } else {\n          throw error;\n        }\n      });\n    }\n  }, {\n    key: 'addFieldIfNotExists',\n    value: function addFieldIfNotExists(className, fieldName, type) {\n      return this._schemaCollection().then(function (schemaCollection) {\n        return schemaCollection.addFieldIfNotExists(className, fieldName, type);\n      });\n    }\n\n    // Drops a collection. Resolves with true if it was a Parse Schema (eg. _User, Custom, etc.)\n    // and resolves with false if it wasn't (eg. a join table). Rejects if deletion was impossible.\n\n  }, {\n    key: 'deleteClass',\n    value: function deleteClass(className) {\n      var _this5 = this;\n\n      return this._adaptiveCollection(className).then(function (collection) {\n        return collection.drop();\n      }).catch(function (error) {\n        // 'ns not found' means collection was already gone. Ignore deletion attempt.\n        if (error.message == 'ns not found') {\n          return;\n        }\n        throw error;\n      })\n      // We've dropped the collection, now remove the _SCHEMA document\n      .then(function () {\n        return _this5._schemaCollection();\n      }).then(function (schemaCollection) {\n        return schemaCollection.findAndDeleteSchema(className);\n      });\n    }\n\n    // Delete all data known to this adatper. Used for testing.\n\n  }, {\n    key: 'deleteAllClasses',\n    value: function deleteAllClasses() {\n      return storageAdapterAllCollections(this).then(function (collections) {\n        return Promise.all(collections.map(function (collection) {\n          return collection.drop();\n        }));\n      });\n    }\n\n    // Remove the column and all the data. For Relations, the _Join collection is handled\n    // specially, this function does not delete _Join columns. It should, however, indicate\n    // that the relation fields does not exist anymore. In mongo, this means removing it from\n    // the _SCHEMA collection.  There should be no actual data in the collection under the same name\n    // as the relation column, so it's fine to attempt to delete it. If the fields listed to be\n    // deleted do not exist, this function should return successfully anyways. Checking for\n    // attempts to delete non-existent fields is the responsibility of Parse Server.\n\n    // Pointer field names are passed for legacy reasons: the original mongo\n    // format stored pointer field names differently in the database, and therefore\n    // needed to know the type of the field before it could delete it. Future database\n    // adatpers should ignore the pointerFieldNames argument. All the field names are in\n    // fieldNames, they show up additionally in the pointerFieldNames database for use\n    // by the mongo adapter, which deals with the legacy mongo format.\n\n    // This function is not obligated to delete fields atomically. It is given the field\n    // names in a list so that databases that are capable of deleting fields atomically\n    // may do so.\n\n    // Returns a Promise.\n\n  }, {\n    key: 'deleteFields',\n    value: function deleteFields(className, schema, fieldNames) {\n      var _this6 = this;\n\n      var mongoFormatNames = fieldNames.map(function (fieldName) {\n        if (schema.fields[fieldName].type === 'Pointer') {\n          return '_p_' + fieldName;\n        } else {\n          return fieldName;\n        }\n      });\n      var collectionUpdate = { '$unset': {} };\n      mongoFormatNames.forEach(function (name) {\n        collectionUpdate['$unset'][name] = null;\n      });\n\n      var schemaUpdate = { '$unset': {} };\n      fieldNames.forEach(function (name) {\n        schemaUpdate['$unset'][name] = null;\n      });\n\n      return this._adaptiveCollection(className).then(function (collection) {\n        return collection.updateMany({}, collectionUpdate);\n      }).then(function () {\n        return _this6._schemaCollection();\n      }).then(function (schemaCollection) {\n        return schemaCollection.updateSchema(className, schemaUpdate);\n      });\n    }\n\n    // Return a promise for all schemas known to this adapter, in Parse format. In case the\n    // schemas cannot be retrieved, returns a promise that rejects. Requirements for the\n    // rejection reason are TBD.\n\n  }, {\n    key: 'getAllClasses',\n    value: function getAllClasses() {\n      return this._schemaCollection().then(function (schemasCollection) {\n        return schemasCollection._fetchAllSchemasFrom_SCHEMA();\n      });\n    }\n\n    // Return a promise for the schema with the given name, in Parse format. If\n    // this adapter doesn't know about the schema, return a promise that rejects with\n    // undefined as the reason.\n\n  }, {\n    key: 'getClass',\n    value: function getClass(className) {\n      return this._schemaCollection().then(function (schemasCollection) {\n        return schemasCollection._fechOneSchemaFrom_SCHEMA(className);\n      });\n    }\n\n    // TODO: As yet not particularly well specified. Creates an object. Maybe shouldn't even need the schema,\n    // and should infer from the type. Or maybe does need the schema for validations. Or maybe needs\n    // the schem only for the legacy mongo format. We'll figure that out later.\n\n  }, {\n    key: 'createObject',\n    value: function createObject(className, schema, object) {\n      schema = convertParseSchemaToMongoSchema(schema);\n      var mongoObject = (0, _MongoTransform.parseObjectToMongoObjectForCreate)(className, object, schema);\n      return this._adaptiveCollection(className).then(function (collection) {\n        return collection.insertOne(mongoObject);\n      }).catch(function (error) {\n        if (error.code === 11000) {\n          // Duplicate value\n          throw new _node2.default.Error(_node2.default.Error.DUPLICATE_VALUE, 'A duplicate value for a field with unique values was provided');\n        }\n        throw error;\n      });\n    }\n\n    // Remove all objects that match the given Parse Query.\n    // If no objects match, reject with OBJECT_NOT_FOUND. If objects are found and deleted, resolve with undefined.\n    // If there is some other error, reject with INTERNAL_SERVER_ERROR.\n\n  }, {\n    key: 'deleteObjectsByQuery',\n    value: function deleteObjectsByQuery(className, schema, query) {\n      schema = convertParseSchemaToMongoSchema(schema);\n      return this._adaptiveCollection(className).then(function (collection) {\n        var mongoWhere = (0, _MongoTransform.transformWhere)(className, query, schema);\n        return collection.deleteMany(mongoWhere);\n      }).then(function (_ref3) {\n        var result = _ref3.result;\n\n        if (result.n === 0) {\n          throw new _node2.default.Error(_node2.default.Error.OBJECT_NOT_FOUND, 'Object not found.');\n        }\n        return Promise.resolve();\n      }, function () {\n        throw new _node2.default.Error(_node2.default.Error.INTERNAL_SERVER_ERROR, 'Database adapter error');\n      });\n    }\n\n    // Apply the update to all objects that match the given Parse Query.\n\n  }, {\n    key: 'updateObjectsByQuery',\n    value: function updateObjectsByQuery(className, schema, query, update) {\n      schema = convertParseSchemaToMongoSchema(schema);\n      var mongoUpdate = (0, _MongoTransform.transformUpdate)(className, update, schema);\n      var mongoWhere = (0, _MongoTransform.transformWhere)(className, query, schema);\n      return this._adaptiveCollection(className).then(function (collection) {\n        return collection.updateMany(mongoWhere, mongoUpdate);\n      });\n    }\n\n    // Atomically finds and updates an object based on query.\n    // Return value not currently well specified.\n\n  }, {\n    key: 'findOneAndUpdate',\n    value: function findOneAndUpdate(className, schema, query, update) {\n      schema = convertParseSchemaToMongoSchema(schema);\n      var mongoUpdate = (0, _MongoTransform.transformUpdate)(className, update, schema);\n      var mongoWhere = (0, _MongoTransform.transformWhere)(className, query, schema);\n      return this._adaptiveCollection(className).then(function (collection) {\n        return collection._mongoCollection.findAndModify(mongoWhere, [], mongoUpdate, { new: true });\n      }).then(function (result) {\n        return (0, _MongoTransform.mongoObjectToParseObject)(className, result.value, schema);\n      });\n    }\n\n    // Hopefully we can get rid of this. It's only used for config and hooks.\n\n  }, {\n    key: 'upsertOneObject',\n    value: function upsertOneObject(className, schema, query, update) {\n      schema = convertParseSchemaToMongoSchema(schema);\n      var mongoUpdate = (0, _MongoTransform.transformUpdate)(className, update, schema);\n      var mongoWhere = (0, _MongoTransform.transformWhere)(className, query, schema);\n      return this._adaptiveCollection(className).then(function (collection) {\n        return collection.upsertOne(mongoWhere, mongoUpdate);\n      });\n    }\n\n    // Executes a find. Accepts: className, query in Parse format, and { skip, limit, sort }.\n\n  }, {\n    key: 'find',\n    value: function find(className, schema, query, _ref4) {\n      var _this7 = this;\n\n      var skip = _ref4.skip,\n          limit = _ref4.limit,\n          sort = _ref4.sort,\n          keys = _ref4.keys;\n\n      schema = convertParseSchemaToMongoSchema(schema);\n      var mongoWhere = (0, _MongoTransform.transformWhere)(className, query, schema);\n      var mongoSort = _lodash2.default.mapKeys(sort, function (value, fieldName) {\n        return (0, _MongoTransform.transformKey)(className, fieldName, schema);\n      });\n      var mongoKeys = _lodash2.default.reduce(keys, function (memo, key) {\n        memo[(0, _MongoTransform.transformKey)(className, key, schema)] = 1;\n        return memo;\n      }, {});\n      return this._adaptiveCollection(className).then(function (collection) {\n        return collection.find(mongoWhere, {\n          skip: skip,\n          limit: limit,\n          sort: mongoSort,\n          keys: mongoKeys,\n          maxTimeMS: _this7._maxTimeMS\n        });\n      }).then(function (objects) {\n        return objects.map(function (object) {\n          return (0, _MongoTransform.mongoObjectToParseObject)(className, object, schema);\n        });\n      });\n    }\n\n    // Create a unique index. Unique indexes on nullable fields are not allowed. Since we don't\n    // currently know which fields are nullable and which aren't, we ignore that criteria.\n    // As such, we shouldn't expose this function to users of parse until we have an out-of-band\n    // Way of determining if a field is nullable. Undefined doesn't count against uniqueness,\n    // which is why we use sparse indexes.\n\n  }, {\n    key: 'ensureUniqueness',\n    value: function ensureUniqueness(className, schema, fieldNames) {\n      schema = convertParseSchemaToMongoSchema(schema);\n      var indexCreationRequest = {};\n      var mongoFieldNames = fieldNames.map(function (fieldName) {\n        return (0, _MongoTransform.transformKey)(className, fieldName, schema);\n      });\n      mongoFieldNames.forEach(function (fieldName) {\n        indexCreationRequest[fieldName] = 1;\n      });\n      return this._adaptiveCollection(className).then(function (collection) {\n        return collection._ensureSparseUniqueIndexInBackground(indexCreationRequest);\n      }).catch(function (error) {\n        if (error.code === 11000) {\n          throw new _node2.default.Error(_node2.default.Error.DUPLICATE_VALUE, 'Tried to ensure field uniqueness for a class that already has duplicates.');\n        } else {\n          throw error;\n        }\n      });\n    }\n\n    // Used in tests\n\n  }, {\n    key: '_rawFind',\n    value: function _rawFind(className, query) {\n      var _this8 = this;\n\n      return this._adaptiveCollection(className).then(function (collection) {\n        return collection.find(query, {\n          maxTimeMS: _this8._maxTimeMS\n        });\n      });\n    }\n\n    // Executes a count.\n\n  }, {\n    key: 'count',\n    value: function count(className, schema, query) {\n      var _this9 = this;\n\n      schema = convertParseSchemaToMongoSchema(schema);\n      return this._adaptiveCollection(className).then(function (collection) {\n        return collection.count((0, _MongoTransform.transformWhere)(className, query, schema), {\n          maxTimeMS: _this9._maxTimeMS\n        });\n      });\n    }\n  }, {\n    key: 'performInitialization',\n    value: function performInitialization() {\n      return Promise.resolve();\n    }\n  }]);\n\n  return MongoStorageAdapter;\n}();\n\nexports.default = MongoStorageAdapter;\n\nmodule.exports = MongoStorageAdapter; // Required for tests","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Storage/Mongo/MongoCollection.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar mongodb = require('mongodb');\nvar Collection = mongodb.Collection;\n\nvar MongoCollection = function () {\n  function MongoCollection(mongoCollection) {\n    _classCallCheck(this, MongoCollection);\n\n    this._mongoCollection = mongoCollection;\n  }\n\n  // Does a find with \"smart indexing\".\n  // Currently this just means, if it needs a geoindex and there is\n  // none, then build the geoindex.\n  // This could be improved a lot but it's not clear if that's a good\n  // idea. Or even if this behavior is a good idea.\n\n\n  _createClass(MongoCollection, [{\n    key: 'find',\n    value: function find(query) {\n      var _this = this;\n\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          skip = _ref.skip,\n          limit = _ref.limit,\n          sort = _ref.sort,\n          keys = _ref.keys,\n          maxTimeMS = _ref.maxTimeMS;\n\n      return this._rawFind(query, { skip: skip, limit: limit, sort: sort, keys: keys, maxTimeMS: maxTimeMS }).catch(function (error) {\n        // Check for \"no geoindex\" error\n        if (error.code != 17007 && !error.message.match(/unable to find index for .geoNear/)) {\n          throw error;\n        }\n        // Figure out what key needs an index\n        var key = error.message.match(/field=([A-Za-z_0-9]+) /)[1];\n        if (!key) {\n          throw error;\n        }\n\n        var index = {};\n        index[key] = '2d';\n        return _this._mongoCollection.createIndex(index)\n        // Retry, but just once.\n        .then(function () {\n          return _this._rawFind(query, { skip: skip, limit: limit, sort: sort, keys: keys, maxTimeMS: maxTimeMS });\n        });\n      });\n    }\n  }, {\n    key: '_rawFind',\n    value: function _rawFind(query) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          skip = _ref2.skip,\n          limit = _ref2.limit,\n          sort = _ref2.sort,\n          keys = _ref2.keys,\n          maxTimeMS = _ref2.maxTimeMS;\n\n      var findOperation = this._mongoCollection.find(query, { skip: skip, limit: limit, sort: sort });\n\n      if (keys) {\n        findOperation = findOperation.project(keys);\n      }\n\n      if (maxTimeMS) {\n        findOperation = findOperation.maxTimeMS(maxTimeMS);\n      }\n\n      return findOperation.toArray();\n    }\n  }, {\n    key: 'count',\n    value: function count(query) {\n      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          skip = _ref3.skip,\n          limit = _ref3.limit,\n          sort = _ref3.sort,\n          maxTimeMS = _ref3.maxTimeMS;\n\n      var countOperation = this._mongoCollection.count(query, { skip: skip, limit: limit, sort: sort, maxTimeMS: maxTimeMS });\n\n      return countOperation;\n    }\n  }, {\n    key: 'insertOne',\n    value: function insertOne(object) {\n      return this._mongoCollection.insertOne(object);\n    }\n\n    // Atomically updates data in the database for a single (first) object that matched the query\n    // If there is nothing that matches the query - does insert\n    // Postgres Note: `INSERT ... ON CONFLICT UPDATE` that is available since 9.5.\n\n  }, {\n    key: 'upsertOne',\n    value: function upsertOne(query, update) {\n      return this._mongoCollection.update(query, update, { upsert: true });\n    }\n  }, {\n    key: 'updateOne',\n    value: function updateOne(query, update) {\n      return this._mongoCollection.updateOne(query, update);\n    }\n  }, {\n    key: 'updateMany',\n    value: function updateMany(query, update) {\n      return this._mongoCollection.updateMany(query, update);\n    }\n  }, {\n    key: 'deleteOne',\n    value: function deleteOne(query) {\n      return this._mongoCollection.deleteOne(query);\n    }\n  }, {\n    key: 'deleteMany',\n    value: function deleteMany(query) {\n      return this._mongoCollection.deleteMany(query);\n    }\n  }, {\n    key: '_ensureSparseUniqueIndexInBackground',\n    value: function _ensureSparseUniqueIndexInBackground(indexRequest) {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this2._mongoCollection.ensureIndex(indexRequest, { unique: true, background: true, sparse: true }, function (error) {\n          if (error) {\n            reject(error);\n          } else {\n            resolve();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'drop',\n    value: function drop() {\n      return this._mongoCollection.drop();\n    }\n  }]);\n\n  return MongoCollection;\n}();\n\nexports.default = MongoCollection;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Storage/Mongo/MongoSchemaCollection.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _MongoCollection = require('./MongoCollection');\n\nvar _MongoCollection2 = _interopRequireDefault(_MongoCollection);\n\nvar _node = require('parse/node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction mongoFieldToParseSchemaField(type) {\n  if (type[0] === '*') {\n    return {\n      type: 'Pointer',\n      targetClass: type.slice(1)\n    };\n  }\n  if (type.startsWith('relation<')) {\n    return {\n      type: 'Relation',\n      targetClass: type.slice('relation<'.length, type.length - 1)\n    };\n  }\n  switch (type) {\n    case 'number':\n      return { type: 'Number' };\n    case 'string':\n      return { type: 'String' };\n    case 'boolean':\n      return { type: 'Boolean' };\n    case 'date':\n      return { type: 'Date' };\n    case 'map':\n    case 'object':\n      return { type: 'Object' };\n    case 'array':\n      return { type: 'Array' };\n    case 'geopoint':\n      return { type: 'GeoPoint' };\n    case 'file':\n      return { type: 'File' };\n    case 'bytes':\n      return { type: 'Bytes' };\n  }\n}\n\nvar nonFieldSchemaKeys = ['_id', '_metadata', '_client_permissions'];\nfunction mongoSchemaFieldsToParseSchemaFields(schema) {\n  var fieldNames = Object.keys(schema).filter(function (key) {\n    return nonFieldSchemaKeys.indexOf(key) === -1;\n  });\n  var response = fieldNames.reduce(function (obj, fieldName) {\n    obj[fieldName] = mongoFieldToParseSchemaField(schema[fieldName]);\n    return obj;\n  }, {});\n  response.ACL = { type: 'ACL' };\n  response.createdAt = { type: 'Date' };\n  response.updatedAt = { type: 'Date' };\n  response.objectId = { type: 'String' };\n  return response;\n}\n\nvar emptyCLPS = Object.freeze({\n  find: {},\n  get: {},\n  create: {},\n  update: {},\n  delete: {},\n  addField: {}\n});\n\nvar defaultCLPS = Object.freeze({\n  find: { '*': true },\n  get: { '*': true },\n  create: { '*': true },\n  update: { '*': true },\n  delete: { '*': true },\n  addField: { '*': true }\n});\n\nfunction mongoSchemaToParseSchema(mongoSchema) {\n  var clps = defaultCLPS;\n  if (mongoSchema._metadata && mongoSchema._metadata.class_permissions) {\n    clps = _extends({}, emptyCLPS, mongoSchema._metadata.class_permissions);\n  }\n  return {\n    className: mongoSchema._id,\n    fields: mongoSchemaFieldsToParseSchemaFields(mongoSchema),\n    classLevelPermissions: clps\n  };\n}\n\nfunction _mongoSchemaQueryFromNameQuery(name, query) {\n  var object = { _id: name };\n  if (query) {\n    Object.keys(query).forEach(function (key) {\n      object[key] = query[key];\n    });\n  }\n  return object;\n}\n\n// Returns a type suitable for inserting into mongo _SCHEMA collection.\n// Does no validation. That is expected to be done in Parse Server.\nfunction parseFieldTypeToMongoFieldType(_ref) {\n  var type = _ref.type,\n      targetClass = _ref.targetClass;\n\n  switch (type) {\n    case 'Pointer':\n      return '*' + targetClass;\n    case 'Relation':\n      return 'relation<' + targetClass + '>';\n    case 'Number':\n      return 'number';\n    case 'String':\n      return 'string';\n    case 'Boolean':\n      return 'boolean';\n    case 'Date':\n      return 'date';\n    case 'Object':\n      return 'object';\n    case 'Array':\n      return 'array';\n    case 'GeoPoint':\n      return 'geopoint';\n    case 'File':\n      return 'file';\n  }\n}\n\nvar MongoSchemaCollection = function () {\n  function MongoSchemaCollection(collection) {\n    _classCallCheck(this, MongoSchemaCollection);\n\n    this._collection = collection;\n  }\n\n  _createClass(MongoSchemaCollection, [{\n    key: '_fetchAllSchemasFrom_SCHEMA',\n    value: function _fetchAllSchemasFrom_SCHEMA() {\n      return this._collection._rawFind({}).then(function (schemas) {\n        return schemas.map(mongoSchemaToParseSchema);\n      });\n    }\n  }, {\n    key: '_fechOneSchemaFrom_SCHEMA',\n    value: function _fechOneSchemaFrom_SCHEMA(name) {\n      return this._collection._rawFind(_mongoSchemaQueryFromNameQuery(name), { limit: 1 }).then(function (results) {\n        if (results.length === 1) {\n          return mongoSchemaToParseSchema(results[0]);\n        } else {\n          throw undefined;\n        }\n      });\n    }\n\n    // Atomically find and delete an object based on query.\n\n  }, {\n    key: 'findAndDeleteSchema',\n    value: function findAndDeleteSchema(name) {\n      return this._collection._mongoCollection.findAndRemove(_mongoSchemaQueryFromNameQuery(name), []);\n    }\n  }, {\n    key: 'updateSchema',\n    value: function updateSchema(name, update) {\n      return this._collection.updateOne(_mongoSchemaQueryFromNameQuery(name), update);\n    }\n  }, {\n    key: 'upsertSchema',\n    value: function upsertSchema(name, query, update) {\n      return this._collection.upsertOne(_mongoSchemaQueryFromNameQuery(name, query), update);\n    }\n\n    // Add a field to the schema. If database does not support the field\n    // type (e.g. mongo doesn't support more than one GeoPoint in a class) reject with an \"Incorrect Type\"\n    // Parse error with a desciptive message. If the field already exists, this function must\n    // not modify the schema, and must reject with DUPLICATE_VALUE error.\n    // If this is called for a class that doesn't exist, this function must create that class.\n\n    // TODO: throw an error if an unsupported field type is passed. Deciding whether a type is supported\n    // should be the job of the adapter. Some adapters may not support GeoPoint at all. Others may\n    // Support additional types that Mongo doesn't, like Money, or something.\n\n    // TODO: don't spend an extra query on finding the schema if the type we are trying to add isn't a GeoPoint.\n\n  }, {\n    key: 'addFieldIfNotExists',\n    value: function addFieldIfNotExists(className, fieldName, type) {\n      var _this = this;\n\n      return this._fechOneSchemaFrom_SCHEMA(className).then(function (schema) {\n        // The schema exists. Check for existing GeoPoints.\n        if (type.type === 'GeoPoint') {\n          // Make sure there are not other geopoint fields\n          if (Object.keys(schema.fields).some(function (existingField) {\n            return schema.fields[existingField].type === 'GeoPoint';\n          })) {\n            throw new _node2.default.Error(_node2.default.Error.INCORRECT_TYPE, 'MongoDB only supports one GeoPoint field in a class.');\n          }\n        }\n        return;\n      }, function (error) {\n        // If error is undefined, the schema doesn't exist, and we can create the schema with the field.\n        // If some other error, reject with it.\n        if (error === undefined) {\n          return;\n        }\n        throw error;\n      }).then(function () {\n        // We use $exists and $set to avoid overwriting the field type if it\n        // already exists. (it could have added inbetween the last query and the update)\n        return _this.upsertSchema(className, _defineProperty({}, fieldName, { '$exists': false }), { '$set': _defineProperty({}, fieldName, parseFieldTypeToMongoFieldType(type)) });\n      });\n    }\n  }]);\n\n  return MongoSchemaCollection;\n}();\n\n// Exported for testing reasons and because we haven't moved all mongo schema format\n// related logic into the database adapter yet.\n\n\nMongoSchemaCollection._TESTmongoSchemaToParseSchema = mongoSchemaToParseSchema;\nMongoSchemaCollection.parseFieldTypeToMongoFieldType = parseFieldTypeToMongoFieldType;\n\nexports.default = MongoSchemaCollection;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/vendor/mongodbUrl.js":"// A slightly patched version of node's url module, with support for mongodb://\n// uris.\n//\n// See https://github.com/nodejs/node/blob/master/LICENSE for licensing\n// information\n\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar punycode = require('punycode');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i;\nvar portPattern = /:[0-9]*$/;\n\n// Special case for a simple path URL\nvar simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/;\n\nvar hostnameMaxLen = 255;\n// protocols that can allow \"unsafe\" and \"unwise\" chars.\nvar unsafeProtocol = {\n  'javascript': true,\n  'javascript:': true\n};\n// protocols that never have a hostname.\nvar hostlessProtocol = {\n  'javascript': true,\n  'javascript:': true\n};\n// protocols that always contain a // bit.\nvar slashedProtocol = {\n  'http': true,\n  'http:': true,\n  'https': true,\n  'https:': true,\n  'ftp': true,\n  'ftp:': true,\n  'gopher': true,\n  'gopher:': true,\n  'file': true,\n  'file:': true\n};\nvar querystring = require('querystring');\n\n/* istanbul ignore next: improve coverage */\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url instanceof Url) return url;\n\n  var u = new Url();\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\n/* istanbul ignore next: improve coverage */\nUrl.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n  if (typeof url !== 'string') {\n    throw new TypeError('Parameter \"url\" must be a string, not ' + (typeof url === 'undefined' ? 'undefined' : _typeof(url)));\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var hasHash = false;\n  var start = -1;\n  var end = -1;\n  var rest = '';\n  var lastPos = 0;\n  var i = 0;\n  for (var inWs = false, split = false; i < url.length; ++i) {\n    var code = url.charCodeAt(i);\n\n    // Find first and last non-whitespace characters for trimming\n    var isWs = code === 32 /* */ || code === 9 /*\\t*/ || code === 13 /*\\r*/ || code === 10 /*\\n*/ || code === 12 /*\\f*/ || code === 160 /*\\u00A0*/ || code === 65279 /*\\uFEFF*/;\n    if (start === -1) {\n      if (isWs) continue;\n      lastPos = start = i;\n    } else {\n      if (inWs) {\n        if (!isWs) {\n          end = -1;\n          inWs = false;\n        }\n      } else if (isWs) {\n        end = i;\n        inWs = true;\n      }\n    }\n\n    // Only convert backslashes while we haven't seen a split character\n    if (!split) {\n      switch (code) {\n        case 35:\n          // '#'\n          hasHash = true;\n        // Fall through\n        case 63:\n          // '?'\n          split = true;\n          break;\n        case 92:\n          // '\\\\'\n          if (i - lastPos > 0) rest += url.slice(lastPos, i);\n          rest += '/';\n          lastPos = i + 1;\n          break;\n      }\n    } else if (!hasHash && code === 35 /*#*/) {\n        hasHash = true;\n      }\n  }\n\n  // Check if string was non-empty (including strings with only whitespace)\n  if (start !== -1) {\n    if (lastPos === start) {\n      // We didn't convert any backslashes\n\n      if (end === -1) {\n        if (start === 0) rest = url;else rest = url.slice(start);\n      } else {\n        rest = url.slice(start, end);\n      }\n    } else if (end === -1 && lastPos < url.length) {\n      // We converted some backslashes and have only part of the entire string\n      rest += url.slice(lastPos);\n    } else if (end !== -1 && lastPos < end) {\n      // We converted some backslashes and have only part of the entire string\n      rest += url.slice(lastPos, end);\n    }\n  }\n\n  if (!slashesDenoteHost && !hasHash) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.slice(1));\n        } else {\n          this.query = this.search.slice(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.slice(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || /^\\/\\/[^@\\/]+@[^@\\/]+/.test(rest)) {\n    var slashes = rest.charCodeAt(0) === 47 /*/*/ && rest.charCodeAt(1) === 47 /*/*/;\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.slice(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:b path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    var hostEnd = -1;\n    var atSign = -1;\n    var nonHost = -1;\n    for (i = 0; i < rest.length; ++i) {\n      switch (rest.charCodeAt(i)) {\n        case 9: // '\\t'\n        case 10: // '\\n'\n        case 13: // '\\r'\n        case 32: // ' '\n        case 34: // '\"'\n        case 37: // '%'\n        case 39: // '\\''\n        case 59: // ';'\n        case 60: // '<'\n        case 62: // '>'\n        case 92: // '\\\\'\n        case 94: // '^'\n        case 96: // '`'\n        case 123: // '{'\n        case 124: // '|'\n        case 125:\n          // '}'\n          // Characters that are never ever allowed in a hostname from RFC 2396\n          if (nonHost === -1) nonHost = i;\n          break;\n        case 35: // '#'\n        case 47: // '/'\n        case 63:\n          // '?'\n          // Find the first instance of any host-ending characters\n          if (nonHost === -1) nonHost = i;\n          hostEnd = i;\n          break;\n        case 64:\n          // '@'\n          // At this point, either we have an explicit point where the\n          // auth portion cannot go past, or the last @ char is the decider.\n          atSign = i;\n          nonHost = -1;\n          break;\n      }\n      if (hostEnd !== -1) break;\n    }\n    start = 0;\n    if (atSign !== -1) {\n      this.auth = decodeURIComponent(rest.slice(0, atSign));\n      start = atSign + 1;\n    }\n    if (nonHost === -1) {\n      this.host = rest.slice(start);\n      rest = '';\n    } else {\n      this.host = rest.slice(start, nonHost);\n      rest = rest.slice(nonHost);\n    }\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    if (typeof this.hostname !== 'string') this.hostname = '';\n\n    var hostname = this.hostname;\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = hostname.charCodeAt(0) === 91 /*[*/ && hostname.charCodeAt(hostname.length - 1) === 93 /*]*/;\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var result = validateHostname(this, rest, hostname);\n      if (result !== undefined) rest = result;\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.slice(1, -1);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    var _result = autoEscapeStr(rest);\n    if (_result !== undefined) rest = _result;\n  }\n\n  var questionIdx = -1;\n  var hashIdx = -1;\n  for (i = 0; i < rest.length; ++i) {\n    var _code = rest.charCodeAt(i);\n    if (_code === 35 /*#*/) {\n        this.hash = rest.slice(i);\n        hashIdx = i;\n        break;\n      } else if (_code === 63 /*?*/ && questionIdx === -1) {\n      questionIdx = i;\n    }\n  }\n\n  if (questionIdx !== -1) {\n    if (hashIdx === -1) {\n      this.search = rest.slice(questionIdx);\n      this.query = rest.slice(questionIdx + 1);\n    } else {\n      this.search = rest.slice(questionIdx, hashIdx);\n      this.query = rest.slice(questionIdx + 1, hashIdx);\n    }\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n\n  var firstIdx = questionIdx !== -1 && (hashIdx === -1 || questionIdx < hashIdx) ? questionIdx : hashIdx;\n  if (firstIdx === -1) {\n    if (rest.length > 0) this.pathname = rest;\n  } else if (firstIdx > 0) {\n    this.pathname = rest.slice(0, firstIdx);\n  }\n  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  // to support http.request\n  if (this.pathname || this.search) {\n    var _p = this.pathname || '';\n    var s = this.search || '';\n    this.path = _p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n/* istanbul ignore next: improve coverage */\nfunction validateHostname(self, rest, hostname) {\n  for (var i = 0, lastPos; i <= hostname.length; ++i) {\n    var code;\n    if (i < hostname.length) code = hostname.charCodeAt(i);\n    if (code === 46 /*.*/ || i === hostname.length) {\n      if (i - lastPos > 0) {\n        if (i - lastPos > 63) {\n          self.hostname = hostname.slice(0, lastPos + 63);\n          return '/' + hostname.slice(lastPos + 63) + rest;\n        }\n      }\n      lastPos = i + 1;\n      continue;\n    } else if (code >= 48 /*0*/ && code <= 57 /*9*/ || code >= 97 /*a*/ && code <= 122 /*z*/ || code === 45 /*-*/ || code >= 65 /*A*/ && code <= 90 /*Z*/ || code === 43 /*+*/ || code === 95 /*_*/ ||\n    /* BEGIN MONGO URI PATCH */\n    code === 44 /*,*/ || code === 58 /*:*/ ||\n    /* END MONGO URI PATCH */\n    code > 127) {\n      continue;\n    }\n    // Invalid host character\n    self.hostname = hostname.slice(0, i);\n    if (i < hostname.length) return '/' + hostname.slice(i) + rest;\n    break;\n  }\n}\n\n/* istanbul ignore next: improve coverage */\nfunction autoEscapeStr(rest) {\n  var newRest = '';\n  var lastPos = 0;\n  for (var i = 0; i < rest.length; ++i) {\n    // Automatically escape all delimiters and unwise characters from RFC 2396\n    // Also escape single quotes in case of an XSS attack\n    switch (rest.charCodeAt(i)) {\n      case 9:\n        // '\\t'\n        if (i - lastPos > 0) newRest += rest.slice(lastPos, i);\n        newRest += '%09';\n        lastPos = i + 1;\n        break;\n      case 10:\n        // '\\n'\n        if (i - lastPos > 0) newRest += rest.slice(lastPos, i);\n        newRest += '%0A';\n        lastPos = i + 1;\n        break;\n      case 13:\n        // '\\r'\n        if (i - lastPos > 0) newRest += rest.slice(lastPos, i);\n        newRest += '%0D';\n        lastPos = i + 1;\n        break;\n      case 32:\n        // ' '\n        if (i - lastPos > 0) newRest += rest.slice(lastPos, i);\n        newRest += '%20';\n        lastPos = i + 1;\n        break;\n      case 34:\n        // '\"'\n        if (i - lastPos > 0) newRest += rest.slice(lastPos, i);\n        newRest += '%22';\n        lastPos = i + 1;\n        break;\n      case 39:\n        // '\\''\n        if (i - lastPos > 0) newRest += rest.slice(lastPos, i);\n        newRest += '%27';\n        lastPos = i + 1;\n        break;\n      case 60:\n        // '<'\n        if (i - lastPos > 0) newRest += rest.slice(lastPos, i);\n        newRest += '%3C';\n        lastPos = i + 1;\n        break;\n      case 62:\n        // '>'\n        if (i - lastPos > 0) newRest += rest.slice(lastPos, i);\n        newRest += '%3E';\n        lastPos = i + 1;\n        break;\n      case 92:\n        // '\\\\'\n        if (i - lastPos > 0) newRest += rest.slice(lastPos, i);\n        newRest += '%5C';\n        lastPos = i + 1;\n        break;\n      case 94:\n        // '^'\n        if (i - lastPos > 0) newRest += rest.slice(lastPos, i);\n        newRest += '%5E';\n        lastPos = i + 1;\n        break;\n      case 96:\n        // '`'\n        if (i - lastPos > 0) newRest += rest.slice(lastPos, i);\n        newRest += '%60';\n        lastPos = i + 1;\n        break;\n      case 123:\n        // '{'\n        if (i - lastPos > 0) newRest += rest.slice(lastPos, i);\n        newRest += '%7B';\n        lastPos = i + 1;\n        break;\n      case 124:\n        // '|'\n        if (i - lastPos > 0) newRest += rest.slice(lastPos, i);\n        newRest += '%7C';\n        lastPos = i + 1;\n        break;\n      case 125:\n        // '}'\n        if (i - lastPos > 0) newRest += rest.slice(lastPos, i);\n        newRest += '%7D';\n        lastPos = i + 1;\n        break;\n    }\n  }\n  if (lastPos === 0) return;\n  if (lastPos < rest.length) return newRest + rest.slice(lastPos);else return newRest;\n}\n\n// format a parsed object into a url string\n/* istanbul ignore next: improve coverage */\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (typeof obj === 'string') obj = urlParse(obj);else if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) throw new TypeError('Parameter \"urlObj\" must be an object, not ' + obj === null ? 'null' : typeof obj === 'undefined' ? 'undefined' : _typeof(obj));else if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n\n  return obj.format();\n}\n\n/* istanbul ignore next: improve coverage */\nUrl.prototype.format = function () {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeAuth(auth);\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '';\n  var pathname = this.pathname || '';\n  var hash = this.hash || '';\n  var host = false;\n  var query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query !== null && _typeof(this.query) === 'object') query = querystring.stringify(this.query);\n\n  var search = this.search || query && '?' + query || '';\n\n  if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58 /*:*/) protocol += ':';\n\n  var newPathname = '';\n  var lastPos = 0;\n  for (var i = 0; i < pathname.length; ++i) {\n    switch (pathname.charCodeAt(i)) {\n      case 35:\n        // '#'\n        if (i - lastPos > 0) newPathname += pathname.slice(lastPos, i);\n        newPathname += '%23';\n        lastPos = i + 1;\n        break;\n      case 63:\n        // '?'\n        if (i - lastPos > 0) newPathname += pathname.slice(lastPos, i);\n        newPathname += '%3F';\n        lastPos = i + 1;\n        break;\n    }\n  }\n  if (lastPos > 0) {\n    if (lastPos !== pathname.length) pathname = newPathname + pathname.slice(lastPos);else pathname = newPathname;\n  }\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charCodeAt(0) !== 47 /*/*/) pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  search = search.replace('#', '%23');\n\n  if (hash && hash.charCodeAt(0) !== 35 /*#*/) hash = '#' + hash;\n  if (search && search.charCodeAt(0) !== 63 /*?*/) search = '?' + search;\n\n  return protocol + host + pathname + search + hash;\n};\n\n/* istanbul ignore next: improve coverage */\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\n/* istanbul ignore next: improve coverage */\nUrl.prototype.resolve = function (relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\n/* istanbul ignore next: improve coverage */\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\n/* istanbul ignore next: improve coverage */\nUrl.prototype.resolveObject = function (relative) {\n  if (typeof relative === 'string') {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol') result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !/^file:?$/.test(relative.protocol) && !hostlessProtocol[relative.protocol]) {\n      var _relPath = (relative.pathname || '').split('/');\n      while (_relPath.length && !(relative.host = _relPath.shift())) {}\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (_relPath[0] !== '') _relPath.unshift('');\n      if (_relPath.length < 2) _relPath.unshift('');\n      result.pathname = _relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/';\n  var isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/';\n  var mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname;\n  var removeAllDots = mustEndAbs;\n  var srcPath = result.pathname && result.pathname.split('/') || [];\n  var relPath = relative.pathname && relative.pathname.split('/') || [];\n  var psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = relative.host || relative.host === '' ? relative.host : result.host;\n    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (relative.search !== null && relative.search !== undefined) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occasionally the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (result.pathname !== null || result.search !== null) {\n      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      spliceOne(srcPath, i);\n    } else if (last === '..') {\n      spliceOne(srcPath, i);\n      up++;\n    } else if (up) {\n      spliceOne(srcPath, i);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';\n    //occasionally the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var _authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n    if (_authInHost) {\n      result.auth = _authInHost.shift();\n      result.host = result.hostname = _authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || result.host && srcPath.length;\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (result.pathname !== null || result.search !== null) {\n    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\n/* istanbul ignore next: improve coverage */\nUrl.prototype.parseHost = function () {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.slice(1);\n    }\n    host = host.slice(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\n/* istanbul ignore next: improve coverage */\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\n    list[i] = list[k];\n  }list.pop();\n}\n\nvar hexTable = new Array(256);\nfor (var i = 0; i < 256; ++i) {\n  hexTable[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();\n} /* istanbul ignore next: improve coverage */\nfunction encodeAuth(str) {\n  // faster encodeURIComponent alternative for encoding auth uri components\n  var out = '';\n  var lastPos = 0;\n  for (var i = 0; i < str.length; ++i) {\n    var c = str.charCodeAt(i);\n\n    // These characters do not need escaping:\n    // ! - . _ ~\n    // ' ( ) * :\n    // digits\n    // alpha (uppercase)\n    // alpha (lowercase)\n    if (c === 0x21 || c === 0x2D || c === 0x2E || c === 0x5F || c === 0x7E || c >= 0x27 && c <= 0x2A || c >= 0x30 && c <= 0x3A || c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A) {\n      continue;\n    }\n\n    if (i - lastPos > 0) out += str.slice(lastPos, i);\n\n    lastPos = i + 1;\n\n    // Other ASCII characters\n    if (c < 0x80) {\n      out += hexTable[c];\n      continue;\n    }\n\n    // Multi-byte characters ...\n    if (c < 0x800) {\n      out += hexTable[0xC0 | c >> 6] + hexTable[0x80 | c & 0x3F];\n      continue;\n    }\n    if (c < 0xD800 || c >= 0xE000) {\n      out += hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];\n      continue;\n    }\n    // Surrogate pair\n    ++i;\n    var c2;\n    if (i < str.length) c2 = str.charCodeAt(i) & 0x3FF;else c2 = 0;\n    c = 0x10000 + ((c & 0x3FF) << 10 | c2);\n    out += hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];\n  }\n  if (lastPos === 0) return str;\n  if (lastPos < str.length) return out + str.slice(lastPos);\n  return out;\n}","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Storage/Mongo/MongoTransform.js":"'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _logger = require('../../../logger');\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar mongodb = require('mongodb');\nvar Parse = require('parse/node').Parse;\n\nvar transformKey = function transformKey(className, fieldName, schema) {\n  // Check if the schema is known since it's a built-in field.\n  switch (fieldName) {\n    case 'objectId':\n      return '_id';\n    case 'createdAt':\n      return '_created_at';\n    case 'updatedAt':\n      return '_updated_at';\n    case 'sessionToken':\n      return '_session_token';\n  }\n\n  if (schema.fields[fieldName] && schema.fields[fieldName].__type == 'Pointer') {\n    fieldName = '_p_' + fieldName;\n  } else if (schema.fields[fieldName] && schema.fields[fieldName].type == 'Pointer') {\n    fieldName = '_p_' + fieldName;\n  }\n\n  return fieldName;\n};\n\nvar transformKeyValueForUpdate = function transformKeyValueForUpdate(className, restKey, restValue, parseFormatSchema) {\n  // Check if the schema is known since it's a built-in field.\n  var key = restKey;\n  var timeField = false;\n  switch (key) {\n    case 'objectId':\n    case '_id':\n      if (className === '_GlobalConfig') {\n        return {\n          key: key,\n          value: parseInt(restValue)\n        };\n      }\n      key = '_id';\n      break;\n    case 'createdAt':\n    case '_created_at':\n      key = '_created_at';\n      timeField = true;\n      break;\n    case 'updatedAt':\n    case '_updated_at':\n      key = '_updated_at';\n      timeField = true;\n      break;\n    case 'sessionToken':\n    case '_session_token':\n      key = '_session_token';\n      break;\n    case 'expiresAt':\n    case '_expiresAt':\n      key = 'expiresAt';\n      timeField = true;\n      break;\n    case '_email_verify_token_expires_at':\n      key = '_email_verify_token_expires_at';\n      timeField = true;\n      break;\n    case '_account_lockout_expires_at':\n      key = '_account_lockout_expires_at';\n      timeField = true;\n      break;\n    case '_failed_login_count':\n      key = '_failed_login_count';\n      break;\n    case '_perishable_token_expires_at':\n      key = '_perishable_token_expires_at';\n      timeField = true;\n      break;\n    case '_password_changed_at':\n      key = '_password_changed_at';\n      timeField = true;\n      break;\n    case '_rperm':\n    case '_wperm':\n      return { key: key, value: restValue };\n  }\n\n  if (parseFormatSchema.fields[key] && parseFormatSchema.fields[key].type === 'Pointer' || !parseFormatSchema.fields[key] && restValue && restValue.__type == 'Pointer') {\n    key = '_p_' + key;\n  }\n\n  // Handle atomic values\n  var value = transformTopLevelAtom(restValue);\n  if (value !== CannotTransform) {\n    if (timeField && typeof value === 'string') {\n      value = new Date(value);\n    }\n    if (restKey.indexOf('.') > 0) {\n      return { key: key, value: restValue };\n    }\n    return { key: key, value: value };\n  }\n\n  // Handle arrays\n  if (restValue instanceof Array) {\n    value = restValue.map(transformInteriorValue);\n    return { key: key, value: value };\n  }\n\n  // Handle update operators\n  if ((typeof restValue === 'undefined' ? 'undefined' : _typeof(restValue)) === 'object' && '__op' in restValue) {\n    return { key: key, value: transformUpdateOperator(restValue, false) };\n  }\n\n  // Handle normal objects by recursing\n  value = _lodash2.default.mapValues(restValue, transformInteriorValue);\n  return { key: key, value: value };\n};\n\nvar transformInteriorValue = function transformInteriorValue(restValue) {\n  if (restValue !== null && (typeof restValue === 'undefined' ? 'undefined' : _typeof(restValue)) === 'object' && Object.keys(restValue).some(function (key) {\n    return key.includes('$') || key.includes('.');\n  })) {\n    throw new Parse.Error(Parse.Error.INVALID_NESTED_KEY, \"Nested keys should not contain the '$' or '.' characters\");\n  }\n  // Handle atomic values\n  var value = transformInteriorAtom(restValue);\n  if (value !== CannotTransform) {\n    return value;\n  }\n\n  // Handle arrays\n  if (restValue instanceof Array) {\n    return restValue.map(transformInteriorValue);\n  }\n\n  // Handle update operators\n  if ((typeof restValue === 'undefined' ? 'undefined' : _typeof(restValue)) === 'object' && '__op' in restValue) {\n    return transformUpdateOperator(restValue, true);\n  }\n\n  // Handle normal objects by recursing\n  return _lodash2.default.mapValues(restValue, transformInteriorValue);\n};\n\nvar valueAsDate = function valueAsDate(value) {\n  if (typeof value === 'string') {\n    return new Date(value);\n  } else if (value instanceof Date) {\n    return value;\n  }\n  return false;\n};\n\nfunction transformQueryKeyValue(className, key, value, schema) {\n  switch (key) {\n    case 'createdAt':\n      if (valueAsDate(value)) {\n        return { key: '_created_at', value: valueAsDate(value) };\n      }\n      key = '_created_at';\n      break;\n    case 'updatedAt':\n      if (valueAsDate(value)) {\n        return { key: '_updated_at', value: valueAsDate(value) };\n      }\n      key = '_updated_at';\n      break;\n    case 'expiresAt':\n      if (valueAsDate(value)) {\n        return { key: 'expiresAt', value: valueAsDate(value) };\n      }\n      break;\n    case '_email_verify_token_expires_at':\n      if (valueAsDate(value)) {\n        return { key: '_email_verify_token_expires_at', value: valueAsDate(value) };\n      }\n      break;\n    case 'objectId':\n      {\n        if (className === '_GlobalConfig') {\n          value = parseInt(value);\n        }\n        return { key: '_id', value: value };\n      }\n    case '_account_lockout_expires_at':\n      if (valueAsDate(value)) {\n        return { key: '_account_lockout_expires_at', value: valueAsDate(value) };\n      }\n      break;\n    case '_failed_login_count':\n      return { key: key, value: value };\n    case 'sessionToken':\n      return { key: '_session_token', value: value };\n    case '_perishable_token_expires_at':\n      if (valueAsDate(value)) {\n        return { key: '_perishable_token_expires_at', value: valueAsDate(value) };\n      }\n      break;\n    case '_password_changed_at':\n      if (valueAsDate(value)) {\n        return { key: '_password_changed_at', value: valueAsDate(value) };\n      }\n      break;\n    case '_rperm':\n    case '_wperm':\n    case '_perishable_token':\n    case '_email_verify_token':\n      return { key: key, value: value };\n    case '$or':\n      return { key: '$or', value: value.map(function (subQuery) {\n          return transformWhere(className, subQuery, schema);\n        }) };\n    case '$and':\n      return { key: '$and', value: value.map(function (subQuery) {\n          return transformWhere(className, subQuery, schema);\n        }) };\n    default:\n      {\n        // Other auth data\n        var authDataMatch = key.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/);\n        if (authDataMatch) {\n          var provider = authDataMatch[1];\n          // Special-case auth data.\n          return { key: '_auth_data_' + provider + '.id', value: value };\n        }\n      }\n  }\n\n  var expectedTypeIsArray = schema && schema.fields[key] && schema.fields[key].type === 'Array';\n\n  var expectedTypeIsPointer = schema && schema.fields[key] && schema.fields[key].type === 'Pointer';\n\n  if (expectedTypeIsPointer || !schema && value && value.__type === 'Pointer') {\n    key = '_p_' + key;\n  }\n\n  // Handle query constraints\n  var transformedConstraint = transformConstraint(value, expectedTypeIsArray);\n  if (transformedConstraint !== CannotTransform) {\n    return { key: key, value: transformedConstraint };\n  }\n\n  if (expectedTypeIsArray && !(value instanceof Array)) {\n    return { key: key, value: { '$all': [value] } };\n  }\n\n  // Handle atomic values\n  if (transformTopLevelAtom(value) !== CannotTransform) {\n    return { key: key, value: transformTopLevelAtom(value) };\n  } else {\n    throw new Parse.Error(Parse.Error.INVALID_JSON, 'You cannot use ' + value + ' as a query parameter.');\n  }\n}\n\n// Main exposed method to help run queries.\n// restWhere is the \"where\" clause in REST API form.\n// Returns the mongo form of the query.\nfunction transformWhere(className, restWhere, schema) {\n  var mongoWhere = {};\n  for (var restKey in restWhere) {\n    var out = transformQueryKeyValue(className, restKey, restWhere[restKey], schema);\n    mongoWhere[out.key] = out.value;\n  }\n  return mongoWhere;\n}\n\nvar parseObjectKeyValueToMongoObjectKeyValue = function parseObjectKeyValueToMongoObjectKeyValue(restKey, restValue, schema) {\n  // Check if the schema is known since it's a built-in field.\n  var transformedValue = void 0;\n  var coercedToDate = void 0;\n  switch (restKey) {\n    case 'objectId':\n      return { key: '_id', value: restValue };\n    case 'expiresAt':\n      transformedValue = transformTopLevelAtom(restValue);\n      coercedToDate = typeof transformedValue === 'string' ? new Date(transformedValue) : transformedValue;\n      return { key: 'expiresAt', value: coercedToDate };\n    case '_email_verify_token_expires_at':\n      transformedValue = transformTopLevelAtom(restValue);\n      coercedToDate = typeof transformedValue === 'string' ? new Date(transformedValue) : transformedValue;\n      return { key: '_email_verify_token_expires_at', value: coercedToDate };\n    case '_account_lockout_expires_at':\n      transformedValue = transformTopLevelAtom(restValue);\n      coercedToDate = typeof transformedValue === 'string' ? new Date(transformedValue) : transformedValue;\n      return { key: '_account_lockout_expires_at', value: coercedToDate };\n    case '_perishable_token_expires_at':\n      transformedValue = transformTopLevelAtom(restValue);\n      coercedToDate = typeof transformedValue === 'string' ? new Date(transformedValue) : transformedValue;\n      return { key: '_perishable_token_expires_at', value: coercedToDate };\n    case '_password_changed_at':\n      transformedValue = transformTopLevelAtom(restValue);\n      coercedToDate = typeof transformedValue === 'string' ? new Date(transformedValue) : transformedValue;\n      return { key: '_password_changed_at', value: coercedToDate };\n    case '_failed_login_count':\n    case '_rperm':\n    case '_wperm':\n    case '_email_verify_token':\n    case '_hashed_password':\n    case '_perishable_token':\n      return { key: restKey, value: restValue };\n    case 'sessionToken':\n      return { key: '_session_token', value: restValue };\n    default:\n      // Auth data should have been transformed already\n      if (restKey.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n        throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'can only query on ' + restKey);\n      }\n      // Trust that the auth data has been transformed and save it directly\n      if (restKey.match(/^_auth_data_[a-zA-Z0-9_]+$/)) {\n        return { key: restKey, value: restValue };\n      }\n  }\n  //skip straight to transformTopLevelAtom for Bytes, they don't show up in the schema for some reason\n  if (restValue && restValue.__type !== 'Bytes') {\n    //Note: We may not know the type of a field here, as the user could be saving (null) to a field\n    //That never existed before, meaning we can't infer the type.\n    if (schema.fields[restKey] && schema.fields[restKey].type == 'Pointer' || restValue.__type == 'Pointer') {\n      restKey = '_p_' + restKey;\n    }\n  }\n\n  // Handle atomic values\n  var value = transformTopLevelAtom(restValue);\n  if (value !== CannotTransform) {\n    return { key: restKey, value: value };\n  }\n\n  // ACLs are handled before this method is called\n  // If an ACL key still exists here, something is wrong.\n  if (restKey === 'ACL') {\n    throw 'There was a problem transforming an ACL.';\n  }\n\n  // Handle arrays\n  if (restValue instanceof Array) {\n    value = restValue.map(transformInteriorValue);\n    return { key: restKey, value: value };\n  }\n\n  // Handle normal objects by recursing\n  if (Object.keys(restValue).some(function (key) {\n    return key.includes('$') || key.includes('.');\n  })) {\n    throw new Parse.Error(Parse.Error.INVALID_NESTED_KEY, \"Nested keys should not contain the '$' or '.' characters\");\n  }\n  value = _lodash2.default.mapValues(restValue, transformInteriorValue);\n  return { key: restKey, value: value };\n};\n\nvar parseObjectToMongoObjectForCreate = function parseObjectToMongoObjectForCreate(className, restCreate, schema) {\n  restCreate = addLegacyACL(restCreate);\n  var mongoCreate = {};\n  for (var restKey in restCreate) {\n    if (restCreate[restKey] && restCreate[restKey].__type === 'Relation') {\n      continue;\n    }\n\n    var _parseObjectKeyValueT = parseObjectKeyValueToMongoObjectKeyValue(restKey, restCreate[restKey], schema),\n        key = _parseObjectKeyValueT.key,\n        value = _parseObjectKeyValueT.value;\n\n    if (value !== undefined) {\n      mongoCreate[key] = value;\n    }\n  }\n\n  // Use the legacy mongo format for createdAt and updatedAt\n  if (mongoCreate.createdAt) {\n    mongoCreate._created_at = new Date(mongoCreate.createdAt.iso || mongoCreate.createdAt);\n    delete mongoCreate.createdAt;\n  }\n  if (mongoCreate.updatedAt) {\n    mongoCreate._updated_at = new Date(mongoCreate.updatedAt.iso || mongoCreate.updatedAt);\n    delete mongoCreate.updatedAt;\n  }\n\n  return mongoCreate;\n};\n\n// Main exposed method to help update old objects.\nvar transformUpdate = function transformUpdate(className, restUpdate, parseFormatSchema) {\n  var mongoUpdate = {};\n  var acl = addLegacyACL(restUpdate);\n  if (acl._rperm || acl._wperm || acl._acl) {\n    mongoUpdate.$set = {};\n    if (acl._rperm) {\n      mongoUpdate.$set._rperm = acl._rperm;\n    }\n    if (acl._wperm) {\n      mongoUpdate.$set._wperm = acl._wperm;\n    }\n    if (acl._acl) {\n      mongoUpdate.$set._acl = acl._acl;\n    }\n  }\n  for (var restKey in restUpdate) {\n    if (restUpdate[restKey] && restUpdate[restKey].__type === 'Relation') {\n      continue;\n    }\n    var out = transformKeyValueForUpdate(className, restKey, restUpdate[restKey], parseFormatSchema);\n\n    // If the output value is an object with any $ keys, it's an\n    // operator that needs to be lifted onto the top level update\n    // object.\n    if (_typeof(out.value) === 'object' && out.value !== null && out.value.__op) {\n      mongoUpdate[out.value.__op] = mongoUpdate[out.value.__op] || {};\n      mongoUpdate[out.value.__op][out.key] = out.value.arg;\n    } else {\n      mongoUpdate['$set'] = mongoUpdate['$set'] || {};\n      mongoUpdate['$set'][out.key] = out.value;\n    }\n  }\n\n  return mongoUpdate;\n};\n\n// Add the legacy _acl format.\nvar addLegacyACL = function addLegacyACL(restObject) {\n  var restObjectCopy = _extends({}, restObject);\n  var _acl = {};\n\n  if (restObject._wperm) {\n    restObject._wperm.forEach(function (entry) {\n      _acl[entry] = { w: true };\n    });\n    restObjectCopy._acl = _acl;\n  }\n\n  if (restObject._rperm) {\n    restObject._rperm.forEach(function (entry) {\n      if (!(entry in _acl)) {\n        _acl[entry] = { r: true };\n      } else {\n        _acl[entry].r = true;\n      }\n    });\n    restObjectCopy._acl = _acl;\n  }\n\n  return restObjectCopy;\n};\n\n// A sentinel value that helper transformations return when they\n// cannot perform a transformation\nfunction CannotTransform() {}\n\nvar transformInteriorAtom = function transformInteriorAtom(atom) {\n  // TODO: check validity harder for the __type-defined types\n  if ((typeof atom === 'undefined' ? 'undefined' : _typeof(atom)) === 'object' && atom && !(atom instanceof Date) && atom.__type === 'Pointer') {\n    return {\n      __type: 'Pointer',\n      className: atom.className,\n      objectId: atom.objectId\n    };\n  } else if (typeof atom === 'function' || (typeof atom === 'undefined' ? 'undefined' : _typeof(atom)) === 'symbol') {\n    throw new Parse.Error(Parse.Error.INVALID_JSON, 'cannot transform value: ' + atom);\n  } else if (DateCoder.isValidJSON(atom)) {\n    return DateCoder.JSONToDatabase(atom);\n  } else if (BytesCoder.isValidJSON(atom)) {\n    return BytesCoder.JSONToDatabase(atom);\n  } else {\n    return atom;\n  }\n};\n\n// Helper function to transform an atom from REST format to Mongo format.\n// An atom is anything that can't contain other expressions. So it\n// includes things where objects are used to represent other\n// datatypes, like pointers and dates, but it does not include objects\n// or arrays with generic stuff inside.\n// Raises an error if this cannot possibly be valid REST format.\n// Returns CannotTransform if it's just not an atom\nfunction transformTopLevelAtom(atom) {\n  switch (typeof atom === 'undefined' ? 'undefined' : _typeof(atom)) {\n    case 'string':\n    case 'number':\n    case 'boolean':\n      return atom;\n    case 'undefined':\n      return atom;\n    case 'symbol':\n    case 'function':\n      throw new Parse.Error(Parse.Error.INVALID_JSON, 'cannot transform value: ' + atom);\n    case 'object':\n      if (atom instanceof Date) {\n        // Technically dates are not rest format, but, it seems pretty\n        // clear what they should be transformed to, so let's just do it.\n        return atom;\n      }\n\n      if (atom === null) {\n        return atom;\n      }\n\n      // TODO: check validity harder for the __type-defined types\n      if (atom.__type == 'Pointer') {\n        return atom.className + '$' + atom.objectId;\n      }\n      if (DateCoder.isValidJSON(atom)) {\n        return DateCoder.JSONToDatabase(atom);\n      }\n      if (BytesCoder.isValidJSON(atom)) {\n        return BytesCoder.JSONToDatabase(atom);\n      }\n      if (GeoPointCoder.isValidJSON(atom)) {\n        return GeoPointCoder.JSONToDatabase(atom);\n      }\n      if (FileCoder.isValidJSON(atom)) {\n        return FileCoder.JSONToDatabase(atom);\n      }\n      return CannotTransform;\n\n    default:\n      // I don't think typeof can ever let us get here\n      throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, 'really did not expect value: ' + atom);\n  }\n}\n\n// Transforms a query constraint from REST API format to Mongo format.\n// A constraint is something with fields like $lt.\n// If it is not a valid constraint but it could be a valid something\n// else, return CannotTransform.\n// inArray is whether this is an array field.\nfunction transformConstraint(constraint, inArray) {\n  if ((typeof constraint === 'undefined' ? 'undefined' : _typeof(constraint)) !== 'object' || !constraint) {\n    return CannotTransform;\n  }\n  var transformFunction = inArray ? transformInteriorAtom : transformTopLevelAtom;\n  var transformer = function transformer(atom) {\n    var result = transformFunction(atom);\n    if (result === CannotTransform) {\n      throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad atom: ' + JSON.stringify(atom));\n    }\n    return result;\n  };\n  // keys is the constraints in reverse alphabetical order.\n  // This is a hack so that:\n  //   $regex is handled before $options\n  //   $nearSphere is handled before $maxDistance\n  var keys = Object.keys(constraint).sort().reverse();\n  var answer = {};\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n\n      switch (key) {\n        case '$lt':\n        case '$lte':\n        case '$gt':\n        case '$gte':\n        case '$exists':\n        case '$ne':\n        case '$eq':\n          answer[key] = transformer(constraint[key]);\n          break;\n\n        case '$in':\n        case '$nin':\n          {\n            var arr = constraint[key];\n            if (!(arr instanceof Array)) {\n              throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad ' + key + ' value');\n            }\n            answer[key] = _lodash2.default.flatMap(arr, function (value) {\n              return function (atom) {\n                if (Array.isArray(atom)) {\n                  return value.map(transformer);\n                } else {\n                  return transformer(atom);\n                }\n              }(value);\n            });\n            break;\n          }\n        case '$all':\n          {\n            var _arr = constraint[key];\n            if (!(_arr instanceof Array)) {\n              throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad ' + key + ' value');\n            }\n            answer[key] = _arr.map(transformInteriorAtom);\n            break;\n          }\n        case '$regex':\n          var s = constraint[key];\n          if (typeof s !== 'string') {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad regex: ' + s);\n          }\n          answer[key] = s;\n          break;\n\n        case '$options':\n          answer[key] = constraint[key];\n          break;\n\n        case '$nearSphere':\n          var point = constraint[key];\n          answer[key] = [point.longitude, point.latitude];\n          break;\n\n        case '$maxDistance':\n          answer[key] = constraint[key];\n          break;\n\n        // The SDKs don't seem to use these but they are documented in the\n        // REST API docs.\n        case '$maxDistanceInRadians':\n          answer['$maxDistance'] = constraint[key];\n          break;\n        case '$maxDistanceInMiles':\n          answer['$maxDistance'] = constraint[key] / 3959;\n          break;\n        case '$maxDistanceInKilometers':\n          answer['$maxDistance'] = constraint[key] / 6371;\n          break;\n\n        case '$select':\n        case '$dontSelect':\n          throw new Parse.Error(Parse.Error.COMMAND_UNAVAILABLE, 'the ' + key + ' constraint is not supported yet');\n\n        case '$within':\n          var box = constraint[key]['$box'];\n          if (!box || box.length != 2) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'malformatted $within arg');\n          }\n          answer[key] = {\n            '$box': [[box[0].longitude, box[0].latitude], [box[1].longitude, box[1].latitude]]\n          };\n          break;\n\n        default:\n          if (key.match(/^\\$+/)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad constraint: ' + key);\n          }\n          return CannotTransform;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return answer;\n}\n\n// Transforms an update operator from REST format to mongo format.\n// To be transformed, the input should have an __op field.\n// If flatten is true, this will flatten operators to their static\n// data format. For example, an increment of 2 would simply become a\n// 2.\n// The output for a non-flattened operator is a hash with __op being\n// the mongo op, and arg being the argument.\n// The output for a flattened operator is just a value.\n// Returns undefined if this should be a no-op.\n\nfunction transformUpdateOperator(_ref, flatten) {\n  var __op = _ref.__op,\n      amount = _ref.amount,\n      objects = _ref.objects;\n\n  switch (__op) {\n    case 'Delete':\n      if (flatten) {\n        return undefined;\n      } else {\n        return { __op: '$unset', arg: '' };\n      }\n\n    case 'Increment':\n      if (typeof amount !== 'number') {\n        throw new Parse.Error(Parse.Error.INVALID_JSON, 'incrementing must provide a number');\n      }\n      if (flatten) {\n        return amount;\n      } else {\n        return { __op: '$inc', arg: amount };\n      }\n\n    case 'Add':\n    case 'AddUnique':\n      if (!(objects instanceof Array)) {\n        throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n      }\n      var toAdd = objects.map(transformInteriorAtom);\n      if (flatten) {\n        return toAdd;\n      } else {\n        var mongoOp = {\n          Add: '$push',\n          AddUnique: '$addToSet'\n        }[__op];\n        return { __op: mongoOp, arg: { '$each': toAdd } };\n      }\n\n    case 'Remove':\n      if (!(objects instanceof Array)) {\n        throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to remove must be an array');\n      }\n      var toRemove = objects.map(transformInteriorAtom);\n      if (flatten) {\n        return [];\n      } else {\n        return { __op: '$pullAll', arg: toRemove };\n      }\n\n    default:\n      throw new Parse.Error(Parse.Error.COMMAND_UNAVAILABLE, 'The ' + __op + ' operator is not supported yet.');\n  }\n}\n\nvar nestedMongoObjectToNestedParseObject = function nestedMongoObjectToNestedParseObject(mongoObject) {\n  switch (typeof mongoObject === 'undefined' ? 'undefined' : _typeof(mongoObject)) {\n    case 'string':\n    case 'number':\n    case 'boolean':\n      return mongoObject;\n    case 'undefined':\n    case 'symbol':\n    case 'function':\n      throw 'bad value in mongoObjectToParseObject';\n    case 'object':\n      if (mongoObject === null) {\n        return null;\n      }\n      if (mongoObject instanceof Array) {\n        return mongoObject.map(nestedMongoObjectToNestedParseObject);\n      }\n\n      if (mongoObject instanceof Date) {\n        return Parse._encode(mongoObject);\n      }\n\n      if (mongoObject instanceof mongodb.Long) {\n        return mongoObject.toNumber();\n      }\n\n      if (mongoObject instanceof mongodb.Double) {\n        return mongoObject.value;\n      }\n\n      if (BytesCoder.isValidDatabaseObject(mongoObject)) {\n        return BytesCoder.databaseToJSON(mongoObject);\n      }\n\n      if (mongoObject.hasOwnProperty('__type') && mongoObject.__type == 'Date' && mongoObject.iso instanceof Date) {\n        mongoObject.iso = mongoObject.iso.toJSON();\n        return mongoObject;\n      }\n\n      return _lodash2.default.mapValues(mongoObject, nestedMongoObjectToNestedParseObject);\n    default:\n      throw 'unknown js type';\n  }\n};\n\n// Converts from a mongo-format object to a REST-format object.\n// Does not strip out anything based on a lack of authentication.\nvar mongoObjectToParseObject = function mongoObjectToParseObject(className, mongoObject, schema) {\n  switch (typeof mongoObject === 'undefined' ? 'undefined' : _typeof(mongoObject)) {\n    case 'string':\n    case 'number':\n    case 'boolean':\n      return mongoObject;\n    case 'undefined':\n    case 'symbol':\n    case 'function':\n      throw 'bad value in mongoObjectToParseObject';\n    case 'object':\n      {\n        if (mongoObject === null) {\n          return null;\n        }\n        if (mongoObject instanceof Array) {\n          return mongoObject.map(nestedMongoObjectToNestedParseObject);\n        }\n\n        if (mongoObject instanceof Date) {\n          return Parse._encode(mongoObject);\n        }\n\n        if (mongoObject instanceof mongodb.Long) {\n          return mongoObject.toNumber();\n        }\n\n        if (mongoObject instanceof mongodb.Double) {\n          return mongoObject.value;\n        }\n\n        if (BytesCoder.isValidDatabaseObject(mongoObject)) {\n          return BytesCoder.databaseToJSON(mongoObject);\n        }\n\n        var restObject = {};\n        if (mongoObject._rperm || mongoObject._wperm) {\n          restObject._rperm = mongoObject._rperm || [];\n          restObject._wperm = mongoObject._wperm || [];\n          delete mongoObject._rperm;\n          delete mongoObject._wperm;\n        }\n\n        for (var key in mongoObject) {\n          switch (key) {\n            case '_id':\n              restObject['objectId'] = '' + mongoObject[key];\n              break;\n            case '_hashed_password':\n              restObject._hashed_password = mongoObject[key];\n              break;\n            case '_acl':\n              break;\n            case '_email_verify_token':\n            case '_perishable_token':\n            case '_perishable_token_expires_at':\n            case '_password_changed_at':\n            case '_tombstone':\n            case '_email_verify_token_expires_at':\n            case '_account_lockout_expires_at':\n            case '_failed_login_count':\n            case '_password_history':\n              // Those keys will be deleted if needed in the DB Controller\n              restObject[key] = mongoObject[key];\n              break;\n            case '_session_token':\n              restObject['sessionToken'] = mongoObject[key];\n              break;\n            case 'updatedAt':\n            case '_updated_at':\n              restObject['updatedAt'] = Parse._encode(new Date(mongoObject[key])).iso;\n              break;\n            case 'createdAt':\n            case '_created_at':\n              restObject['createdAt'] = Parse._encode(new Date(mongoObject[key])).iso;\n              break;\n            case 'expiresAt':\n            case '_expiresAt':\n              restObject['expiresAt'] = Parse._encode(new Date(mongoObject[key]));\n              break;\n            default:\n              // Check other auth data keys\n              var authDataMatch = key.match(/^_auth_data_([a-zA-Z0-9_]+)$/);\n              if (authDataMatch) {\n                var provider = authDataMatch[1];\n                restObject['authData'] = restObject['authData'] || {};\n                restObject['authData'][provider] = mongoObject[key];\n                break;\n              }\n\n              if (key.indexOf('_p_') == 0) {\n                var newKey = key.substring(3);\n                if (!schema.fields[newKey]) {\n                  _logger2.default.info('transform.js', 'Found a pointer column not in the schema, dropping it.', className, newKey);\n                  break;\n                }\n                if (schema.fields[newKey].type !== 'Pointer') {\n                  _logger2.default.info('transform.js', 'Found a pointer in a non-pointer column, dropping it.', className, key);\n                  break;\n                }\n                if (mongoObject[key] === null) {\n                  break;\n                }\n                var objData = mongoObject[key].split('$');\n                if (objData[0] !== schema.fields[newKey].targetClass) {\n                  throw 'pointer to incorrect className';\n                }\n                restObject[newKey] = {\n                  __type: 'Pointer',\n                  className: objData[0],\n                  objectId: objData[1]\n                };\n                break;\n              } else if (key[0] == '_' && key != '__type') {\n                throw 'bad key in untransform: ' + key;\n              } else {\n                var value = mongoObject[key];\n                if (schema.fields[key] && schema.fields[key].type === 'File' && FileCoder.isValidDatabaseObject(value)) {\n                  restObject[key] = FileCoder.databaseToJSON(value);\n                  break;\n                }\n                if (schema.fields[key] && schema.fields[key].type === 'GeoPoint' && GeoPointCoder.isValidDatabaseObject(value)) {\n                  restObject[key] = GeoPointCoder.databaseToJSON(value);\n                  break;\n                }\n                if (schema.fields[key] && schema.fields[key].type === 'Bytes' && BytesCoder.isValidDatabaseObject(value)) {\n                  restObject[key] = BytesCoder.databaseToJSON(value);\n                  break;\n                }\n              }\n              restObject[key] = nestedMongoObjectToNestedParseObject(mongoObject[key]);\n          }\n        }\n\n        var relationFieldNames = Object.keys(schema.fields).filter(function (fieldName) {\n          return schema.fields[fieldName].type === 'Relation';\n        });\n        var relationFields = {};\n        relationFieldNames.forEach(function (relationFieldName) {\n          relationFields[relationFieldName] = {\n            __type: 'Relation',\n            className: schema.fields[relationFieldName].targetClass\n          };\n        });\n\n        return _extends({}, restObject, relationFields);\n      }\n    default:\n      throw 'unknown js type';\n  }\n};\n\nvar DateCoder = {\n  JSONToDatabase: function JSONToDatabase(json) {\n    return new Date(json.iso);\n  },\n  isValidJSON: function isValidJSON(value) {\n    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null && value.__type === 'Date';\n  }\n};\n\nvar BytesCoder = {\n  base64Pattern: new RegExp(\"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\"),\n  isBase64Value: function isBase64Value(object) {\n    if (typeof object !== 'string') {\n      return false;\n    }\n    return this.base64Pattern.test(object);\n  },\n  databaseToJSON: function databaseToJSON(object) {\n    var value = void 0;\n    if (this.isBase64Value(object)) {\n      value = object;\n    } else {\n      value = object.buffer.toString('base64');\n    }\n    return {\n      __type: 'Bytes',\n      base64: value\n    };\n  },\n  isValidDatabaseObject: function isValidDatabaseObject(object) {\n    return object instanceof mongodb.Binary || this.isBase64Value(object);\n  },\n  JSONToDatabase: function JSONToDatabase(json) {\n    return new mongodb.Binary(new Buffer(json.base64, 'base64'));\n  },\n  isValidJSON: function isValidJSON(value) {\n    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null && value.__type === 'Bytes';\n  }\n};\n\nvar GeoPointCoder = {\n  databaseToJSON: function databaseToJSON(object) {\n    return {\n      __type: 'GeoPoint',\n      latitude: object[1],\n      longitude: object[0]\n    };\n  },\n  isValidDatabaseObject: function isValidDatabaseObject(object) {\n    return object instanceof Array && object.length == 2;\n  },\n  JSONToDatabase: function JSONToDatabase(json) {\n    return [json.longitude, json.latitude];\n  },\n  isValidJSON: function isValidJSON(value) {\n    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null && value.__type === 'GeoPoint';\n  }\n};\n\nvar FileCoder = {\n  databaseToJSON: function databaseToJSON(object) {\n    return {\n      __type: 'File',\n      name: object\n    };\n  },\n  isValidDatabaseObject: function isValidDatabaseObject(object) {\n    return typeof object === 'string';\n  },\n  JSONToDatabase: function JSONToDatabase(json) {\n    return json.name;\n  },\n  isValidJSON: function isValidJSON(value) {\n    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null && value.__type === 'File';\n  }\n};\n\nmodule.exports = {\n  transformKey: transformKey,\n  parseObjectToMongoObjectForCreate: parseObjectToMongoObjectForCreate,\n  transformUpdate: transformUpdate,\n  transformWhere: transformWhere,\n  mongoObjectToParseObject: mongoObjectToParseObject\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Storage/Postgres/PostgresStorageAdapter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PostgresStorageAdapter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _PostgresClient = require('./PostgresClient');\n\nvar _node = require('parse/node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _sql = require('./sql');\n\nvar _sql2 = _interopRequireDefault(_sql);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar PostgresRelationDoesNotExistError = '42P01';\nvar PostgresDuplicateRelationError = '42P07';\nvar PostgresDuplicateColumnError = '42701';\nvar PostgresDuplicateObjectError = '42710';\nvar PostgresUniqueIndexViolationError = '23505';\nvar PostgresTransactionAbortedError = '25P02';\nvar logger = require('../../../logger');\n\nvar debug = function debug() {\n  var args = [].concat(Array.prototype.slice.call(arguments));\n  args = ['PG: ' + arguments[0]].concat(args.slice(1, args.length));\n  var log = logger.getLogger();\n  log.debug.apply(log, args);\n};\n\nvar parseTypeToPostgresType = function parseTypeToPostgresType(type) {\n  switch (type.type) {\n    case 'String':\n      return 'text';\n    case 'Date':\n      return 'timestamp with time zone';\n    case 'Object':\n      return 'jsonb';\n    case 'File':\n      return 'text';\n    case 'Boolean':\n      return 'boolean';\n    case 'Pointer':\n      return 'char(10)';\n    case 'Number':\n      return 'double precision';\n    case 'GeoPoint':\n      return 'point';\n    case 'Array':\n      if (type.contents && type.contents.type === 'String') {\n        return 'text[]';\n      } else {\n        return 'jsonb';\n      }\n    default:\n      throw 'no type for ' + JSON.stringify(type) + ' yet';\n  }\n};\n\nvar ParseToPosgresComparator = {\n  '$gt': '>',\n  '$lt': '<',\n  '$gte': '>=',\n  '$lte': '<='\n};\n\nvar toPostgresValue = function toPostgresValue(value) {\n  if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n    if (value.__type === 'Date') {\n      return value.iso;\n    }\n    if (value.__type === 'File') {\n      return value.name;\n    }\n  }\n  return value;\n};\n\nvar transformValue = function transformValue(value) {\n  if (value.__type === 'Pointer') {\n    return value.objectId;\n  }\n  return value;\n};\n\n// Duplicate from then mongo adapter...\nvar emptyCLPS = Object.freeze({\n  find: {},\n  get: {},\n  create: {},\n  update: {},\n  delete: {},\n  addField: {}\n});\n\nvar defaultCLPS = Object.freeze({\n  find: { '*': true },\n  get: { '*': true },\n  create: { '*': true },\n  update: { '*': true },\n  delete: { '*': true },\n  addField: { '*': true }\n});\n\nvar toParseSchema = function toParseSchema(schema) {\n  if (schema.className === '_User') {\n    delete schema.fields._hashed_password;\n  }\n  if (schema.fields) {\n    delete schema.fields._wperm;\n    delete schema.fields._rperm;\n  }\n  var clps = defaultCLPS;\n  if (schema.classLevelPermissions) {\n    clps = _extends({}, emptyCLPS, schema.classLevelPermissions);\n  }\n  return {\n    className: schema.className,\n    fields: schema.fields,\n    classLevelPermissions: clps\n  };\n};\n\nvar toPostgresSchema = function toPostgresSchema(schema) {\n  if (!schema) {\n    return schema;\n  }\n  schema.fields = schema.fields || {};\n  schema.fields._wperm = { type: 'Array', contents: { type: 'String' } };\n  schema.fields._rperm = { type: 'Array', contents: { type: 'String' } };\n  if (schema.className === '_User') {\n    schema.fields._hashed_password = { type: 'String' };\n    schema.fields._password_history = { type: 'Array' };\n  }\n  return schema;\n};\n\nvar handleDotFields = function handleDotFields(object) {\n  Object.keys(object).forEach(function (fieldName) {\n    if (fieldName.indexOf('.') > -1) {\n      var components = fieldName.split('.');\n      var first = components.shift();\n      object[first] = object[first] || {};\n      var currentObj = object[first];\n      var next = void 0;\n      var value = object[fieldName];\n      if (value && value.__op === 'Delete') {\n        value = undefined;\n      }\n      /* eslint-disable no-cond-assign */\n      while (next = components.shift()) {\n        /* eslint-enable no-cond-assign */\n        currentObj[next] = currentObj[next] || {};\n        if (components.length === 0) {\n          currentObj[next] = value;\n        }\n        currentObj = currentObj[next];\n      }\n      delete object[fieldName];\n    }\n  });\n  return object;\n};\n\nvar validateKeys = function validateKeys(object) {\n  if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) == 'object') {\n    for (var key in object) {\n      if (_typeof(object[key]) == 'object') {\n        validateKeys(object[key]);\n      }\n\n      if (key.includes('$') || key.includes('.')) {\n        throw new _node2.default.Error(_node2.default.Error.INVALID_NESTED_KEY, \"Nested keys should not contain the '$' or '.' characters\");\n      }\n    }\n  }\n};\n\n// Returns the list of join tables on a schema\nvar joinTablesForSchema = function joinTablesForSchema(schema) {\n  var list = [];\n  if (schema) {\n    Object.keys(schema.fields).forEach(function (field) {\n      if (schema.fields[field].type === 'Relation') {\n        list.push('_Join:' + field + ':' + schema.className);\n      }\n    });\n  }\n  return list;\n};\n\nvar buildWhereClause = function buildWhereClause(_ref) {\n  var schema = _ref.schema,\n      query = _ref.query,\n      index = _ref.index;\n\n  var patterns = [];\n  var values = [];\n  var sorts = [];\n\n  schema = toPostgresSchema(schema);\n\n  var _loop = function _loop(fieldName) {\n    var isArrayField = schema.fields && schema.fields[fieldName] && schema.fields[fieldName].type === 'Array';\n    var initialPatternsLength = patterns.length;\n    var fieldValue = query[fieldName];\n\n    // nothingin the schema, it's gonna blow up\n    if (!schema.fields[fieldName]) {\n      // as it won't exist\n      if (fieldValue.$exists === false) {\n        return 'continue';\n      }\n    }\n\n    if (fieldName.indexOf('.') >= 0) {\n      var components = fieldName.split('.').map(function (cmpt, index) {\n        if (index === 0) {\n          return '\"' + cmpt + '\"';\n        }\n        return '\\'' + cmpt + '\\'';\n      });\n      var name = components.slice(0, components.length - 1).join('->');\n      name += '->>' + components[components.length - 1];\n      patterns.push(name + ' = \\'' + fieldValue + '\\'');\n    } else if (typeof fieldValue === 'string') {\n      patterns.push('$' + index + ':name = $' + (index + 1));\n      values.push(fieldName, fieldValue);\n      index += 2;\n    } else if (typeof fieldValue === 'boolean') {\n      patterns.push('$' + index + ':name = $' + (index + 1));\n      values.push(fieldName, fieldValue);\n      index += 2;\n    } else if (typeof fieldValue === 'number') {\n      patterns.push('$' + index + ':name = $' + (index + 1));\n      values.push(fieldName, fieldValue);\n      index += 2;\n    } else if (fieldName === '$or' || fieldName === '$and') {\n      var _values;\n\n      var clauses = [];\n      var clauseValues = [];\n      fieldValue.forEach(function (subQuery) {\n        var clause = buildWhereClause({ schema: schema, query: subQuery, index: index });\n        if (clause.pattern.length > 0) {\n          clauses.push(clause.pattern);\n          clauseValues.push.apply(clauseValues, _toConsumableArray(clause.values));\n          index += clause.values.length;\n        }\n      });\n      var orOrAnd = fieldName === '$or' ? ' OR ' : ' AND ';\n      patterns.push('(' + clauses.join(orOrAnd) + ')');\n      (_values = values).push.apply(_values, clauseValues);\n    }\n\n    if (fieldValue.$ne) {\n      if (isArrayField) {\n        fieldValue.$ne = JSON.stringify([fieldValue.$ne]);\n        patterns.push('NOT array_contains($' + index + ':name, $' + (index + 1) + ')');\n      } else {\n        if (fieldValue.$ne === null) {\n          patterns.push('$' + index + ':name <> $' + (index + 1));\n        } else {\n          // if not null, we need to manually exclude null\n          patterns.push('($' + index + ':name <> $' + (index + 1) + ' OR $' + index + ':name IS NULL)');\n        }\n      }\n\n      // TODO: support arrays\n      values.push(fieldName, fieldValue.$ne);\n      index += 2;\n    }\n\n    if (fieldValue.$eq) {\n      patterns.push('$' + index + ':name = $' + (index + 1));\n      values.push(fieldName, fieldValue.$eq);\n      index += 2;\n    }\n    var isInOrNin = Array.isArray(fieldValue.$in) || Array.isArray(fieldValue.$nin);\n    if (Array.isArray(fieldValue.$in) && isArrayField && schema.fields[fieldName].contents && schema.fields[fieldName].contents.type === 'String') {\n      var inPatterns = [];\n      var allowNull = false;\n      values.push(fieldName);\n      fieldValue.$in.forEach(function (listElem, listIndex) {\n        if (listElem === null) {\n          allowNull = true;\n        } else {\n          values.push(listElem);\n          inPatterns.push('$' + (index + 1 + listIndex - (allowNull ? 1 : 0)));\n        }\n      });\n      if (allowNull) {\n        patterns.push('($' + index + ':name IS NULL OR $' + index + ':name && ARRAY[' + inPatterns.join(',') + '])');\n      } else {\n        patterns.push('$' + index + ':name && ARRAY[' + inPatterns.join(',') + ']');\n      }\n      index = index + 1 + inPatterns.length;\n    } else if (isInOrNin) {\n      createConstraint = function createConstraint(baseArray, notIn) {\n        if (baseArray.length > 0) {\n          var not = notIn ? ' NOT ' : '';\n          if (isArrayField) {\n            patterns.push(not + ' array_contains($' + index + ':name, $' + (index + 1) + ')');\n            values.push(fieldName, JSON.stringify(baseArray));\n            index += 2;\n          } else {\n            var _inPatterns = [];\n            values.push(fieldName);\n            baseArray.forEach(function (listElem, listIndex) {\n              values.push(listElem);\n              _inPatterns.push('$' + (index + 1 + listIndex));\n            });\n            patterns.push('$' + index + ':name ' + not + ' IN (' + _inPatterns.join(',') + ')');\n            index = index + 1 + _inPatterns.length;\n          }\n        } else if (!notIn) {\n          values.push(fieldName);\n          patterns.push('$' + index + ':name IS NULL');\n          index = index + 1;\n        }\n      };\n\n      if (fieldValue.$in) {\n        createConstraint(_lodash2.default.flatMap(fieldValue.$in, function (elt) {\n          return elt;\n        }), false);\n      }\n      if (fieldValue.$nin) {\n        createConstraint(_lodash2.default.flatMap(fieldValue.$nin, function (elt) {\n          return elt;\n        }), true);\n      }\n    }\n\n    if (Array.isArray(fieldValue.$all) && isArrayField) {\n      patterns.push('array_contains_all($' + index + ':name, $' + (index + 1) + '::jsonb)');\n      values.push(fieldName, JSON.stringify(fieldValue.$all));\n      index += 2;\n    }\n\n    if (typeof fieldValue.$exists !== 'undefined') {\n      if (fieldValue.$exists) {\n        patterns.push('$' + index + ':name IS NOT NULL');\n      } else {\n        patterns.push('$' + index + ':name IS NULL');\n      }\n      values.push(fieldName);\n      index += 1;\n    }\n\n    if (fieldValue.$nearSphere) {\n      var point = fieldValue.$nearSphere;\n      var distance = fieldValue.$maxDistance;\n      var distanceInKM = distance * 6371 * 1000;\n      patterns.push('ST_distance_sphere($' + index + ':name::geometry, POINT($' + (index + 1) + ', $' + (index + 2) + ')::geometry) <= $' + (index + 3));\n      sorts.push('ST_distance_sphere($' + index + ':name::geometry, POINT($' + (index + 1) + ', $' + (index + 2) + ')::geometry) ASC');\n      values.push(fieldName, point.longitude, point.latitude, distanceInKM);\n      index += 4;\n    }\n\n    if (fieldValue.$within && fieldValue.$within.$box) {\n      var box = fieldValue.$within.$box;\n      var left = box[0].longitude;\n      var bottom = box[0].latitude;\n      var right = box[1].longitude;\n      var top = box[1].latitude;\n\n      patterns.push('$' + index + ':name::point <@ $' + (index + 1) + '::box');\n      values.push(fieldName, '((' + left + ', ' + bottom + '), (' + right + ', ' + top + '))');\n      index += 2;\n    }\n\n    if (fieldValue.$regex) {\n      var regex = fieldValue.$regex;\n      var operator = '~';\n      var opts = fieldValue.$options;\n      if (opts) {\n        if (opts.indexOf('i') >= 0) {\n          operator = '~*';\n        }\n        if (opts.indexOf('x') >= 0) {\n          regex = removeWhiteSpace(regex);\n        }\n      }\n\n      regex = processRegexPattern(regex);\n\n      patterns.push('$' + index + ':name ' + operator + ' \\'$' + (index + 1) + ':raw\\'');\n      values.push(fieldName, regex);\n      index += 2;\n    }\n\n    if (fieldValue.__type === 'Pointer') {\n      if (isArrayField) {\n        patterns.push('array_contains($' + index + ':name, $' + (index + 1) + ')');\n        values.push(fieldName, JSON.stringify([fieldValue]));\n        index += 2;\n      } else {\n        patterns.push('$' + index + ':name = $' + (index + 1));\n        values.push(fieldName, fieldValue.objectId);\n        index += 2;\n      }\n    }\n\n    if (fieldValue.__type === 'Date') {\n      patterns.push('$' + index + ':name = $' + (index + 1));\n      values.push(fieldName, fieldValue.iso);\n      index += 2;\n    }\n\n    Object.keys(ParseToPosgresComparator).forEach(function (cmp) {\n      if (fieldValue[cmp]) {\n        var pgComparator = ParseToPosgresComparator[cmp];\n        patterns.push('$' + index + ':name ' + pgComparator + ' $' + (index + 1));\n        values.push(fieldName, toPostgresValue(fieldValue[cmp]));\n        index += 2;\n      }\n    });\n\n    if (initialPatternsLength === patterns.length) {\n      throw new _node2.default.Error(_node2.default.Error.OPERATION_FORBIDDEN, 'Postgres doesn\\'t support this query type yet ' + JSON.stringify(fieldValue));\n    }\n  };\n\n  for (var fieldName in query) {\n    var createConstraint;\n\n    var _ret = _loop(fieldName);\n\n    if (_ret === 'continue') continue;\n  }\n  values = values.map(transformValue);\n  return { pattern: patterns.join(' AND '), values: values, sorts: sorts };\n};\n\nvar PostgresStorageAdapter = exports.PostgresStorageAdapter = function () {\n  // Private\n  function PostgresStorageAdapter(_ref2) {\n    var uri = _ref2.uri,\n        _ref2$collectionPrefi = _ref2.collectionPrefix,\n        collectionPrefix = _ref2$collectionPrefi === undefined ? '' : _ref2$collectionPrefi,\n        databaseOptions = _ref2.databaseOptions;\n\n    _classCallCheck(this, PostgresStorageAdapter);\n\n    this._collectionPrefix = collectionPrefix;\n    this._client = (0, _PostgresClient.createClient)(uri, databaseOptions);\n  }\n\n  _createClass(PostgresStorageAdapter, [{\n    key: '_ensureSchemaCollectionExists',\n    value: function _ensureSchemaCollectionExists(conn) {\n      conn = conn || this._client;\n      return conn.none('CREATE TABLE IF NOT EXISTS \"_SCHEMA\" ( \"className\" varChar(120), \"schema\" jsonb, \"isParseClass\" bool, PRIMARY KEY (\"className\") )').catch(function (error) {\n        if (error.code === PostgresDuplicateRelationError || error.code === PostgresUniqueIndexViolationError || error.code === PostgresDuplicateObjectError) {\n          // Table already exists, must have been created by a different request. Ignore error.\n        } else {\n          throw error;\n        }\n      });\n    }\n  }, {\n    key: 'classExists',\n    value: function classExists(name) {\n      return this._client.one('SELECT EXISTS (SELECT 1 FROM   information_schema.tables WHERE table_name = $1)', [name]).then(function (res) {\n        return res.exists;\n      });\n    }\n  }, {\n    key: 'setClassLevelPermissions',\n    value: function setClassLevelPermissions(className, CLPs) {\n      var _this = this;\n\n      return this._ensureSchemaCollectionExists().then(function () {\n        var values = [className, 'schema', 'classLevelPermissions', JSON.stringify(CLPs)];\n        return _this._client.none('UPDATE \"_SCHEMA\" SET $2:name = json_object_set_key($2:name, $3::text, $4::jsonb) WHERE \"className\"=$1 ', values);\n      });\n    }\n  }, {\n    key: 'createClass',\n    value: function createClass(className, schema) {\n      var _this2 = this;\n\n      return this._client.tx(function (t) {\n        var q1 = _this2.createTable(className, schema, t);\n        var q2 = t.none('INSERT INTO \"_SCHEMA\" (\"className\", \"schema\", \"isParseClass\") VALUES ($<className>, $<schema>, true)', { className: className, schema: schema });\n\n        return t.batch([q1, q2]);\n      }).then(function () {\n        return toParseSchema(schema);\n      }).catch(function (err) {\n        if (Array.isArray(err.data) && err.data.length > 1 && err.data[0].result.code === PostgresTransactionAbortedError) {\n          err = err.data[1].result;\n        }\n\n        if (err.code === PostgresUniqueIndexViolationError && err.detail.includes(className)) {\n          throw new _node2.default.Error(_node2.default.Error.DUPLICATE_VALUE, 'Class ' + className + ' already exists.');\n        }\n        throw err;\n      });\n    }\n\n    // Just create a table, do not insert in schema\n\n  }, {\n    key: 'createTable',\n    value: function createTable(className, schema, conn) {\n      conn = conn || this._client;\n      debug('createTable', className, schema);\n      var valuesArray = [];\n      var patternsArray = [];\n      var fields = Object.assign({}, schema.fields);\n      if (className === '_User') {\n        fields._email_verify_token_expires_at = { type: 'Date' };\n        fields._email_verify_token = { type: 'String' };\n        fields._account_lockout_expires_at = { type: 'Date' };\n        fields._failed_login_count = { type: 'Number' };\n        fields._perishable_token = { type: 'String' };\n        fields._perishable_token_expires_at = { type: 'Date' };\n        fields._password_changed_at = { type: 'Date' };\n        fields._password_history = { type: 'Array' };\n      }\n      var index = 2;\n      var relations = [];\n      Object.keys(fields).forEach(function (fieldName) {\n        var parseType = fields[fieldName];\n        // Skip when it's a relation\n        // We'll create the tables later\n        if (parseType.type === 'Relation') {\n          relations.push(fieldName);\n          return;\n        }\n        if (['_rperm', '_wperm'].indexOf(fieldName) >= 0) {\n          parseType.contents = { type: 'String' };\n        }\n        valuesArray.push(fieldName);\n        valuesArray.push(parseTypeToPostgresType(parseType));\n        patternsArray.push('$' + index + ':name $' + (index + 1) + ':raw');\n        if (fieldName === 'objectId') {\n          patternsArray.push('PRIMARY KEY ($' + index + ':name)');\n        }\n        index = index + 2;\n      });\n      var qs = 'CREATE TABLE IF NOT EXISTS $1:name (' + patternsArray.join(',') + ')';\n      var values = [className].concat(valuesArray);\n      return this._ensureSchemaCollectionExists(conn).then(function () {\n        return conn.none(qs, values);\n      }).catch(function (error) {\n        if (error.code === PostgresDuplicateRelationError) {\n          // Table already exists, must have been created by a different request. Ignore error.\n        } else {\n          throw error;\n        }\n      }).then(function () {\n        // Create the relation tables\n        return Promise.all(relations.map(function (fieldName) {\n          return conn.none('CREATE TABLE IF NOT EXISTS $<joinTable:name> (\"relatedId\" varChar(120), \"owningId\" varChar(120), PRIMARY KEY(\"relatedId\", \"owningId\") )', { joinTable: '_Join:' + fieldName + ':' + className });\n        }));\n      });\n    }\n  }, {\n    key: 'addFieldIfNotExists',\n    value: function addFieldIfNotExists(className, fieldName, type) {\n      var _this3 = this;\n\n      // TODO: Must be revised for invalid logic...\n      debug('addFieldIfNotExists', { className: className, fieldName: fieldName, type: type });\n      return this._client.tx(\"addFieldIfNotExists\", function (t) {\n        var promise = Promise.resolve();\n        if (type.type !== 'Relation') {\n          promise = t.none('ALTER TABLE $<className:name> ADD COLUMN $<fieldName:name> $<postgresType:raw>', {\n            className: className,\n            fieldName: fieldName,\n            postgresType: parseTypeToPostgresType(type)\n          }).catch(function (error) {\n            if (error.code === PostgresRelationDoesNotExistError) {\n              return _this3.createClass(className, { fields: _defineProperty({}, fieldName, type) });\n            } else if (error.code === PostgresDuplicateColumnError) {\n              // Column already exists, created by other request. Carry on to\n              // See if it's the right type.\n            } else {\n              throw error;\n            }\n          });\n        } else {\n          promise = t.none('CREATE TABLE IF NOT EXISTS $<joinTable:name> (\"relatedId\" varChar(120), \"owningId\" varChar(120), PRIMARY KEY(\"relatedId\", \"owningId\") )', { joinTable: '_Join:' + fieldName + ':' + className });\n        }\n        return promise.then(function () {\n          return t.any('SELECT \"schema\" FROM \"_SCHEMA\" WHERE \"className\" = $<className>', { className: className });\n        }).then(function (result) {\n          if (fieldName in result[0].schema.fields) {\n            throw \"Attempted to add a field that already exists\";\n          } else {\n            result[0].schema.fields[fieldName] = type;\n            return t.none('UPDATE \"_SCHEMA\" SET \"schema\"=$<schema> WHERE \"className\"=$<className>', { schema: result[0].schema, className: className });\n          }\n        });\n      });\n    }\n\n    // Drops a collection. Resolves with true if it was a Parse Schema (eg. _User, Custom, etc.)\n    // and resolves with false if it wasn't (eg. a join table). Rejects if deletion was impossible.\n\n  }, {\n    key: 'deleteClass',\n    value: function deleteClass(className) {\n      var _this4 = this;\n\n      return Promise.resolve().then(function () {\n        var operations = [['DROP TABLE IF EXISTS $1:name', [className]], ['DELETE FROM \"_SCHEMA\" WHERE \"className\"=$1', [className]]];\n        return _this4._client.tx(function (t) {\n          return t.batch(operations.map(function (statement) {\n            return t.none(statement[0], statement[1]);\n          }));\n        });\n      }).then(function () {\n        // resolves with false when _Join table\n        return className.indexOf('_Join:') != 0;\n      });\n    }\n\n    // Delete all data known to this adapter. Used for testing.\n\n  }, {\n    key: 'deleteAllClasses',\n    value: function deleteAllClasses() {\n      var _this5 = this;\n\n      var now = new Date().getTime();\n      debug('deleteAllClasses');\n      return this._client.any('SELECT * FROM \"_SCHEMA\"').then(function (results) {\n        var joins = results.reduce(function (list, schema) {\n          return list.concat(joinTablesForSchema(schema.schema));\n        }, []);\n        var classes = ['_SCHEMA', '_PushStatus', '_JobStatus', '_Hooks', '_GlobalConfig'].concat(_toConsumableArray(results.map(function (result) {\n          return result.className;\n        })), _toConsumableArray(joins));\n        return _this5._client.tx(function (t) {\n          return t.batch(classes.map(function (className) {\n            return t.none('DROP TABLE IF EXISTS $<className:name>', { className: className });\n          }));\n        });\n      }, function (error) {\n        if (error.code === PostgresRelationDoesNotExistError) {\n          // No _SCHEMA collection. Don't delete anything.\n          return;\n        } else {\n          throw error;\n        }\n      }).then(function () {\n        debug('deleteAllClasses done in ' + (new Date().getTime() - now));\n      });\n    }\n\n    // Remove the column and all the data. For Relations, the _Join collection is handled\n    // specially, this function does not delete _Join columns. It should, however, indicate\n    // that the relation fields does not exist anymore. In mongo, this means removing it from\n    // the _SCHEMA collection.  There should be no actual data in the collection under the same name\n    // as the relation column, so it's fine to attempt to delete it. If the fields listed to be\n    // deleted do not exist, this function should return successfully anyways. Checking for\n    // attempts to delete non-existent fields is the responsibility of Parse Server.\n\n    // This function is not obligated to delete fields atomically. It is given the field\n    // names in a list so that databases that are capable of deleting fields atomically\n    // may do so.\n\n    // Returns a Promise.\n\n  }, {\n    key: 'deleteFields',\n    value: function deleteFields(className, schema, fieldNames) {\n      var _this6 = this;\n\n      debug('deleteFields', className, fieldNames);\n      return Promise.resolve().then(function () {\n        fieldNames = fieldNames.reduce(function (list, fieldName) {\n          var field = schema.fields[fieldName];\n          if (field.type !== 'Relation') {\n            list.push(fieldName);\n          }\n          delete schema.fields[fieldName];\n          return list;\n        }, []);\n\n        var values = [className].concat(_toConsumableArray(fieldNames));\n        var columns = fieldNames.map(function (name, idx) {\n          return '$' + (idx + 2) + ':name';\n        }).join(',');\n\n        var doBatch = function doBatch(t) {\n          var batch = [t.none('UPDATE \"_SCHEMA\" SET \"schema\"=$<schema> WHERE \"className\"=$<className>', { schema: schema, className: className })];\n          if (values.length > 1) {\n            batch.push(t.none('ALTER TABLE $1:name DROP COLUMN ' + columns, values));\n          }\n          return batch;\n        };\n        return _this6._client.tx(function (t) {\n          return t.batch(doBatch(t));\n        });\n      });\n    }\n\n    // Return a promise for all schemas known to this adapter, in Parse format. In case the\n    // schemas cannot be retrieved, returns a promise that rejects. Requirements for the\n    // rejection reason are TBD.\n\n  }, {\n    key: 'getAllClasses',\n    value: function getAllClasses() {\n      var _this7 = this;\n\n      return this._ensureSchemaCollectionExists().then(function () {\n        return _this7._client.map('SELECT * FROM \"_SCHEMA\"', null, function (row) {\n          return _extends({ className: row.className }, row.schema);\n        });\n      }).then(function (res) {\n        return res.map(toParseSchema);\n      });\n    }\n\n    // Return a promise for the schema with the given name, in Parse format. If\n    // this adapter doesn't know about the schema, return a promise that rejects with\n    // undefined as the reason.\n\n  }, {\n    key: 'getClass',\n    value: function getClass(className) {\n      debug('getClass', className);\n      return this._client.any('SELECT * FROM \"_SCHEMA\" WHERE \"className\"=$<className>', { className: className }).then(function (result) {\n        if (result.length === 1) {\n          return result[0].schema;\n        } else {\n          throw undefined;\n        }\n      }).then(toParseSchema);\n    }\n\n    // TODO: remove the mongo format dependency in the return value\n\n  }, {\n    key: 'createObject',\n    value: function createObject(className, schema, object) {\n      debug('createObject', className, object);\n      var columnsArray = [];\n      var valuesArray = [];\n      schema = toPostgresSchema(schema);\n      var geoPoints = {};\n\n      object = handleDotFields(object);\n\n      validateKeys(object);\n\n      Object.keys(object).forEach(function (fieldName) {\n        var authDataMatch = fieldName.match(/^_auth_data_([a-zA-Z0-9_]+)$/);\n        if (authDataMatch) {\n          var provider = authDataMatch[1];\n          object['authData'] = object['authData'] || {};\n          object['authData'][provider] = object[fieldName];\n          delete object[fieldName];\n          fieldName = 'authData';\n        }\n\n        columnsArray.push(fieldName);\n        if (!schema.fields[fieldName] && className === '_User') {\n          if (fieldName === '_email_verify_token' || fieldName === '_failed_login_count' || fieldName === '_perishable_token' || fieldName === '_password_history') {\n            valuesArray.push(object[fieldName]);\n          }\n\n          if (fieldName === '_email_verify_token_expires_at') {\n            if (object[fieldName]) {\n              valuesArray.push(object[fieldName].iso);\n            } else {\n              valuesArray.push(null);\n            }\n          }\n\n          if (fieldName === '_account_lockout_expires_at' || fieldName === '_perishable_token_expires_at' || fieldName === '_password_changed_at') {\n            if (object[fieldName]) {\n              valuesArray.push(object[fieldName].iso);\n            } else {\n              valuesArray.push(null);\n            }\n          }\n          return;\n        }\n        switch (schema.fields[fieldName].type) {\n          case 'Date':\n            if (object[fieldName]) {\n              valuesArray.push(object[fieldName].iso);\n            } else {\n              valuesArray.push(null);\n            }\n            break;\n          case 'Pointer':\n            valuesArray.push(object[fieldName].objectId);\n            break;\n          case 'Array':\n            if (['_rperm', '_wperm'].indexOf(fieldName) >= 0) {\n              valuesArray.push(object[fieldName]);\n            } else {\n              valuesArray.push(JSON.stringify(object[fieldName]));\n            }\n            break;\n          case 'Object':\n          case 'String':\n          case 'Number':\n          case 'Boolean':\n            valuesArray.push(object[fieldName]);\n            break;\n          case 'File':\n            valuesArray.push(object[fieldName].name);\n            break;\n          case 'GeoPoint':\n            // pop the point and process later\n            geoPoints[fieldName] = object[fieldName];\n            columnsArray.pop();\n            break;\n          default:\n            throw 'Type ' + schema.fields[fieldName].type + ' not supported yet';\n        }\n      });\n\n      columnsArray = columnsArray.concat(Object.keys(geoPoints));\n      var initialValues = valuesArray.map(function (val, index) {\n        var termination = '';\n        var fieldName = columnsArray[index];\n        if (['_rperm', '_wperm'].indexOf(fieldName) >= 0) {\n          termination = '::text[]';\n        } else if (schema.fields[fieldName] && schema.fields[fieldName].type === 'Array') {\n          termination = '::jsonb';\n        }\n        return '$' + (index + 2 + columnsArray.length) + termination;\n      });\n      var geoPointsInjects = Object.keys(geoPoints).map(function (key) {\n        var value = geoPoints[key];\n        valuesArray.push(value.longitude, value.latitude);\n        var l = valuesArray.length + columnsArray.length;\n        return 'POINT($' + l + ', $' + (l + 1) + ')';\n      });\n\n      var columnsPattern = columnsArray.map(function (col, index) {\n        return '$' + (index + 2) + ':name';\n      }).join(',');\n      var valuesPattern = initialValues.concat(geoPointsInjects).join(',');\n\n      var qs = 'INSERT INTO $1:name (' + columnsPattern + ') VALUES (' + valuesPattern + ')';\n      var values = [className].concat(_toConsumableArray(columnsArray), valuesArray);\n      debug(qs, values);\n      return this._client.any(qs, values).then(function () {\n        return { ops: [object] };\n      }).catch(function (error) {\n        if (error.code === PostgresUniqueIndexViolationError) {\n          throw new _node2.default.Error(_node2.default.Error.DUPLICATE_VALUE, 'A duplicate value for a field with unique values was provided');\n        } else {\n          throw error;\n        }\n      });\n    }\n\n    // Remove all objects that match the given Parse Query.\n    // If no objects match, reject with OBJECT_NOT_FOUND. If objects are found and deleted, resolve with undefined.\n    // If there is some other error, reject with INTERNAL_SERVER_ERROR.\n\n  }, {\n    key: 'deleteObjectsByQuery',\n    value: function deleteObjectsByQuery(className, schema, query) {\n      debug('deleteObjectsByQuery', className, query);\n      var values = [className];\n      var index = 2;\n      var where = buildWhereClause({ schema: schema, index: index, query: query });\n      values.push.apply(values, _toConsumableArray(where.values));\n      if (Object.keys(query).length === 0) {\n        where.pattern = 'TRUE';\n      }\n      var qs = 'WITH deleted AS (DELETE FROM $1:name WHERE ' + where.pattern + ' RETURNING *) SELECT count(*) FROM deleted';\n      debug(qs, values);\n      return this._client.one(qs, values, function (a) {\n        return +a.count;\n      }).then(function (count) {\n        if (count === 0) {\n          throw new _node2.default.Error(_node2.default.Error.OBJECT_NOT_FOUND, 'Object not found.');\n        } else {\n          return count;\n        }\n      });\n    }\n    // Return value not currently well specified.\n\n  }, {\n    key: 'findOneAndUpdate',\n    value: function findOneAndUpdate(className, schema, query, update) {\n      debug('findOneAndUpdate', className, query, update);\n      return this.updateObjectsByQuery(className, schema, query, update).then(function (val) {\n        return val[0];\n      });\n    }\n\n    // Apply the update to all objects that match the given Parse Query.\n\n  }, {\n    key: 'updateObjectsByQuery',\n    value: function updateObjectsByQuery(className, schema, query, update) {\n      debug('updateObjectsByQuery', className, query, update);\n      var updatePatterns = [];\n      var values = [className];\n      var index = 2;\n      schema = toPostgresSchema(schema);\n\n      var originalUpdate = _extends({}, update);\n      update = handleDotFields(update);\n      // Resolve authData first,\n      // So we don't end up with multiple key updates\n      for (var fieldName in update) {\n        var authDataMatch = fieldName.match(/^_auth_data_([a-zA-Z0-9_]+)$/);\n        if (authDataMatch) {\n          var provider = authDataMatch[1];\n          var value = update[fieldName];\n          delete update[fieldName];\n          update['authData'] = update['authData'] || {};\n          update['authData'][provider] = value;\n        }\n      }\n\n      var _loop2 = function _loop2(_fieldName) {\n        var fieldValue = update[_fieldName];\n        if (fieldValue === null) {\n          updatePatterns.push('$' + index + ':name = NULL');\n          values.push(_fieldName);\n          index += 1;\n        } else if (_fieldName == 'authData') {\n          // This recursively sets the json_object\n          // Only 1 level deep\n          var generate = function generate(jsonb, key, value) {\n            return 'json_object_set_key(COALESCE(' + jsonb + ', \\'{}\\'::jsonb), ' + key + ', ' + value + ')::jsonb';\n          };\n          var lastKey = '$' + index + ':name';\n          var fieldNameIndex = index;\n          index += 1;\n          values.push(_fieldName);\n          var _update = Object.keys(fieldValue).reduce(function (lastKey, key) {\n            var str = generate(lastKey, '$' + index + '::text', '$' + (index + 1) + '::jsonb');\n            index += 2;\n            var value = fieldValue[key];\n            if (value) {\n              if (value.__op === 'Delete') {\n                value = null;\n              } else {\n                value = JSON.stringify(value);\n              }\n            }\n            values.push(key, value);\n            return str;\n          }, lastKey);\n          updatePatterns.push('$' + fieldNameIndex + ':name = ' + _update);\n        } else if (fieldValue.__op === 'Increment') {\n          updatePatterns.push('$' + index + ':name = COALESCE($' + index + ':name, 0) + $' + (index + 1));\n          values.push(_fieldName, fieldValue.amount);\n          index += 2;\n        } else if (fieldValue.__op === 'Add') {\n          updatePatterns.push('$' + index + ':name = array_add(COALESCE($' + index + ':name, \\'[]\\'::jsonb), $' + (index + 1) + '::jsonb)');\n          values.push(_fieldName, JSON.stringify(fieldValue.objects));\n          index += 2;\n        } else if (fieldValue.__op === 'Delete') {\n          updatePatterns.push('$' + index + ':name = $' + (index + 1));\n          values.push(_fieldName, null);\n          index += 2;\n        } else if (fieldValue.__op === 'Remove') {\n          updatePatterns.push('$' + index + ':name = array_remove(COALESCE($' + index + ':name, \\'[]\\'::jsonb), $' + (index + 1) + '::jsonb)');\n          values.push(_fieldName, JSON.stringify(fieldValue.objects));\n          index += 2;\n        } else if (fieldValue.__op === 'AddUnique') {\n          updatePatterns.push('$' + index + ':name = array_add_unique(COALESCE($' + index + ':name, \\'[]\\'::jsonb), $' + (index + 1) + '::jsonb)');\n          values.push(_fieldName, JSON.stringify(fieldValue.objects));\n          index += 2;\n        } else if (_fieldName === 'updatedAt') {\n          //TODO: stop special casing this. It should check for __type === 'Date' and use .iso\n          updatePatterns.push('$' + index + ':name = $' + (index + 1));\n          values.push(_fieldName, fieldValue);\n          index += 2;\n        } else if (typeof fieldValue === 'string') {\n          updatePatterns.push('$' + index + ':name = $' + (index + 1));\n          values.push(_fieldName, fieldValue);\n          index += 2;\n        } else if (typeof fieldValue === 'boolean') {\n          updatePatterns.push('$' + index + ':name = $' + (index + 1));\n          values.push(_fieldName, fieldValue);\n          index += 2;\n        } else if (fieldValue.__type === 'Pointer') {\n          updatePatterns.push('$' + index + ':name = $' + (index + 1));\n          values.push(_fieldName, fieldValue.objectId);\n          index += 2;\n        } else if (fieldValue.__type === 'Date') {\n          updatePatterns.push('$' + index + ':name = $' + (index + 1));\n          values.push(_fieldName, toPostgresValue(fieldValue));\n          index += 2;\n        } else if (fieldValue instanceof Date) {\n          updatePatterns.push('$' + index + ':name = $' + (index + 1));\n          values.push(_fieldName, fieldValue);\n          index += 2;\n        } else if (fieldValue.__type === 'File') {\n          updatePatterns.push('$' + index + ':name = $' + (index + 1));\n          values.push(_fieldName, toPostgresValue(fieldValue));\n          index += 2;\n        } else if (fieldValue.__type === 'GeoPoint') {\n          updatePatterns.push('$' + index + ':name = POINT($' + (index + 1) + ', $' + (index + 2) + ')');\n          values.push(_fieldName, fieldValue.latitude, fieldValue.longitude);\n          index += 3;\n        } else if (fieldValue.__type === 'Relation') {\n          // noop\n        } else if (typeof fieldValue === 'number') {\n          updatePatterns.push('$' + index + ':name = $' + (index + 1));\n          values.push(_fieldName, fieldValue);\n          index += 2;\n        } else if ((typeof fieldValue === 'undefined' ? 'undefined' : _typeof(fieldValue)) === 'object' && schema.fields[_fieldName] && schema.fields[_fieldName].type === 'Object') {\n          // Gather keys to increment\n          var keysToIncrement = Object.keys(originalUpdate).filter(function (k) {\n            // choose top level fields that have a delete operation set\n            return originalUpdate[k].__op === 'Increment' && k.split('.').length === 2 && k.split(\".\")[0] === _fieldName;\n          }).map(function (k) {\n            return k.split('.')[1];\n          });\n\n          var incrementPatterns = '';\n          if (keysToIncrement.length > 0) {\n            incrementPatterns = ' || ' + keysToIncrement.map(function (c) {\n              var amount = fieldValue[c].amount;\n              return 'CONCAT(\\'{\"' + c + '\":\\', COALESCE($' + index + ':name->>\\'' + c + '\\',\\'0\\')::int + ' + amount + ', \\'}\\')::jsonb';\n            }).join(' || ');\n            // Strip the keys\n            keysToIncrement.forEach(function (key) {\n              delete fieldValue[key];\n            });\n          }\n\n          var keysToDelete = Object.keys(originalUpdate).filter(function (k) {\n            // choose top level fields that have a delete operation set\n            return originalUpdate[k].__op === 'Delete' && k.split('.').length === 2 && k.split(\".\")[0] === _fieldName;\n          }).map(function (k) {\n            return k.split('.')[1];\n          });\n\n          var deletePatterns = keysToDelete.reduce(function (p, c, i) {\n            return p + (' - \\'$' + (index + 1 + i) + ':value\\'');\n          }, '');\n\n          updatePatterns.push('$' + index + ':name = ( COALESCE($' + index + ':name, \\'{}\\'::jsonb) ' + deletePatterns + ' ' + incrementPatterns + ' || $' + (index + 1 + keysToDelete.length) + '::jsonb )');\n\n          values.push.apply(values, [_fieldName].concat(_toConsumableArray(keysToDelete), [JSON.stringify(fieldValue)]));\n          index += 2 + keysToDelete.length;\n        } else if (Array.isArray(fieldValue) && schema.fields[_fieldName] && schema.fields[_fieldName].type === 'Array') {\n          var expectedType = parseTypeToPostgresType(schema.fields[_fieldName]);\n          if (expectedType === 'text[]') {\n            updatePatterns.push('$' + index + ':name = $' + (index + 1) + '::text[]');\n          } else {\n            var type = 'text';\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = fieldValue[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var elt = _step.value;\n\n                if ((typeof elt === 'undefined' ? 'undefined' : _typeof(elt)) == 'object') {\n                  type = 'json';\n                  break;\n                }\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                  _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n\n            updatePatterns.push('$' + index + ':name = array_to_json($' + (index + 1) + '::' + type + '[])::jsonb');\n          }\n          values.push(_fieldName, fieldValue);\n          index += 2;\n        } else {\n          debug('Not supported update', _fieldName, fieldValue);\n          return {\n            v: Promise.reject(new _node2.default.Error(_node2.default.Error.OPERATION_FORBIDDEN, 'Postgres doesn\\'t support update ' + JSON.stringify(fieldValue) + ' yet'))\n          };\n        }\n      };\n\n      for (var _fieldName in update) {\n        var _ret2 = _loop2(_fieldName);\n\n        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n      }\n\n      var where = buildWhereClause({ schema: schema, index: index, query: query });\n      values.push.apply(values, _toConsumableArray(where.values));\n\n      var qs = 'UPDATE $1:name SET ' + updatePatterns.join(',') + ' WHERE ' + where.pattern + ' RETURNING *';\n      debug('update: ', qs, values);\n      return this._client.any(qs, values); // TODO: This is unsafe, verification is needed, or a different query method;\n    }\n\n    // Hopefully, we can get rid of this. It's only used for config and hooks.\n\n  }, {\n    key: 'upsertOneObject',\n    value: function upsertOneObject(className, schema, query, update) {\n      var _this8 = this;\n\n      debug('upsertOneObject', { className: className, query: query, update: update });\n      var createValue = Object.assign({}, query, update);\n      return this.createObject(className, schema, createValue).catch(function (err) {\n        // ignore duplicate value errors as it's upsert\n        if (err.code === _node2.default.Error.DUPLICATE_VALUE) {\n          return _this8.findOneAndUpdate(className, schema, query, update);\n        }\n        throw err;\n      });\n    }\n  }, {\n    key: 'find',\n    value: function find(className, schema, query, _ref3) {\n      var _values2;\n\n      var skip = _ref3.skip,\n          limit = _ref3.limit,\n          sort = _ref3.sort,\n          keys = _ref3.keys;\n\n      debug('find', className, query, { skip: skip, limit: limit, sort: sort, keys: keys });\n      var hasLimit = limit !== undefined;\n      var hasSkip = skip !== undefined;\n      var values = [className];\n      var where = buildWhereClause({ schema: schema, query: query, index: 2 });\n      (_values2 = values).push.apply(_values2, _toConsumableArray(where.values));\n\n      var wherePattern = where.pattern.length > 0 ? 'WHERE ' + where.pattern : '';\n      var limitPattern = hasLimit ? 'LIMIT $' + (values.length + 1) : '';\n      if (hasLimit) {\n        values.push(limit);\n      }\n      var skipPattern = hasSkip ? 'OFFSET $' + (values.length + 1) : '';\n      if (hasSkip) {\n        values.push(skip);\n      }\n\n      var sortPattern = '';\n      if (sort) {\n        var sorting = Object.keys(sort).map(function (key) {\n          // Using $idx pattern gives:  non-integer constant in ORDER BY\n          if (sort[key] === 1) {\n            return '\"' + key + '\" ASC';\n          }\n          return '\"' + key + '\" DESC';\n        }).join(',');\n        sortPattern = sort !== undefined && Object.keys(sort).length > 0 ? 'ORDER BY ' + sorting : '';\n      }\n      if (where.sorts && Object.keys(where.sorts).length > 0) {\n        sortPattern = 'ORDER BY ' + where.sorts.join(',');\n      }\n\n      var columns = '*';\n      if (keys) {\n        // Exclude empty keys\n        keys = keys.filter(function (key) {\n          return key.length > 0;\n        });\n        columns = keys.map(function (key, index) {\n          return '$' + (index + values.length + 1) + ':name';\n        }).join(',');\n        values = values.concat(keys);\n      }\n\n      var qs = 'SELECT ' + columns + ' FROM $1:name ' + wherePattern + ' ' + sortPattern + ' ' + limitPattern + ' ' + skipPattern;\n      debug(qs, values);\n      return this._client.any(qs, values).catch(function (err) {\n        // Query on non existing table, don't crash\n        if (err.code === PostgresRelationDoesNotExistError) {\n          return [];\n        }\n        return Promise.reject(err);\n      }).then(function (results) {\n        return results.map(function (object) {\n          Object.keys(schema.fields).forEach(function (fieldName) {\n            if (schema.fields[fieldName].type === 'Pointer' && object[fieldName]) {\n              object[fieldName] = { objectId: object[fieldName], __type: 'Pointer', className: schema.fields[fieldName].targetClass };\n            }\n            if (schema.fields[fieldName].type === 'Relation') {\n              object[fieldName] = {\n                __type: \"Relation\",\n                className: schema.fields[fieldName].targetClass\n              };\n            }\n            if (object[fieldName] && schema.fields[fieldName].type === 'GeoPoint') {\n              object[fieldName] = {\n                __type: \"GeoPoint\",\n                latitude: object[fieldName].y,\n                longitude: object[fieldName].x\n              };\n            }\n            if (object[fieldName] && schema.fields[fieldName].type === 'File') {\n              object[fieldName] = {\n                __type: 'File',\n                name: object[fieldName]\n              };\n            }\n          });\n          //TODO: remove this reliance on the mongo format. DB adapter shouldn't know there is a difference between created at and any other date field.\n          if (object.createdAt) {\n            object.createdAt = object.createdAt.toISOString();\n          }\n          if (object.updatedAt) {\n            object.updatedAt = object.updatedAt.toISOString();\n          }\n          if (object.expiresAt) {\n            object.expiresAt = { __type: 'Date', iso: object.expiresAt.toISOString() };\n          }\n          if (object._email_verify_token_expires_at) {\n            object._email_verify_token_expires_at = { __type: 'Date', iso: object._email_verify_token_expires_at.toISOString() };\n          }\n          if (object._account_lockout_expires_at) {\n            object._account_lockout_expires_at = { __type: 'Date', iso: object._account_lockout_expires_at.toISOString() };\n          }\n          if (object._perishable_token_expires_at) {\n            object._perishable_token_expires_at = { __type: 'Date', iso: object._perishable_token_expires_at.toISOString() };\n          }\n          if (object._password_changed_at) {\n            object._password_changed_at = { __type: 'Date', iso: object._password_changed_at.toISOString() };\n          }\n\n          for (var fieldName in object) {\n            if (object[fieldName] === null) {\n              delete object[fieldName];\n            }\n            if (object[fieldName] instanceof Date) {\n              object[fieldName] = { __type: 'Date', iso: object[fieldName].toISOString() };\n            }\n          }\n\n          return object;\n        });\n      });\n    }\n\n    // Create a unique index. Unique indexes on nullable fields are not allowed. Since we don't\n    // currently know which fields are nullable and which aren't, we ignore that criteria.\n    // As such, we shouldn't expose this function to users of parse until we have an out-of-band\n    // Way of determining if a field is nullable. Undefined doesn't count against uniqueness,\n    // which is why we use sparse indexes.\n\n  }, {\n    key: 'ensureUniqueness',\n    value: function ensureUniqueness(className, schema, fieldNames) {\n      // Use the same name for every ensureUniqueness attempt, because postgres\n      // Will happily create the same index with multiple names.\n      var constraintName = 'unique_' + fieldNames.sort().join('_');\n      var constraintPatterns = fieldNames.map(function (fieldName, index) {\n        return '$' + (index + 3) + ':name';\n      });\n      var qs = 'ALTER TABLE $1:name ADD CONSTRAINT $2:name UNIQUE (' + constraintPatterns.join(',') + ')';\n      return this._client.none(qs, [className, constraintName].concat(_toConsumableArray(fieldNames))).catch(function (error) {\n        if (error.code === PostgresDuplicateRelationError && error.message.includes(constraintName)) {\n          // Index already exists. Ignore error.\n        } else if (error.code === PostgresUniqueIndexViolationError && error.message.includes(constraintName)) {\n          // Cast the error into the proper parse error\n          throw new _node2.default.Error(_node2.default.Error.DUPLICATE_VALUE, 'A duplicate value for a field with unique values was provided');\n        } else {\n          throw error;\n        }\n      });\n    }\n\n    // Executes a count.\n\n  }, {\n    key: 'count',\n    value: function count(className, schema, query) {\n      debug('count', className, query);\n      var values = [className];\n      var where = buildWhereClause({ schema: schema, query: query, index: 2 });\n      values.push.apply(values, _toConsumableArray(where.values));\n\n      var wherePattern = where.pattern.length > 0 ? 'WHERE ' + where.pattern : '';\n      var qs = 'SELECT count(*) FROM $1:name ' + wherePattern;\n      return this._client.one(qs, values, function (a) {\n        return +a.count;\n      }).catch(function (err) {\n        if (err.code === PostgresRelationDoesNotExistError) {\n          return 0;\n        }\n        throw err;\n      });\n    }\n  }, {\n    key: 'performInitialization',\n    value: function performInitialization(_ref4) {\n      var _this9 = this;\n\n      var VolatileClassesSchemas = _ref4.VolatileClassesSchemas;\n\n      debug('performInitialization');\n      var promises = VolatileClassesSchemas.map(function (schema) {\n        return _this9.createTable(schema.className, schema).catch(function (err) {\n          if (err.code === PostgresDuplicateRelationError || err.code === _node2.default.Error.INVALID_CLASS_NAME) {\n            return Promise.resolve();\n          }\n          throw err;\n        });\n      });\n      return Promise.all(promises).then(function () {\n        return _this9._client.tx(function (t) {\n          return t.batch([t.none(_sql2.default.misc.jsonObjectSetKeys), t.none(_sql2.default.array.add), t.none(_sql2.default.array.addUnique), t.none(_sql2.default.array.remove), t.none(_sql2.default.array.containsAll), t.none(_sql2.default.array.contains)]);\n        });\n      }).then(function (data) {\n        debug('initializationDone in ' + data.duration);\n      }).catch(function (error) {\n        /* eslint-disable no-console */\n        console.error(error);\n      });\n    }\n  }]);\n\n  return PostgresStorageAdapter;\n}();\n\nfunction removeWhiteSpace(regex) {\n  if (!regex.endsWith('\\n')) {\n    regex += '\\n';\n  }\n\n  // remove non escaped comments\n  return regex.replace(/([^\\\\])#.*\\n/gmi, '$1')\n  // remove lines starting with a comment\n  .replace(/^#.*\\n/gmi, '')\n  // remove non escaped whitespace\n  .replace(/([^\\\\])\\s+/gmi, '$1')\n  // remove whitespace at the beginning of a line\n  .replace(/^\\s+/, '').trim();\n}\n\nfunction processRegexPattern(s) {\n  if (s && s.startsWith('^')) {\n    // regex for startsWith\n    return '^' + literalizeRegexPart(s.slice(1));\n  } else if (s && s.endsWith('$')) {\n    // regex for endsWith\n    return literalizeRegexPart(s.slice(0, s.length - 1)) + '$';\n  }\n\n  // regex for contains\n  return literalizeRegexPart(s);\n}\n\nfunction createLiteralRegex(remaining) {\n  return remaining.split('').map(function (c) {\n    if (c.match(/[0-9a-zA-Z]/) !== null) {\n      // don't escape alphanumeric characters\n      return c;\n    }\n    // escape everything else (single quotes with single quotes, everything else with a backslash)\n    return c === '\\'' ? '\\'\\'' : '\\\\' + c;\n  }).join('');\n}\n\nfunction literalizeRegexPart(s) {\n  var matcher1 = /\\\\Q((?!\\\\E).*)\\\\E$/;\n  var result1 = s.match(matcher1);\n  if (result1 && result1.length > 1 && result1.index > -1) {\n    // process regex that has a beginning and an end specified for the literal text\n    var prefix = s.substr(0, result1.index);\n    var remaining = result1[1];\n\n    return literalizeRegexPart(prefix) + createLiteralRegex(remaining);\n  }\n\n  // process regex that has a beginning specified for the literal text\n  var matcher2 = /\\\\Q((?!\\\\E).*)$/;\n  var result2 = s.match(matcher2);\n  if (result2 && result2.length > 1 && result2.index > -1) {\n    var _prefix = s.substr(0, result2.index);\n    var _remaining = result2[1];\n\n    return literalizeRegexPart(_prefix) + createLiteralRegex(_remaining);\n  }\n\n  // remove all instances of \\Q and \\E from the remaining text & escape single quotes\n  return s.replace(/([^\\\\])(\\\\E)/, '$1').replace(/([^\\\\])(\\\\Q)/, '$1').replace(/^\\\\E/, '').replace(/^\\\\Q/, '').replace(/([^'])'/, '$1\\'\\'').replace(/^'([^'])/, '\\'\\'$1');\n}\n\nexports.default = PostgresStorageAdapter;\n\nmodule.exports = PostgresStorageAdapter; // Required for tests","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Storage/Postgres/PostgresClient.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createClient = createClient;\n\nvar parser = require('./PostgresConfigParser');\n\nfunction createClient(uri, databaseOptions) {\n  var dbOptions = {};\n  databaseOptions = databaseOptions || {};\n\n  if (uri) {\n    dbOptions = parser.getDatabaseOptionsFromURI(uri);\n  }\n\n  for (var key in databaseOptions) {\n    dbOptions[key] = databaseOptions[key];\n  }\n\n  var initOptions = dbOptions.initOptions || {};\n  var pgp = require('pg-promise')(initOptions);\n  var client = pgp(dbOptions);\n\n  if (dbOptions.pgOptions) {\n    for (var _key in dbOptions.pgOptions) {\n      pgp.pg.defaults[_key] = dbOptions.pgOptions[_key];\n    }\n  }\n\n  return client;\n}","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Storage/Postgres/PostgresConfigParser.js":"'use strict';\n\nvar url = require('url');\n\nfunction getDatabaseOptionsFromURI(uri) {\n  var databaseOptions = {};\n\n  var parsedURI = url.parse(uri);\n  var queryParams = parseQueryParams(parsedURI.query);\n  var authParts = parsedURI.auth ? parsedURI.auth.split(':') : [];\n\n  databaseOptions.host = parsedURI.hostname || 'localhost';\n  databaseOptions.port = parsedURI.port ? parseInt(parsedURI.port) : 5432;\n  databaseOptions.database = parsedURI.pathname ? parsedURI.pathname.substr(1) : undefined;\n\n  databaseOptions.user = authParts.length > 0 ? authParts[0] : '';\n  databaseOptions.password = authParts.length > 1 ? authParts[1] : '';\n\n  databaseOptions.ssl = queryParams.ssl && queryParams.ssl.toLowerCase() === 'true' ? true : false;\n  databaseOptions.binary = queryParams.binary && queryParams.binary.toLowerCase() === 'true' ? true : false;\n\n  databaseOptions.client_encoding = queryParams.client_encoding;\n  databaseOptions.application_name = queryParams.application_name;\n  databaseOptions.fallback_application_name = queryParams.fallback_application_name;\n\n  if (queryParams.poolSize) {\n    databaseOptions.poolSize = parseInt(queryParams.poolSize) || 10;\n  }\n\n  return databaseOptions;\n}\n\nfunction parseQueryParams(queryString) {\n  queryString = queryString || '';\n\n  return queryString.split('&').reduce(function (p, c) {\n    var parts = c.split('=');\n    p[decodeURIComponent(parts[0])] = parts.length > 1 ? decodeURIComponent(parts.slice(1).join('=')) : '';\n    return p;\n  }, {});\n}\n\nmodule.exports = {\n  parseQueryParams: parseQueryParams,\n  getDatabaseOptionsFromURI: getDatabaseOptionsFromURI\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Storage/Postgres/sql/index.js":"'use strict';\n\nvar QueryFile = require('pg-promise').QueryFile;\nvar path = require('path');\n\nmodule.exports = {\n  array: {\n    add: sql('array/add.sql'),\n    addUnique: sql('array/add-unique.sql'),\n    contains: sql('array/contains.sql'),\n    containsAll: sql('array/contains-all.sql'),\n    remove: sql('array/remove.sql')\n  },\n  misc: {\n    jsonObjectSetKeys: sql('misc/json-object-set-keys.sql')\n  }\n};\n\n///////////////////////////////////////////////\n// Helper for linking to external query files;\nfunction sql(file) {\n\n  var fullPath = path.join(__dirname, file); // generating full path;\n\n  var qf = new QueryFile(fullPath, { minify: true });\n\n  if (qf.error) {\n    throw qf.error;\n  }\n\n  return qf;\n}","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/ParseServerRESTController.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Config = require('./Config');\nvar Auth = require('./Auth');\nvar RESTController = require('parse/lib/node/RESTController');\nvar URL = require('url');\nvar Parse = require('parse/node');\n\nfunction getSessionToken(options) {\n  if (options && typeof options.sessionToken === 'string') {\n    return Parse.Promise.as(options.sessionToken);\n  }\n  return Parse.Promise.as(null);\n}\n\nfunction getAuth() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var config = arguments[1];\n\n  var installationId = options.installationId || 'cloud';\n  if (options.useMasterKey) {\n    return Parse.Promise.as(new Auth.Auth({ config: config, isMaster: true, installationId: installationId }));\n  }\n  return getSessionToken(options).then(function (sessionToken) {\n    if (sessionToken) {\n      options.sessionToken = sessionToken;\n      return Auth.getAuthForSessionToken({\n        config: config,\n        sessionToken: sessionToken,\n        installationId: installationId\n      });\n    } else {\n      return Parse.Promise.as(new Auth.Auth({ config: config, installationId: installationId }));\n    }\n  });\n}\n\nfunction ParseServerRESTController(applicationId, router) {\n  function handleRequest(method, path) {\n    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    // Store the arguments, for later use if internal fails\n    var args = arguments;\n\n    var config = new Config(applicationId);\n    var serverURL = URL.parse(config.serverURL);\n    if (path.indexOf(serverURL.path) === 0) {\n      path = path.slice(serverURL.path.length, path.length);\n    }\n\n    if (path[0] !== \"/\") {\n      path = \"/\" + path;\n    }\n\n    if (path === '/batch') {\n      var promises = data.requests.map(function (request) {\n        return handleRequest(request.method, request.path, request.body, options).then(function (response) {\n          return Parse.Promise.as({ success: response });\n        }, function (error) {\n          return Parse.Promise.as({ error: { code: error.code, error: error.message } });\n        });\n      });\n      return Parse.Promise.all(promises);\n    }\n\n    var query = void 0;\n    if (method === 'GET') {\n      query = data;\n    }\n\n    return new Parse.Promise(function (resolve, reject) {\n      getAuth(options, config).then(function (auth) {\n        var request = {\n          body: data,\n          config: config,\n          auth: auth,\n          info: {\n            applicationId: applicationId,\n            sessionToken: options.sessionToken\n          },\n          query: query\n        };\n        return Promise.resolve().then(function () {\n          return router.tryRouteRequest(method, path, request);\n        }).then(function (response) {\n          resolve(response.response, response.status, response);\n        }, function (err) {\n          if (err instanceof Parse.Error && err.code == Parse.Error.INVALID_JSON && err.message == 'cannot route ' + method + ' ' + path) {\n            RESTController.request.apply(null, args).then(resolve, reject);\n          } else {\n            reject(err);\n          }\n        });\n      }, reject);\n    });\n  }\n\n  return {\n    request: handleRequest,\n    ajax: RESTController.ajax\n  };\n}\n\nexports.default = ParseServerRESTController;\nexports.ParseServerRESTController = ParseServerRESTController;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/batch.js":"'use strict';\n\nvar Parse = require('parse/node').Parse;\nvar url = require('url');\nvar path = require('path');\n// These methods handle batch requests.\nvar batchPath = '/batch';\n\n// Mounts a batch-handler onto a PromiseRouter.\nfunction mountOnto(router) {\n  router.route('POST', batchPath, function (req) {\n    return handleBatch(router, req);\n  });\n}\n\nfunction parseURL(URL) {\n  if (typeof URL === 'string') {\n    return url.parse(URL);\n  }\n  return undefined;\n}\n\nfunction makeBatchRoutingPathFunction(originalUrl, serverURL, publicServerURL) {\n  serverURL = serverURL ? parseURL(serverURL) : undefined;\n  publicServerURL = publicServerURL ? parseURL(publicServerURL) : undefined;\n\n  var apiPrefixLength = originalUrl.length - batchPath.length;\n  var apiPrefix = originalUrl.slice(0, apiPrefixLength);\n\n  var makeRoutablePath = function makeRoutablePath(requestPath) {\n    // The routablePath is the path minus the api prefix\n    if (requestPath.slice(0, apiPrefix.length) != apiPrefix) {\n      throw new Parse.Error(Parse.Error.INVALID_JSON, 'cannot route batch path ' + requestPath);\n    }\n    return path.posix.join('/', requestPath.slice(apiPrefix.length));\n  };\n\n  if (serverURL && publicServerURL && serverURL.path != publicServerURL.path) {\n    var localPath = serverURL.path;\n    var publicPath = publicServerURL.path;\n    // Override the api prefix\n    apiPrefix = localPath;\n    return function (requestPath) {\n      // Build the new path by removing the public path\n      // and joining with the local path\n      var newPath = path.posix.join('/', localPath, '/', requestPath.slice(publicPath.length));\n      // Use the method for local routing\n      return makeRoutablePath(newPath);\n    };\n  }\n\n  return makeRoutablePath;\n}\n\n// Returns a promise for a {response} object.\n// TODO: pass along auth correctly\nfunction handleBatch(router, req) {\n  if (!Array.isArray(req.body.requests)) {\n    throw new Parse.Error(Parse.Error.INVALID_JSON, 'requests must be an array');\n  }\n\n  // The batch paths are all from the root of our domain.\n  // That means they include the API prefix, that the API is mounted\n  // to. However, our promise router does not route the api prefix. So\n  // we need to figure out the API prefix, so that we can strip it\n  // from all the subrequests.\n  if (!req.originalUrl.endsWith(batchPath)) {\n    throw 'internal routing problem - expected url to end with batch';\n  }\n\n  var makeRoutablePath = makeBatchRoutingPathFunction(req.originalUrl, req.config.serverURL, req.config.publicServerURL);\n\n  var promises = req.body.requests.map(function (restRequest) {\n    var routablePath = makeRoutablePath(restRequest.path);\n    // Construct a request that we can send to a handler\n    var request = {\n      body: restRequest.body,\n      config: req.config,\n      auth: req.auth,\n      info: req.info\n    };\n\n    return router.tryRouteRequest(restRequest.method, routablePath, request).then(function (response) {\n      return { success: response.response };\n    }, function (error) {\n      return { error: { code: error.code, error: error.message } };\n    });\n  });\n\n  return Promise.all(promises).then(function (results) {\n    return { response: results };\n  });\n}\n\nmodule.exports = {\n  mountOnto: mountOnto,\n  makeBatchRoutingPathFunction: makeBatchRoutingPathFunction\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Auth/index.js":"'use strict';\n\nvar _AdapterLoader = require('../AdapterLoader');\n\nvar _AdapterLoader2 = _interopRequireDefault(_AdapterLoader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar facebook = require('./facebook');\nvar instagram = require(\"./instagram\");\nvar linkedin = require(\"./linkedin\");\nvar meetup = require(\"./meetup\");\nvar google = require(\"./google\");\nvar github = require(\"./github\");\nvar twitter = require(\"./twitter\");\nvar spotify = require(\"./spotify\");\nvar digits = require(\"./twitter\"); // digits tokens are validated by twitter\nvar janrainengage = require(\"./janrainengage\");\nvar janraincapture = require(\"./janraincapture\");\nvar vkontakte = require(\"./vkontakte\");\nvar qq = require(\"./qq\");\nvar wechat = require(\"./wechat\");\nvar weibo = require(\"./weibo\");\n\nvar anonymous = {\n  validateAuthData: function validateAuthData() {\n    return Promise.resolve();\n  },\n  validateAppId: function validateAppId() {\n    return Promise.resolve();\n  }\n};\n\nvar providers = {\n  facebook: facebook,\n  instagram: instagram,\n  linkedin: linkedin,\n  meetup: meetup,\n  google: google,\n  github: github,\n  twitter: twitter,\n  spotify: spotify,\n  anonymous: anonymous,\n  digits: digits,\n  janrainengage: janrainengage,\n  janraincapture: janraincapture,\n  vkontakte: vkontakte,\n  qq: qq,\n  wechat: wechat,\n  weibo: weibo\n};\n\nfunction authDataValidator(adapter, appIds, options) {\n  return function (authData) {\n    return adapter.validateAuthData(authData, options).then(function () {\n      if (appIds) {\n        return adapter.validateAppId(appIds, authData, options);\n      }\n      return Promise.resolve();\n    });\n  };\n}\n\nfunction loadAuthAdapter(provider, authOptions) {\n  var defaultAdapter = providers[provider];\n  var adapter = Object.assign({}, defaultAdapter);\n  var providerOptions = authOptions[provider];\n\n  if (!defaultAdapter && !providerOptions) {\n    return;\n  }\n\n  var appIds = providerOptions ? providerOptions.appIds : undefined;\n\n  // Try the configuration methods\n  if (providerOptions) {\n    var optionalAdapter = (0, _AdapterLoader2.default)(providerOptions, undefined, providerOptions);\n    if (optionalAdapter) {\n      ['validateAuthData', 'validateAppId'].forEach(function (key) {\n        if (optionalAdapter[key]) {\n          adapter[key] = optionalAdapter[key];\n        }\n      });\n    }\n  }\n\n  if (!adapter.validateAuthData || !adapter.validateAppId) {\n    return;\n  }\n\n  return { adapter: adapter, appIds: appIds, providerOptions: providerOptions };\n}\n\nmodule.exports = function () {\n  var authOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var enableAnonymousUsers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  var _enableAnonymousUsers = enableAnonymousUsers;\n  var setEnableAnonymousUsers = function setEnableAnonymousUsers(enable) {\n    _enableAnonymousUsers = enable;\n  };\n  // To handle the test cases on configuration\n  var getValidatorForProvider = function getValidatorForProvider(provider) {\n\n    if (provider === 'anonymous' && !_enableAnonymousUsers) {\n      return;\n    }\n\n    var _loadAuthAdapter = loadAuthAdapter(provider, authOptions),\n        adapter = _loadAuthAdapter.adapter,\n        appIds = _loadAuthAdapter.appIds,\n        providerOptions = _loadAuthAdapter.providerOptions;\n\n    return authDataValidator(adapter, appIds, providerOptions);\n  };\n\n  return Object.freeze({\n    getValidatorForProvider: getValidatorForProvider,\n    setEnableAnonymousUsers: setEnableAnonymousUsers\n  });\n};\n\nmodule.exports.loadAuthAdapter = loadAuthAdapter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Auth/facebook.js":"'use strict';\n\n// Helper functions for accessing the Facebook Graph API.\nvar https = require('https');\nvar Parse = require('parse/node').Parse;\n\n// Returns a promise that fulfills iff this user id is valid.\nfunction validateAuthData(authData) {\n  return graphRequest('me?fields=id&access_token=' + authData.access_token).then(function (data) {\n    if (data && data.id == authData.id) {\n      return;\n    }\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Facebook auth is invalid for this user.');\n  });\n}\n\n// Returns a promise that fulfills iff this app id is valid.\nfunction validateAppId(appIds, authData) {\n  var access_token = authData.access_token;\n  if (!appIds.length) {\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Facebook auth is not configured.');\n  }\n  return graphRequest('app?access_token=' + access_token).then(function (data) {\n    if (data && appIds.indexOf(data.id) != -1) {\n      return;\n    }\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Facebook auth is invalid for this user.');\n  });\n}\n\n// A promisey wrapper for FB graph requests.\nfunction graphRequest(path) {\n  return new Promise(function (resolve, reject) {\n    https.get('https://graph.facebook.com/v2.5/' + path, function (res) {\n      var data = '';\n      res.on('data', function (chunk) {\n        data += chunk;\n      });\n      res.on('end', function () {\n        data = JSON.parse(data);\n        resolve(data);\n      });\n    }).on('error', function () {\n      reject('Failed to validate this access token with Facebook.');\n    });\n  });\n}\n\nmodule.exports = {\n  validateAppId: validateAppId,\n  validateAuthData: validateAuthData\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Auth/instagram.js":"'use strict';\n\n// Helper functions for accessing the instagram API.\nvar https = require('https');\nvar Parse = require('parse/node').Parse;\n\n// Returns a promise that fulfills iff this user id is valid.\nfunction validateAuthData(authData) {\n  return request(\"users/self/?access_token=\" + authData.access_token).then(function (response) {\n    if (response && response.data && response.data.id == authData.id) {\n      return;\n    }\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Instagram auth is invalid for this user.');\n  });\n}\n\n// Returns a promise that fulfills iff this app id is valid.\nfunction validateAppId() {\n  return Promise.resolve();\n}\n\n// A promisey wrapper for api requests\nfunction request(path) {\n  return new Promise(function (resolve, reject) {\n    https.get(\"https://api.instagram.com/v1/\" + path, function (res) {\n      var data = '';\n      res.on('data', function (chunk) {\n        data += chunk;\n      });\n      res.on('end', function () {\n        data = JSON.parse(data);\n        resolve(data);\n      });\n    }).on('error', function () {\n      reject('Failed to validate this access token with Instagram.');\n    });\n  });\n}\n\nmodule.exports = {\n  validateAppId: validateAppId,\n  validateAuthData: validateAuthData\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Auth/linkedin.js":"'use strict';\n\n// Helper functions for accessing the linkedin API.\nvar https = require('https');\nvar Parse = require('parse/node').Parse;\n\n// Returns a promise that fulfills iff this user id is valid.\nfunction validateAuthData(authData) {\n  return request('people/~:(id)', authData.access_token, authData.is_mobile_sdk).then(function (data) {\n    if (data && data.id == authData.id) {\n      return;\n    }\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Linkedin auth is invalid for this user.');\n  });\n}\n\n// Returns a promise that fulfills iff this app id is valid.\nfunction validateAppId() {\n  return Promise.resolve();\n}\n\n// A promisey wrapper for api requests\nfunction request(path, access_token, is_mobile_sdk) {\n  var headers = {\n    'Authorization': 'Bearer ' + access_token,\n    'x-li-format': 'json'\n  };\n\n  if (is_mobile_sdk) {\n    headers['x-li-src'] = 'msdk';\n  }\n\n  return new Promise(function (resolve, reject) {\n    https.get({\n      host: 'api.linkedin.com',\n      path: '/v1/' + path,\n      headers: headers\n    }, function (res) {\n      var data = '';\n      res.on('data', function (chunk) {\n        data += chunk;\n      });\n      res.on('end', function () {\n        data = JSON.parse(data);\n        resolve(data);\n      });\n    }).on('error', function () {\n      reject('Failed to validate this access token with Linkedin.');\n    });\n  });\n}\n\nmodule.exports = {\n  validateAppId: validateAppId,\n  validateAuthData: validateAuthData\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Auth/meetup.js":"'use strict';\n\n// Helper functions for accessing the meetup API.\nvar https = require('https');\nvar Parse = require('parse/node').Parse;\n\n// Returns a promise that fulfills iff this user id is valid.\nfunction validateAuthData(authData) {\n  return request('member/self', authData.access_token).then(function (data) {\n    if (data && data.id == authData.id) {\n      return;\n    }\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Meetup auth is invalid for this user.');\n  });\n}\n\n// Returns a promise that fulfills iff this app id is valid.\nfunction validateAppId() {\n  return Promise.resolve();\n}\n\n// A promisey wrapper for api requests\nfunction request(path, access_token) {\n  return new Promise(function (resolve, reject) {\n    https.get({\n      host: 'api.meetup.com',\n      path: '/2/' + path,\n      headers: {\n        'Authorization': 'bearer ' + access_token\n      }\n    }, function (res) {\n      var data = '';\n      res.on('data', function (chunk) {\n        data += chunk;\n      });\n      res.on('end', function () {\n        data = JSON.parse(data);\n        resolve(data);\n      });\n    }).on('error', function () {\n      reject('Failed to validate this access token with Meetup.');\n    });\n  });\n}\n\nmodule.exports = {\n  validateAppId: validateAppId,\n  validateAuthData: validateAuthData\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Auth/google.js":"'use strict';\n\n// Helper functions for accessing the google API.\nvar https = require('https');\nvar Parse = require('parse/node').Parse;\n\nfunction validateIdToken(id, token) {\n  return request(\"tokeninfo?id_token=\" + token).then(function (response) {\n    if (response && (response.sub == id || response.user_id == id)) {\n      return;\n    }\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Google auth is invalid for this user.');\n  });\n}\n\nfunction validateAuthToken(id, token) {\n  return request(\"tokeninfo?access_token=\" + token).then(function (response) {\n    if (response && (response.sub == id || response.user_id == id)) {\n      return;\n    }\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Google auth is invalid for this user.');\n  });\n}\n\n// Returns a promise that fulfills if this user id is valid.\nfunction validateAuthData(authData) {\n  if (authData.id_token) {\n    return validateIdToken(authData.id, authData.id_token);\n  } else {\n    return validateAuthToken(authData.id, authData.access_token).then(function () {\n      // Validation with auth token worked\n      return;\n    }, function () {\n      // Try with the id_token param\n      return validateIdToken(authData.id, authData.access_token);\n    });\n  }\n}\n\n// Returns a promise that fulfills if this app id is valid.\nfunction validateAppId() {\n  return Promise.resolve();\n}\n\n// A promisey wrapper for api requests\nfunction request(path) {\n  return new Promise(function (resolve, reject) {\n    https.get(\"https://www.googleapis.com/oauth2/v3/\" + path, function (res) {\n      var data = '';\n      res.on('data', function (chunk) {\n        data += chunk;\n      });\n      res.on('end', function () {\n        data = JSON.parse(data);\n        resolve(data);\n      });\n    }).on('error', function () {\n      reject('Failed to validate this access token with Google.');\n    });\n  });\n}\n\nmodule.exports = {\n  validateAppId: validateAppId,\n  validateAuthData: validateAuthData\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Auth/github.js":"'use strict';\n\n// Helper functions for accessing the github API.\nvar https = require('https');\nvar Parse = require('parse/node').Parse;\n\n// Returns a promise that fulfills iff this user id is valid.\nfunction validateAuthData(authData) {\n  return request('user', authData.access_token).then(function (data) {\n    if (data && data.id == authData.id) {\n      return;\n    }\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Github auth is invalid for this user.');\n  });\n}\n\n// Returns a promise that fulfills iff this app id is valid.\nfunction validateAppId() {\n  return Promise.resolve();\n}\n\n// A promisey wrapper for api requests\nfunction request(path, access_token) {\n  return new Promise(function (resolve, reject) {\n    https.get({\n      host: 'api.github.com',\n      path: '/' + path,\n      headers: {\n        'Authorization': 'bearer ' + access_token,\n        'User-Agent': 'parse-server'\n      }\n    }, function (res) {\n      var data = '';\n      res.on('data', function (chunk) {\n        data += chunk;\n      });\n      res.on('end', function () {\n        data = JSON.parse(data);\n        resolve(data);\n      });\n    }).on('error', function () {\n      reject('Failed to validate this access token with Github.');\n    });\n  });\n}\n\nmodule.exports = {\n  validateAppId: validateAppId,\n  validateAuthData: validateAuthData\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Auth/twitter.js":"'use strict';\n\n// Helper functions for accessing the twitter API.\nvar OAuth = require('./OAuth1Client');\nvar Parse = require('parse/node').Parse;\nvar logger = require('../../logger').default;\n\n// Returns a promise that fulfills iff this user id is valid.\nfunction validateAuthData(authData, options) {\n  if (!options) {\n    throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, 'Twitter auth configuration missing');\n  }\n  options = handleMultipleConfigurations(authData, options);\n  var client = new OAuth(options);\n  client.host = \"api.twitter.com\";\n  client.auth_token = authData.auth_token;\n  client.auth_token_secret = authData.auth_token_secret;\n\n  return client.get(\"/1.1/account/verify_credentials.json\").then(function (data) {\n    if (data && data.id_str == '' + authData.id) {\n      return;\n    }\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Twitter auth is invalid for this user.');\n  });\n}\n\n// Returns a promise that fulfills iff this app id is valid.\nfunction validateAppId() {\n  return Promise.resolve();\n}\n\nfunction handleMultipleConfigurations(authData, options) {\n  if (Array.isArray(options)) {\n    var consumer_key = authData.consumer_key;\n    if (!consumer_key) {\n      logger.error('Twitter Auth', 'Multiple twitter configurations are available, by no consumer_key was sent by the client.');\n      throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Twitter auth is invalid for this user.');\n    }\n    options = options.filter(function (option) {\n      return option.consumer_key == consumer_key;\n    });\n\n    if (options.length == 0) {\n      logger.error('Twitter Auth', 'Cannot find a configuration for the provided consumer_key');\n      throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Twitter auth is invalid for this user.');\n    }\n    options = options[0];\n  }\n  return options;\n}\n\nmodule.exports = {\n  validateAppId: validateAppId,\n  validateAuthData: validateAuthData,\n  handleMultipleConfigurations: handleMultipleConfigurations\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Auth/OAuth1Client.js":"'use strict';\n\nvar https = require('https'),\n    crypto = require('crypto');\nvar Parse = require('parse/node').Parse;\n\nvar OAuth = function OAuth(options) {\n  if (!options) {\n    throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, 'No options passed to OAuth');\n  }\n  this.consumer_key = options.consumer_key;\n  this.consumer_secret = options.consumer_secret;\n  this.auth_token = options.auth_token;\n  this.auth_token_secret = options.auth_token_secret;\n  this.host = options.host;\n  this.oauth_params = options.oauth_params || {};\n};\n\nOAuth.prototype.send = function (method, path, params, body) {\n\n  var request = this.buildRequest(method, path, params, body);\n  // Encode the body properly, the current Parse Implementation don't do it properly\n  return new Promise(function (resolve, reject) {\n    var httpRequest = https.request(request, function (res) {\n      var data = '';\n      res.on('data', function (chunk) {\n        data += chunk;\n      });\n      res.on('end', function () {\n        data = JSON.parse(data);\n        resolve(data);\n      });\n    }).on('error', function () {\n      reject('Failed to make an OAuth request');\n    });\n    if (request.body) {\n      httpRequest.write(request.body);\n    }\n    httpRequest.end();\n  });\n};\n\nOAuth.prototype.buildRequest = function (method, path, params, body) {\n  if (path.indexOf(\"/\") != 0) {\n    path = \"/\" + path;\n  }\n  if (params && Object.keys(params).length > 0) {\n    path += \"?\" + OAuth.buildParameterString(params);\n  }\n\n  var request = {\n    host: this.host,\n    path: path,\n    method: method.toUpperCase()\n  };\n\n  var oauth_params = this.oauth_params || {};\n  oauth_params.oauth_consumer_key = this.consumer_key;\n  if (this.auth_token) {\n    oauth_params[\"oauth_token\"] = this.auth_token;\n  }\n\n  request = OAuth.signRequest(request, oauth_params, this.consumer_secret, this.auth_token_secret);\n\n  if (body && Object.keys(body).length > 0) {\n    request.body = OAuth.buildParameterString(body);\n  }\n  return request;\n};\n\nOAuth.prototype.get = function (path, params) {\n  return this.send(\"GET\", path, params);\n};\n\nOAuth.prototype.post = function (path, params, body) {\n  return this.send(\"POST\", path, params, body);\n};\n\n/*\n\tProper string %escape encoding\n*/\nOAuth.encode = function (str) {\n  //       discuss at: http://phpjs.org/functions/rawurlencode/\n  //      original by: Brett Zamir (http://brett-zamir.me)\n  //         input by: travc\n  //         input by: Brett Zamir (http://brett-zamir.me)\n  //         input by: Michael Grier\n  //         input by: Ratheous\n  //      bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n  //      bugfixed by: Brett Zamir (http://brett-zamir.me)\n  //      bugfixed by: Joris\n  // reimplemented by: Brett Zamir (http://brett-zamir.me)\n  // reimplemented by: Brett Zamir (http://brett-zamir.me)\n  //             note: This reflects PHP 5.3/6.0+ behavior\n  //             note: Please be aware that this function expects to encode into UTF-8 encoded strings, as found on\n  //             note: pages served as UTF-8\n  //        example 1: rawurlencode('Kevin van Zonneveld!');\n  //        returns 1: 'Kevin%20van%20Zonneveld%21'\n  //        example 2: rawurlencode('http://kevin.vanzonneveld.net/');\n  //        returns 2: 'http%3A%2F%2Fkevin.vanzonneveld.net%2F'\n  //        example 3: rawurlencode('http://www.google.nl/search?q=php.js&ie=utf-8&oe=utf-8&aq=t&rls=com.ubuntu:en-US:unofficial&client=firefox-a');\n  //        returns 3: 'http%3A%2F%2Fwww.google.nl%2Fsearch%3Fq%3Dphp.js%26ie%3Dutf-8%26oe%3Dutf-8%26aq%3Dt%26rls%3Dcom.ubuntu%3Aen-US%3Aunofficial%26client%3Dfirefox-a'\n\n  str = (str + '').toString();\n\n  // Tilde should be allowed unescaped in future versions of PHP (as reflected below), but if you want to reflect current\n  // PHP behavior, you would need to add \".replace(/~/g, '%7E');\" to the following.\n  return encodeURIComponent(str).replace(/!/g, '%21').replace(/'/g, '%27').replace(/\\(/g, '%28').replace(/\\)/g, '%29').replace(/\\*/g, '%2A');\n};\n\nOAuth.signatureMethod = \"HMAC-SHA1\";\nOAuth.version = \"1.0\";\n\n/*\n\tGenerate a nonce\n*/\nOAuth.nonce = function () {\n  var text = \"\";\n  var possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\n  for (var i = 0; i < 30; i++) {\n    text += possible.charAt(Math.floor(Math.random() * possible.length));\n  }return text;\n};\n\nOAuth.buildParameterString = function (obj) {\n  // Sort keys and encode values\n  if (obj) {\n    var keys = Object.keys(obj).sort();\n\n    // Map key=value, join them by &\n    return keys.map(function (key) {\n      return key + \"=\" + OAuth.encode(obj[key]);\n    }).join(\"&\");\n  }\n\n  return \"\";\n};\n\n/*\n\tBuild the signature string from the object\n*/\n\nOAuth.buildSignatureString = function (method, url, parameters) {\n  return [method.toUpperCase(), OAuth.encode(url), OAuth.encode(parameters)].join(\"&\");\n};\n\n/*\n\tRetuns encoded HMAC-SHA1 from key and text\n*/\nOAuth.signature = function (text, key) {\n  crypto = require(\"crypto\");\n  return OAuth.encode(crypto.createHmac('sha1', key).update(text).digest('base64'));\n};\n\nOAuth.signRequest = function (request, oauth_parameters, consumer_secret, auth_token_secret) {\n  oauth_parameters = oauth_parameters || {};\n\n  // Set default values\n  if (!oauth_parameters.oauth_nonce) {\n    oauth_parameters.oauth_nonce = OAuth.nonce();\n  }\n  if (!oauth_parameters.oauth_timestamp) {\n    oauth_parameters.oauth_timestamp = Math.floor(new Date().getTime() / 1000);\n  }\n  if (!oauth_parameters.oauth_signature_method) {\n    oauth_parameters.oauth_signature_method = OAuth.signatureMethod;\n  }\n  if (!oauth_parameters.oauth_version) {\n    oauth_parameters.oauth_version = OAuth.version;\n  }\n\n  if (!auth_token_secret) {\n    auth_token_secret = \"\";\n  }\n  // Force GET method if unset\n  if (!request.method) {\n    request.method = \"GET\";\n  }\n\n  // Collect  all the parameters in one signatureParameters object\n  var signatureParams = {};\n  var parametersToMerge = [request.params, request.body, oauth_parameters];\n  for (var i in parametersToMerge) {\n    var parameters = parametersToMerge[i];\n    for (var k in parameters) {\n      signatureParams[k] = parameters[k];\n    }\n  }\n\n  // Create a string based on the parameters\n  var parameterString = OAuth.buildParameterString(signatureParams);\n\n  // Build the signature string\n  var url = \"https://\" + request.host + \"\" + request.path;\n\n  var signatureString = OAuth.buildSignatureString(request.method, url, parameterString);\n  // Hash the signature string\n  var signatureKey = [OAuth.encode(consumer_secret), OAuth.encode(auth_token_secret)].join(\"&\");\n\n  var signature = OAuth.signature(signatureString, signatureKey);\n\n  // Set the signature in the params\n  oauth_parameters.oauth_signature = signature;\n  if (!request.headers) {\n    request.headers = {};\n  }\n\n  // Set the authorization header\n  var authHeader = Object.keys(oauth_parameters).sort().map(function (key) {\n    var value = oauth_parameters[key];\n    return key + '=\"' + value + '\"';\n  }).join(\", \");\n\n  request.headers.Authorization = 'OAuth ' + authHeader;\n\n  // Set the content type header\n  request.headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n  return request;\n};\n\nmodule.exports = OAuth;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Auth/spotify.js":"'use strict';\n\n// Helper functions for accessing the Spotify API.\nvar https = require('https');\nvar Parse = require('parse/node').Parse;\n\n// Returns a promise that fulfills iff this user id is valid.\nfunction validateAuthData(authData) {\n  return request('me', authData.access_token).then(function (data) {\n    if (data && data.id == authData.id) {\n      return;\n    }\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Spotify auth is invalid for this user.');\n  });\n}\n\n// Returns a promise that fulfills if this app id is valid.\nfunction validateAppId(appIds, authData) {\n  var access_token = authData.access_token;\n  if (!appIds.length) {\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Spotify auth is not configured.');\n  }\n  return request('me', access_token).then(function (data) {\n    if (data && appIds.indexOf(data.id) != -1) {\n      return;\n    }\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Spotify auth is invalid for this user.');\n  });\n}\n\n// A promisey wrapper for Spotify API requests.\nfunction request(path, access_token) {\n  return new Promise(function (resolve, reject) {\n    https.get({\n      host: 'api.spotify.com',\n      path: '/v1/' + path,\n      headers: {\n        'Authorization': 'Bearer ' + access_token\n      }\n    }, function (res) {\n      var data = '';\n      res.on('data', function (chunk) {\n        data += chunk;\n      });\n      res.on('end', function () {\n        data = JSON.parse(data);\n        resolve(data);\n      });\n    }).on('error', function () {\n      reject('Failed to validate this access token with Spotify.');\n    });\n  });\n}\n\nmodule.exports = {\n  validateAppId: validateAppId,\n  validateAuthData: validateAuthData\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Auth/janrainengage.js":"'use strict';\n\n// Helper functions for accessing the Janrain Engage API.\nvar https = require('https');\nvar Parse = require('parse/node').Parse;\nvar querystring = require('querystring');\n\n// Returns a promise that fulfills iff this user id is valid.\nfunction validateAuthData(authData, options) {\n  return request(options.api_key, authData.auth_token).then(function (data) {\n    //successful response will have a \"stat\" (status) of 'ok' and a profile node with an identifier\n    //see: http://developers.janrain.com/overview/social-login/identity-providers/user-profile-data/#normalized-user-profile-data\n    if (data && data.stat == 'ok' && data.profile.identifier == authData.id) {\n      return;\n    }\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Janrain engage auth is invalid for this user.');\n  });\n}\n\n// Returns a promise that fulfills iff this app id is valid.\nfunction validateAppId() {\n  //no-op\n  return Promise.resolve();\n}\n\n// A promisey wrapper for api requests\nfunction request(api_key, auth_token) {\n\n  var post_data = querystring.stringify({\n    'token': auth_token,\n    'apiKey': api_key,\n    'format': 'json'\n  });\n\n  var post_options = {\n    host: 'rpxnow.com',\n    path: '/api/v2/auth_info',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'Content-Length': post_data.length\n    }\n  };\n\n  return new Promise(function (resolve) {\n    // Create the post request.\n    var post_req = https.request(post_options, function (res) {\n      var data = '';\n      res.setEncoding('utf8');\n      // Append data as we receive it from the Janrain engage server.\n      res.on('data', function (d) {\n        data += d;\n      });\n      // Once we have all the data, we can parse it and return the data we want.\n      res.on('end', function () {\n        resolve(JSON.parse(data));\n      });\n    });\n\n    post_req.write(post_data);\n    post_req.end();\n  });\n}\n\nmodule.exports = {\n  validateAppId: validateAppId,\n  validateAuthData: validateAuthData\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Auth/janraincapture.js":"'use strict';\n\n// Helper functions for accessing the Janrain Capture API.\nvar https = require('https');\nvar Parse = require('parse/node').Parse;\nvar querystring = require('querystring');\n\n// Returns a promise that fulfills iff this user id is valid.\nfunction validateAuthData(authData, options) {\n  return request(options.janrain_capture_host, authData.access_token).then(function (data) {\n    //successful response will have a \"stat\" (status) of 'ok' and a result node that stores the uuid, because that's all we asked for\n    //see: https://docs.janrain.com/api/registration/entity/#entity\n    if (data && data.stat == 'ok' && data.result == authData.id) {\n      return;\n    }\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Janrain capture auth is invalid for this user.');\n  });\n}\n\n// Returns a promise that fulfills iff this app id is valid.\nfunction validateAppId() {\n  //no-op\n  return Promise.resolve();\n}\n\n// A promisey wrapper for api requests\nfunction request(host, access_token) {\n\n  var query_string_data = querystring.stringify({\n    'access_token': access_token,\n    'attribute_name': 'uuid' // we only need to pull the uuid for this access token to make sure it matches\n  });\n\n  return new Promise(function (resolve, reject) {\n    https.get({\n      host: host,\n      path: '/entity?' + query_string_data\n    }, function (res) {\n      var data = '';\n      res.on('data', function (chunk) {\n        data += chunk;\n      });\n      res.on('end', function () {\n        resolve(JSON.parse(data));\n      });\n    }).on('error', function () {\n      reject('Failed to validate this access token with Janrain capture.');\n    });\n  });\n}\n\nmodule.exports = {\n  validateAppId: validateAppId,\n  validateAuthData: validateAuthData\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Auth/vkontakte.js":"'use strict';\n\n// Helper functions for accessing the vkontakte API.\n\nvar https = require('https');\nvar Parse = require('parse/node').Parse;\nvar logger = require('../../logger').default;\n\n// Returns a promise that fulfills iff this user id is valid.\nfunction validateAuthData(authData, params) {\n  return vkOAuth2Request(params).then(function (response) {\n    if (response && response && response.access_token) {\n      return request(\"api.vk.com\", \"method/secure.checkToken?token=\" + authData.access_token + \"&client_secret=\" + params.appSecret + \"&access_token=\" + response.access_token).then(function (response) {\n        if (response && response.response && response.response.user_id == authData.id) {\n          return;\n        }\n        throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Vk auth is invalid for this user.');\n      });\n    }\n    logger.error('Vk Auth', 'Vk appIds or appSecret is incorrect.');\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Vk appIds or appSecret is incorrect.');\n  });\n}\n\nfunction vkOAuth2Request(params) {\n  var promise = new Parse.Promise();\n  return promise.then(function () {\n    if (!params || !params.appIds || !params.appIds.length || !params.appSecret || !params.appSecret.length) {\n      logger.error('Vk Auth', 'Vk auth is not configured. Missing appIds or appSecret.');\n      throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Vk auth is not configured. Missing appIds or appSecret.');\n    }\n    return request(\"oauth.vk.com\", \"access_token?client_id=\" + params.appIds + \"&client_secret=\" + params.appSecret + \"&v=5.59&grant_type=client_credentials\");\n  });\n}\n\n// Returns a promise that fulfills iff this app id is valid.\nfunction validateAppId() {\n  return Promise.resolve();\n}\n\n// A promisey wrapper for api requests\nfunction request(host, path) {\n  return new Promise(function (resolve, reject) {\n    https.get(\"https://\" + host + \"/\" + path, function (res) {\n      var data = '';\n      res.on('data', function (chunk) {\n        data += chunk;\n      });\n      res.on('end', function () {\n        data = JSON.parse(data);\n        resolve(data);\n      });\n    }).on('error', function () {\n      reject('Failed to validate this access token with Vk.');\n    });\n  });\n}\n\nmodule.exports = {\n  validateAppId: validateAppId,\n  validateAuthData: validateAuthData\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Auth/qq.js":"'use strict';\n\n// Helper functions for accessing the qq Graph API.\nvar https = require('https');\nvar Parse = require('parse/node').Parse;\n\n// Returns a promise that fulfills iff this user id is valid.\nfunction validateAuthData(authData) {\n  return graphRequest('me?access_token=' + authData.access_token).then(function (data) {\n    if (data && data.openid == authData.id) {\n      return;\n    }\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'qq auth is invalid for this user.');\n  });\n}\n\n// Returns a promise that fulfills if this app id is valid.\nfunction validateAppId() {\n  return Promise.resolve();\n}\n\n// A promisey wrapper for qq graph requests.\nfunction graphRequest(path) {\n  return new Promise(function (resolve, reject) {\n    https.get('https://graph.qq.com/oauth2.0/' + path, function (res) {\n      var data = '';\n      res.on('data', function (chunk) {\n        data += chunk;\n      });\n      res.on('end', function () {\n        var starPos = data.indexOf(\"(\");\n        var endPos = data.indexOf(\")\");\n        if (starPos == -1 || endPos == -1) {\n          throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'qq auth is invalid for this user.');\n        }\n        data = data.substring(starPos + 1, endPos - 1);\n        data = JSON.parse(data);\n        resolve(data);\n      });\n    }).on('error', function () {\n      reject('Failed to validate this access token with qq.');\n    });\n  });\n}\n\nmodule.exports = {\n  validateAppId: validateAppId,\n  validateAuthData: validateAuthData\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Auth/wechat.js":"'use strict';\n\n// Helper functions for accessing the WeChat Graph API.\nvar https = require('https');\nvar Parse = require('parse/node').Parse;\n\n// Returns a promise that fulfills iff this user id is valid.\nfunction validateAuthData(authData) {\n  return graphRequest('auth?access_token=' + authData.access_token + '&openid=' + authData.id).then(function (data) {\n    if (data.errcode == 0) {\n      return;\n    }\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'qq auth is invalid for this user.');\n  });\n}\n\n// Returns a promise that fulfills if this app id is valid.\nfunction validateAppId() {\n  return Promise.resolve();\n}\n\n// A promisey wrapper for WeChat graph requests.\nfunction graphRequest(path) {\n  return new Promise(function (resolve, reject) {\n    https.get('https://api.weixin.qq.com/sns/' + path, function (res) {\n      var data = '';\n      res.on('data', function (chunk) {\n        data += chunk;\n      });\n      res.on('end', function () {\n        data = JSON.parse(data);\n        resolve(data);\n      });\n    }).on('error', function () {\n      reject('Failed to validate this access token with weixin.');\n    });\n  });\n}\n\nmodule.exports = {\n  validateAppId: validateAppId,\n  validateAuthData: validateAuthData\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Auth/weibo.js":"'use strict';\n\n// Helper functions for accessing the weibo Graph API.\nvar https = require('https');\nvar Parse = require('parse/node').Parse;\nvar querystring = require('querystring');\n\n// Returns a promise that fulfills iff this user id is valid.\nfunction validateAuthData(authData) {\n  return graphRequest(authData.access_token).then(function (data) {\n    if (data && data.uid == authData.id) {\n      return;\n    }\n    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'weibo auth is invalid for this user.');\n  });\n}\n\n// Returns a promise that fulfills if this app id is valid.\nfunction validateAppId() {\n  return Promise.resolve();\n}\n\n// A promisey wrapper for weibo graph requests.\nfunction graphRequest(access_token) {\n  return new Promise(function (resolve, reject) {\n    var postData = querystring.stringify({\n      \"access_token\": access_token\n    });\n    var options = {\n      hostname: 'api.weibo.com',\n      path: '/oauth2/get_token_info',\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Content-Length': Buffer.byteLength(postData)\n      }\n    };\n    var req = https.request(options, function (res) {\n      var data = '';\n      res.on('data', function (chunk) {\n        data += chunk;\n      });\n      res.on('end', function () {\n        data = JSON.parse(data);\n        resolve(data);\n      });\n      res.on('error', function () {\n        reject('Failed to validate this access token with weibo.');\n      });\n    });\n    req.on('error', function () {\n      reject('Failed to validate this access token with weibo.');\n    });\n    req.write(postData);\n    req.end();\n  });\n}\n\nmodule.exports = {\n  validateAppId: validateAppId,\n  validateAuthData: validateAuthData\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/cloud-code/Parse.Cloud.js":"'use strict';\n\nvar _node = require('parse/node');\n\nvar _triggers = require('../triggers');\n\nvar triggers = _interopRequireWildcard(_triggers);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction validateClassNameForTriggers(className) {\n  var restrictedClassNames = ['_Session'];\n  if (restrictedClassNames.indexOf(className) != -1) {\n    throw 'Triggers are not supported for ' + className + ' class.';\n  }\n  return className;\n}\n\nfunction getClassName(parseClass) {\n  if (parseClass && parseClass.className) {\n    return validateClassNameForTriggers(parseClass.className);\n  }\n  return validateClassNameForTriggers(parseClass);\n}\n\nvar ParseCloud = {};\nParseCloud.define = function (functionName, handler, validationHandler) {\n  triggers.addFunction(functionName, handler, validationHandler, _node.Parse.applicationId);\n};\n\nParseCloud.job = function (functionName, handler) {\n  triggers.addJob(functionName, handler, _node.Parse.applicationId);\n};\n\nParseCloud.beforeSave = function (parseClass, handler) {\n  var className = getClassName(parseClass);\n  triggers.addTrigger(triggers.Types.beforeSave, className, handler, _node.Parse.applicationId);\n};\n\nParseCloud.beforeDelete = function (parseClass, handler) {\n  var className = getClassName(parseClass);\n  triggers.addTrigger(triggers.Types.beforeDelete, className, handler, _node.Parse.applicationId);\n};\n\nParseCloud.afterSave = function (parseClass, handler) {\n  var className = getClassName(parseClass);\n  triggers.addTrigger(triggers.Types.afterSave, className, handler, _node.Parse.applicationId);\n};\n\nParseCloud.afterDelete = function (parseClass, handler) {\n  var className = getClassName(parseClass);\n  triggers.addTrigger(triggers.Types.afterDelete, className, handler, _node.Parse.applicationId);\n};\n\nParseCloud.beforeFind = function (parseClass, handler) {\n  var className = getClassName(parseClass);\n  triggers.addTrigger(triggers.Types.beforeFind, className, handler, _node.Parse.applicationId);\n};\n\nParseCloud.afterFind = function (parseClass, handler) {\n  var className = getClassName(parseClass);\n  triggers.addTrigger(triggers.Types.afterFind, className, handler, _node.Parse.applicationId);\n};\n\nParseCloud._removeAllHooks = function () {\n  triggers._unregisterAll();\n};\n\nParseCloud.useMasterKey = function () {\n  // eslint-disable-next-line\n  console.warn(\"Parse.Cloud.useMasterKey is deprecated (and has no effect anymore) on parse-server, please refer to the cloud code migration notes: https://github.com/ParsePlatform/parse-server/wiki/Compatibility-with-Hosted-Parse#cloud-code\");\n};\n\nParseCloud.httpRequest = require(\"./httpRequest\");\n\nmodule.exports = ParseCloud;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/cloud-code/httpRequest.js":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _request = require('request');\n\nvar _request2 = _interopRequireDefault(_request);\n\nvar _node = require('parse/node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _HTTPResponse = require('./HTTPResponse');\n\nvar _HTTPResponse2 = _interopRequireDefault(_HTTPResponse);\n\nvar _querystring = require('querystring');\n\nvar _querystring2 = _interopRequireDefault(_querystring);\n\nvar _logger = require('../logger');\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar encodeBody = function encodeBody(_ref) {\n  var body = _ref.body,\n      _ref$headers = _ref.headers,\n      headers = _ref$headers === undefined ? {} : _ref$headers;\n\n  if ((typeof body === 'undefined' ? 'undefined' : _typeof(body)) !== 'object') {\n    return { body: body, headers: headers };\n  }\n  var contentTypeKeys = Object.keys(headers).filter(function (key) {\n    return key.match(/content-type/i) != null;\n  });\n\n  if (contentTypeKeys.length == 0) {\n    // no content type\n    //  As per https://parse.com/docs/cloudcode/guide#cloud-code-advanced-sending-a-post-request the default encoding is supposedly x-www-form-urlencoded\n\n    body = _querystring2.default.stringify(body);\n    headers['Content-Type'] = 'application/x-www-form-urlencoded';\n  } else {\n    /* istanbul ignore next */\n    if (contentTypeKeys.length > 1) {\n      _logger2.default.error('Parse.Cloud.httpRequest', 'multiple content-type headers are set.');\n    }\n    // There maybe many, we'll just take the 1st one\n    var contentType = contentTypeKeys[0];\n    if (headers[contentType].match(/application\\/json/i)) {\n      body = JSON.stringify(body);\n    } else if (headers[contentType].match(/application\\/x-www-form-urlencoded/i)) {\n      body = _querystring2.default.stringify(body);\n    }\n  }\n  return { body: body, headers: headers };\n};\n\nmodule.exports = function (options) {\n  var promise = new _node2.default.Promise();\n  var callbacks = {\n    success: options.success,\n    error: options.error\n  };\n  delete options.success;\n  delete options.error;\n  delete options.uri; // not supported\n  options = Object.assign(options, encodeBody(options));\n  // set follow redirects to false by default\n  options.followRedirect = options.followRedirects == true;\n  // support params options\n  if (_typeof(options.params) === 'object') {\n    options.qs = options.params;\n  } else if (typeof options.params === 'string') {\n    options.qs = _querystring2.default.parse(options.params);\n  }\n  // force the response as a buffer\n  options.encoding = null;\n\n  (0, _request2.default)(options, function (error, response, body) {\n    if (error) {\n      if (callbacks.error) {\n        callbacks.error(error);\n      }\n      return promise.reject(error);\n    }\n    var httpResponse = new _HTTPResponse2.default(response, body);\n\n    // Consider <200 && >= 400 as errors\n    if (httpResponse.status < 200 || httpResponse.status >= 400) {\n      if (callbacks.error) {\n        callbacks.error(httpResponse);\n      }\n      return promise.reject(httpResponse);\n    } else {\n      if (callbacks.success) {\n        callbacks.success(httpResponse);\n      }\n      return promise.resolve(httpResponse);\n    }\n  });\n  return promise;\n};\n\nmodule.exports.encodeBody = encodeBody;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/cloud-code/HTTPResponse.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar HTTPResponse = function HTTPResponse(response, body) {\n  var _this = this;\n\n  _classCallCheck(this, HTTPResponse);\n\n  var _text = void 0,\n      _data = void 0;\n  this.status = response.statusCode;\n  this.headers = response.headers || {};\n  this.cookies = this.headers[\"set-cookie\"];\n\n  if (typeof body == 'string') {\n    _text = body;\n  } else if (Buffer.isBuffer(body)) {\n    this.buffer = body;\n  } else if ((typeof body === 'undefined' ? 'undefined' : _typeof(body)) == 'object') {\n    _data = body;\n  }\n\n  var getText = function getText() {\n    if (!_text && _this.buffer) {\n      _text = _this.buffer.toString('utf-8');\n    } else if (!_text && _data) {\n      _text = JSON.stringify(_data);\n    }\n    return _text;\n  };\n\n  var getData = function getData() {\n    if (!_data) {\n      try {\n        _data = JSON.parse(getText());\n      } catch (e) {/* */}\n    }\n    return _data;\n  };\n\n  Object.defineProperty(this, 'body', {\n    get: function get() {\n      return body;\n    }\n  });\n\n  Object.defineProperty(this, 'text', {\n    enumerable: true,\n    get: getText\n  });\n\n  Object.defineProperty(this, 'data', {\n    enumerable: true,\n    get: getData\n  });\n};\n\nexports.default = HTTPResponse;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server-s3-adapter/index.js":"'use strict';\n// S3Adapter\n//\n// Stores Parse files in AWS S3.\n\nvar AWS = require('aws-sdk');\nvar optionsFromArguments = require('./lib/optionsFromArguments');\n\n// Creates an S3 session.\n// Providing AWS access, secret keys and bucket are mandatory\n// Region will use sane defaults if omitted\nfunction S3Adapter() {\n  var options = optionsFromArguments(arguments);\n  this._region = options.region;\n  this._bucket = options.bucket;\n  this._bucketPrefix = options.bucketPrefix;\n  this._directAccess = options.directAccess;\n  this._baseUrl = options.baseUrl;\n  this._baseUrlDirect = options.baseUrlDirect;\n  this._signatureVersion = options.signatureVersion;\n  this._globalCacheControl = options.globalCacheControl;\n\n  let s3Options = {\n    params: { Bucket: this._bucket },\n    region: this._region,\n    signatureVersion: this._signatureVersion,\n    globalCacheControl: this._globalCacheControl\n  };\n\n  if (options.accessKey && options.secretKey) {\n    s3Options.accessKeyId = options.accessKey;\n    s3Options.secretAccessKey = options.secretKey;\n  }\n\n  Object.assign(s3Options, options.s3overrides);\n\n  this._s3Client = new AWS.S3(s3Options);\n  this._hasBucket = false;\n}\n\nS3Adapter.prototype.createBucket = function() {\n  var promise;\n  if (this._hasBucket) {\n    promise = Promise.resolve();\n  } else {\n    promise = new Promise((resolve) => {\n      this._s3Client.createBucket(() => {\n        this._hasBucket = true;\n        resolve();\n      });\n    });\n  }\n  return promise;\n}\n\n// For a given config object, filename, and data, store a file in S3\n// Returns a promise containing the S3 object creation response\nS3Adapter.prototype.createFile = function(filename, data, contentType) {\n  let params = {\n    Key: this._bucketPrefix + filename,\n    Body: data\n  };\n  if (this._directAccess) {\n    params.ACL = \"public-read\"\n  }\n  if (contentType) {\n    params.ContentType = contentType;\n  }\n  if(this._globalCacheControl) {\n    params.CacheControl = this._globalCacheControl;\n  }\n  return this.createBucket().then(() => {\n    return new Promise((resolve, reject) => {\n      this._s3Client.upload(params, (err, data) => {\n        if (err !== null) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  });\n}\n\nS3Adapter.prototype.deleteFile = function(filename) {\n  return this.createBucket().then(() => {\n    return new Promise((resolve, reject) => {\n      let params = {\n        Key: this._bucketPrefix + filename\n      };\n      this._s3Client.deleteObject(params, (err, data) =>{\n        if(err !== null) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  });\n}\n\n// Search for and return a file if found by filename\n// Returns a promise that succeeds with the buffer result from S3\nS3Adapter.prototype.getFileData = function(filename) {\n  let params = {Key: this._bucketPrefix + filename};\n  return this.createBucket().then(() => {\n    return new Promise((resolve, reject) => {\n      this._s3Client.getObject(params, (err, data) => {\n        if (err !== null) {\n          return reject(err);\n        }\n        // Something happened here...\n        if (data && !data.Body) {\n          return reject(data);\n        }\n        resolve(data.Body);\n      });\n    });\n  });\n}\n\n// Generates and returns the location of a file stored in S3 for the given request and filename\n// The location is the direct S3 link if the option is set, otherwise we serve the file through parse-server\nS3Adapter.prototype.getFileLocation = function(config, filename) {\n  filename = encodeURIComponent(filename);\n  if (this._directAccess) {\n    if (this._baseUrl && this._baseUrlDirect) {\n      return `${this._baseUrl}/${filename}`;\n    } else if (this._baseUrl) {\n      return `${this._baseUrl}/${this._bucketPrefix + filename}`;\n    } else {\n      return `https://${this._bucket}.s3.amazonaws.com/${this._bucketPrefix + filename}`;\n    }\n  }\n  return (config.mount + '/files/' + config.applicationId + '/' + filename);\n}\n\nmodule.exports = S3Adapter;\nmodule.exports.default = S3Adapter;\n","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server-s3-adapter/lib/optionsFromArguments.js":"'use strict';\n\nconst DEFAULT_S3_REGION = 'us-east-1';\n\nfunction requiredOrFromEnvironment(options, key, env) {\n  options[key] = options[key] || process.env[env];\n  if (!options[key]) {\n    throw `S3Adapter requires option '${key}' or env. variable ${env}`;\n  }\n  return options;\n}\n\nfunction fromEnvironmentOrDefault(options, key, env, defaultValue) {\n  options[key] = options[key] || process.env[env] || defaultValue;\n  return options;\n}\n\nconst optionsFromArguments = function optionsFromArguments(args) {\n  const stringOrOptions = args[0];\n  let options = {};\n  let s3overrides = {};\n  let otherOptions;\n\n  if (typeof stringOrOptions == 'string') {\n    if (args.length == 1) {\n      options.bucket = stringOrOptions;\n    } else if (args.length == 2) {\n      options.bucket = stringOrOptions;\n      if (typeof args[1] != 'object') {\n        throw new Error('Failed to configure S3Adapter. Arguments don\\'t make sense');\n      }\n      otherOptions = args[1];\n    } else if (args.length > 2) {\n      if (typeof args[1] != 'string' || typeof args[2] != 'string') {\n        throw new Error('Failed to configure S3Adapter. Arguments don\\'t make sense');\n      }\n      options.accessKey = args[0];\n      options.secretKey = args[1];\n      options.bucket = args[2];\n      otherOptions = args[3];\n    }\n\n    if (otherOptions) {\n      options.bucketPrefix = otherOptions.bucketPrefix;\n      options.directAccess = otherOptions.directAccess;\n      options.baseUrl = otherOptions.baseUrl;\n      options.baseUrlDirect = otherOptions.baseUrlDirect;\n      options.signatureVersion = otherOptions.signatureVersion;\n      options.globalCacheControl = otherOptions.globalCacheControl;\n    }\n  } else {\n    if (args.length == 1) {\n      Object.assign(options, stringOrOptions);\n    } else if (args.length == 2) {\n      Object.assign(options, stringOrOptions);\n      s3overrides = args[1];\n      options.bucket = s3overrides.params.Bucket;\n    } else if (args.length > 2) {\n      throw new Error('Failed to configure S3Adapter. Arguments don\\'t make sense');\n    }\n  }\n\n  options = requiredOrFromEnvironment(options, 'bucket', 'S3_BUCKET');\n  options = fromEnvironmentOrDefault(options, 'accessKey', 'S3_ACCESS_KEY', null);\n  options = fromEnvironmentOrDefault(options, 'secretKey', 'S3_SECRET_KEY', null);\n  options = fromEnvironmentOrDefault(options, 'bucketPrefix', 'S3_BUCKET_PREFIX', '');\n  options = fromEnvironmentOrDefault(options, 'region', 'S3_REGION', DEFAULT_S3_REGION);\n  options = fromEnvironmentOrDefault(options, 'directAccess', 'S3_DIRECT_ACCESS', false);\n  options = fromEnvironmentOrDefault(options, 'baseUrl', 'S3_BASE_URL', null);\n  options = fromEnvironmentOrDefault(options, 'baseUrlDirect', 'S3_BASE_URL_DIRECT', false);\n  options = fromEnvironmentOrDefault(options, 'signatureVersion', 'S3_SIGNATURE_VERSION', 'v4');\n  options = fromEnvironmentOrDefault(\n    options, 'globalCacheControl', 'S3_GLOBAL_CACHE_CONTROL', null);\n  options.s3overrides = s3overrides;\n\n  return options;\n}\n\nmodule.exports = optionsFromArguments;\n","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server-fs-adapter/index.js":"'use strict';\n// FileSystemAdapter\n//\n// Stores files in local file system\n// Requires write access to the server's file system.\n\nvar fs = require('fs');\nvar path = require('path');\nvar pathSep = require('path').sep;\n\nfunction FileSystemAdapter(options) {\n  options = options || {};\n  let filesSubDirectory = options.filesSubDirectory || '';\n  this._filesDir = filesSubDirectory;\n  this._mkdir(this._getApplicationDir());\n  if (!this._applicationDirExist()) {\n    throw \"Files directory doesn't exist.\";\n  }\n}\n\nFileSystemAdapter.prototype.createFile = function(filename, data) {\n  return new Promise((resolve, reject) => {\n    let filepath = this._getLocalFilePath(filename);\n    fs.writeFile(filepath, data, (err) => {\n      if(err !== null) {\n        return reject(err);\n      }\n      resolve(data);\n    });\n  });\n}\n\nFileSystemAdapter.prototype.deleteFile = function(filename) {\n  return new Promise((resolve, reject) => {\n    let filepath = this._getLocalFilePath(filename);\n    fs.readFile( filepath , function (err, data) {\n      if(err !== null) {\n        return reject(err);\n      }\n      fs.unlink(filepath, (unlinkErr) => {\n      if(err !== null) {\n          return reject(unlinkErr);\n        }\n        resolve(data);\n      });\n    });\n\n  });\n}\n\nFileSystemAdapter.prototype.getFileData = function(filename) {\n  return new Promise((resolve, reject) => {\n    let filepath = this._getLocalFilePath(filename);\n    fs.readFile( filepath , function (err, data) {\n      if(err !== null) {\n        return reject(err);\n      }\n      resolve(data);\n    });\n  });\n}\n\nFileSystemAdapter.prototype.getFileLocation = function(config, filename) {\n  return config.mount + '/files/' + config.applicationId + '/' + encodeURIComponent(filename);\n}\n\n/*\n  Helpers\n --------------- */\n FileSystemAdapter.prototype._getApplicationDir = function() {\n  if (this._filesDir) {\n    return path.join('files', this._filesDir);\n  } else {\n    return 'files';\n  }\n }\n\nFileSystemAdapter.prototype._applicationDirExist = function() {\n  return fs.existsSync(this._getApplicationDir());\n}\n\nFileSystemAdapter.prototype._getLocalFilePath = function(filename) {\n  let applicationDir = this._getApplicationDir();\n  if (!fs.existsSync(applicationDir)) {\n    this._mkdir(applicationDir);\n  }\n  return path.join(applicationDir, encodeURIComponent(filename));\n}\n\nFileSystemAdapter.prototype._mkdir = function(dirPath) {\n  // snippet found on -> https://gist.github.com/danherbert-epam/3960169\n  let dirs = dirPath.split(pathSep);\n  var root = \"\";\n\n  while (dirs.length > 0) {\n    var dir = dirs.shift();\n    if (dir === \"\") { // If directory starts with a /, the first path will be an empty string.\n      root = pathSep;\n    }\n    if (!fs.existsSync(path.join(root, dir))) {\n      try {\n        fs.mkdirSync(path.join(root, dir));\n      }\n      catch (e) {\n        if ( e.code == 'EACCES' ) {\n          throw new Error(\"PERMISSION ERROR: In order to use the FileSystemAdapter, write access to the server's file system is required.\");\n        }\n      }\n    }\n    root = path.join(root, dir, pathSep);\n  }\n}\n\nmodule.exports = FileSystemAdapter;\nmodule.exports.default = FileSystemAdapter;\n","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Cache/NullCacheAdapter.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar NullCacheAdapter = exports.NullCacheAdapter = function () {\n  function NullCacheAdapter() {\n    _classCallCheck(this, NullCacheAdapter);\n  }\n\n  _createClass(NullCacheAdapter, [{\n    key: \"get\",\n    value: function get() {\n      return new Promise(function (resolve) {\n        return resolve(null);\n      });\n    }\n  }, {\n    key: \"put\",\n    value: function put() {\n      return Promise.resolve();\n    }\n  }, {\n    key: \"del\",\n    value: function del() {\n      return Promise.resolve();\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      return Promise.resolve();\n    }\n  }]);\n\n  return NullCacheAdapter;\n}();\n\nexports.default = NullCacheAdapter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Cache/RedisCacheAdapter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RedisCacheAdapter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _redis = require('redis');\n\nvar _redis2 = _interopRequireDefault(_redis);\n\nvar _logger = require('../../logger');\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DEFAULT_REDIS_TTL = 30 * 1000; // 30 seconds in milliseconds\n\nfunction debug() {\n  _logger2.default.debug.apply(_logger2.default, ['RedisCacheAdapter'].concat(Array.prototype.slice.call(arguments)));\n}\n\nvar RedisCacheAdapter = exports.RedisCacheAdapter = function () {\n  function RedisCacheAdapter(redisCtx) {\n    var ttl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_REDIS_TTL;\n\n    _classCallCheck(this, RedisCacheAdapter);\n\n    this.client = _redis2.default.createClient(redisCtx);\n    this.p = Promise.resolve();\n    this.ttl = ttl;\n  }\n\n  _createClass(RedisCacheAdapter, [{\n    key: 'get',\n    value: function get(key) {\n      var _this = this;\n\n      debug('get', key);\n      this.p = this.p.then(function () {\n        return new Promise(function (resolve) {\n          _this.client.get(key, function (err, res) {\n            debug('-> get', key, res);\n            if (!res) {\n              return resolve(null);\n            }\n            resolve(JSON.parse(res));\n          });\n        });\n      });\n      return this.p;\n    }\n  }, {\n    key: 'put',\n    value: function put(key, value) {\n      var _this2 = this;\n\n      var ttl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.ttl;\n\n      value = JSON.stringify(value);\n      debug('put', key, value, ttl);\n      if (ttl === 0) {\n        return this.p; // ttl of zero is a logical no-op, but redis cannot set expire time of zero\n      }\n      if (ttl < 0 || isNaN(ttl)) {\n        ttl = DEFAULT_REDIS_TTL;\n      }\n      this.p = this.p.then(function () {\n        return new Promise(function (resolve) {\n          if (ttl === Infinity) {\n            _this2.client.set(key, value, function () {\n              resolve();\n            });\n          } else {\n            _this2.client.psetex(key, ttl, value, function () {\n              resolve();\n            });\n          }\n        });\n      });\n      return this.p;\n    }\n  }, {\n    key: 'del',\n    value: function del(key) {\n      var _this3 = this;\n\n      debug('del', key);\n      this.p = this.p.then(function () {\n        return new Promise(function (resolve) {\n          _this3.client.del(key, function () {\n            resolve();\n          });\n        });\n      });\n      return this.p;\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      var _this4 = this;\n\n      debug('clear');\n      this.p = this.p.then(function () {\n        return new Promise(function (resolve) {\n          _this4.client.flushdb(function () {\n            resolve();\n          });\n        });\n      });\n      return this.p;\n    }\n  }]);\n\n  return RedisCacheAdapter;\n}();\n\nexports.default = RedisCacheAdapter;","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/TestUtils.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.destroyAllDataPermanently = destroyAllDataPermanently;\n\nvar _cache = require('./cache');\n\nvar _cache2 = _interopRequireDefault(_cache);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//Used by tests\nfunction destroyAllDataPermanently() {\n  if (!process.env.TESTING) {\n    throw 'Only supported in test environment';\n  }\n  return Promise.all(Object.keys(_cache2.default.cache).map(function (appId) {\n    var app = _cache2.default.get(appId);\n    if (app.databaseController) {\n      return app.databaseController.deleteEverything();\n    } else {\n      return Promise.resolve();\n    }\n  }));\n}","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/deprecated.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useExternal = useExternal;\nfunction useExternal(name, moduleName) {\n  return function () {\n    throw name + \" is not provided by parse-server anymore; please install \" + moduleName;\n  };\n}","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/cli/parse-live-query-server.js":"'use strict';\n\nvar _parseLiveQueryServer = require('./definitions/parse-live-query-server');\n\nvar _parseLiveQueryServer2 = _interopRequireDefault(_parseLiveQueryServer);\n\nvar _runner = require('./utils/runner');\n\nvar _runner2 = _interopRequireDefault(_runner);\n\nvar _index = require('../index');\n\nvar _express = require('express');\n\nvar _express2 = _interopRequireDefault(_express);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(0, _runner2.default)({\n  definitions: _parseLiveQueryServer2.default,\n  start: function start(program, options, logOptions) {\n    logOptions();\n    var app = (0, _express2.default)();\n    var httpServer = require('http').createServer(app);\n    httpServer.listen(options.port);\n    _index.ParseServer.createLiveQueryServer(httpServer, options);\n  }\n});","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/cli/definitions/parse-live-query-server.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _parsers = require(\"../utils/parsers\");\n\nexports.default = {\n  \"appId\": {\n    required: true,\n    help: \"Required. This string should match the appId in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same appId.\"\n  },\n  \"masterKey\": {\n    required: true,\n    help: \"Required. This string should match the masterKey in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same masterKey.\"\n  },\n  \"serverURL\": {\n    required: true,\n    help: \"Required. This string should match the serverURL in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same serverURL.\"\n  },\n  \"redisURL\": {\n    help: \"Optional. This string should match the masterKey in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same masterKey.\"\n  },\n  \"keyPairs\": {\n    help: \"Optional. A JSON object that serves as a whitelist of keys. It is used for validating clients when they try to connect to the LiveQuery server. Check the following Security section and our protocol specification for details.\"\n  },\n  \"websocketTimeout\": {\n    help: \"Optional. Number of milliseconds between ping/pong frames. The WebSocket server sends ping/pong frames to the clients to keep the WebSocket alive. This value defines the interval of the ping/pong frame from the server to clients. Defaults to 10 * 1000 ms (10 s).\",\n    action: (0, _parsers.numberParser)(\"websocketTimeout\")\n  },\n  \"cacheTimeout\": {\n    help: \"Optional. Number in milliseconds. When clients provide the sessionToken to the LiveQuery server, the LiveQuery server will try to fetch its ParseUser's objectId from parse server and store it in the cache. The value defines the duration of the cache. Check the following Security section and our protocol specification for details. Defaults to 30 * 24 * 60 * 60 * 1000 ms (~30 days).\",\n    action: (0, _parsers.numberParser)(\"cacheTimeout\")\n  },\n  \"logLevel\": {\n    help: \"Optional. This string defines the log level of the LiveQuery server. We support VERBOSE, INFO, ERROR, NONE. Defaults to INFO.\"\n  },\n  \"port\": {\n    env: \"PORT\",\n    help: \"The port to run the ParseServer. defaults to 1337.\",\n    default: 1337,\n    action: (0, _parsers.numberParser)(\"port\")\n  }\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/cli/utils/runner.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = function (_ref) {\n  var definitions = _ref.definitions,\n      help = _ref.help,\n      usage = _ref.usage,\n      start = _ref.start;\n\n  _commander2.default.loadDefinitions(definitions);\n  if (usage) {\n    _commander2.default.usage(usage);\n  }\n  if (help) {\n    _commander2.default.on('--help', help);\n  }\n  _commander2.default.parse(process.argv, process.env);\n\n  var options = _commander2.default.getOptions();\n  start(_commander2.default, options, function () {\n    logStartupOptions(options);\n  });\n};\n\nvar _commander = require(\"./commander\");\n\nvar _commander2 = _interopRequireDefault(_commander);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction logStartupOptions(options) {\n  for (var key in options) {\n    var value = options[key];\n    if (key == \"masterKey\") {\n      value = \"***REDACTED***\";\n    }\n    if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === 'object') {\n      value = JSON.stringify(value);\n    }\n    /* eslint-disable no-console */\n    console.log(key + \": \" + value);\n    /* eslint-enable no-console */\n  }\n}","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/cli/utils/commander.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /* eslint-disable no-console */\n\n\nvar _commander = require('commander');\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _definitions = void 0;\nvar _reverseDefinitions = void 0;\nvar _defaults = void 0;\n\n_commander.Command.prototype.loadDefinitions = function (definitions) {\n  _definitions = definitions;\n\n  Object.keys(definitions).reduce(function (program, opt) {\n    if (_typeof(definitions[opt]) == \"object\") {\n      var additionalOptions = definitions[opt];\n      if (additionalOptions.required === true) {\n        return program.option('--' + opt + ' <' + opt + '>', additionalOptions.help, additionalOptions.action);\n      } else {\n        return program.option('--' + opt + ' [' + opt + ']', additionalOptions.help, additionalOptions.action);\n      }\n    }\n    return program.option('--' + opt + ' [' + opt + ']');\n  }, this);\n\n  _defaults = Object.keys(definitions).reduce(function (defs, opt) {\n    if (_definitions[opt].default) {\n      defs[opt] = _definitions[opt].default;\n    }\n    return defs;\n  }, {});\n\n  _reverseDefinitions = Object.keys(definitions).reduce(function (object, key) {\n    var value = definitions[key];\n    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == \"object\") {\n      value = value.env;\n    }\n    if (value) {\n      object[value] = key;\n    }\n    return object;\n  }, {});\n\n  /* istanbul ignore next */\n  this.on('--help', function () {\n    console.log('  Configure From Environment:');\n    console.log('');\n    Object.keys(_reverseDefinitions).forEach(function (key) {\n      console.log('    $ ' + key + '=\\'' + _reverseDefinitions[key] + '\\'');\n    });\n    console.log('');\n  });\n};\n\nfunction parseEnvironment() {\n  var env = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  return Object.keys(_reverseDefinitions).reduce(function (options, key) {\n    if (env[key]) {\n      var originalKey = _reverseDefinitions[key];\n      var action = function action(option) {\n        return option;\n      };\n      if (_typeof(_definitions[originalKey]) === \"object\") {\n        action = _definitions[originalKey].action || action;\n      }\n      options[_reverseDefinitions[key]] = action(env[key]);\n    }\n    return options;\n  }, {});\n}\n\nfunction parseConfigFile(program) {\n  var options = {};\n  if (program.args.length > 0) {\n    var jsonPath = program.args[0];\n    jsonPath = _path2.default.resolve(jsonPath);\n    var jsonConfig = require(jsonPath);\n    if (jsonConfig.apps) {\n      if (jsonConfig.apps.length > 1) {\n        throw 'Multiple apps are not supported';\n      }\n      options = jsonConfig.apps[0];\n    } else {\n      options = jsonConfig;\n    }\n    Object.keys(options).forEach(function (key) {\n      var value = options[key];\n      if (!_definitions[key]) {\n        throw 'error: unknown option ' + key;\n      }\n      var action = _definitions[key].action;\n      if (action) {\n        options[key] = action(value);\n      }\n    });\n    console.log('Configuration loaded from ' + jsonPath);\n  }\n  return options;\n}\n\n_commander.Command.prototype.setValuesIfNeeded = function (options) {\n  var _this = this;\n\n  Object.keys(options).forEach(function (key) {\n    if (!_this.hasOwnProperty(key)) {\n      _this[key] = options[key];\n    }\n  });\n};\n\n_commander.Command.prototype._parse = _commander.Command.prototype.parse;\n\n_commander.Command.prototype.parse = function (args, env) {\n  this._parse(args);\n  // Parse the environment first\n  var envOptions = parseEnvironment(env);\n  var fromFile = parseConfigFile(this);\n  // Load the env if not passed from command line\n  this.setValuesIfNeeded(envOptions);\n  // Load from file to override\n  this.setValuesIfNeeded(fromFile);\n  // Last set the defaults\n  this.setValuesIfNeeded(_defaults);\n};\n\n_commander.Command.prototype.getOptions = function () {\n  var _this2 = this;\n\n  return Object.keys(_definitions).reduce(function (options, key) {\n    if (typeof _this2[key] !== 'undefined') {\n      options[key] = _this2[key];\n    }\n    return options;\n  }, {});\n};\n\nexports.default = new _commander.Command();\n/* eslint-enable no-console */","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/cli/parse-server.js":"'use strict';\n\nvar _express = require('express');\n\nvar _express2 = _interopRequireDefault(_express);\n\nvar _index = require('../index');\n\nvar _parseServer = require('./definitions/parse-server');\n\nvar _parseServer2 = _interopRequireDefault(_parseServer);\n\nvar _cluster = require('cluster');\n\nvar _cluster2 = _interopRequireDefault(_cluster);\n\nvar _os = require('os');\n\nvar _os2 = _interopRequireDefault(_os);\n\nvar _runner = require('./utils/runner');\n\nvar _runner2 = _interopRequireDefault(_runner);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint-disable no-console */\nvar path = require(\"path\");\n\nvar help = function help() {\n  console.log('  Get Started guide:');\n  console.log('');\n  console.log('    Please have a look at the get started guide!');\n  console.log('    https://github.com/ParsePlatform/parse-server/wiki/Parse-Server-Guide');\n  console.log('');\n  console.log('');\n  console.log('  Usage with npm start');\n  console.log('');\n  console.log('    $ npm start -- path/to/config.json');\n  console.log('    $ npm start -- --appId APP_ID --masterKey MASTER_KEY --serverURL serverURL');\n  console.log('    $ npm start -- --appId APP_ID --masterKey MASTER_KEY --serverURL serverURL');\n  console.log('');\n  console.log('');\n  console.log('  Usage:');\n  console.log('');\n  console.log('    $ parse-server path/to/config.json');\n  console.log('    $ parse-server -- --appId APP_ID --masterKey MASTER_KEY --serverURL serverURL');\n  console.log('    $ parse-server -- --appId APP_ID --masterKey MASTER_KEY --serverURL serverURL');\n  console.log('');\n};\n\nfunction startServer(options, callback) {\n  var app = (0, _express2.default)();\n  if (options.middleware) {\n    var middleware = void 0;\n    if (typeof options.middleware == 'function') {\n      middleware = options.middleware;\n    }if (typeof options.middleware == 'string') {\n      middleware = require(path.resolve(process.cwd(), options.middleware));\n    } else {\n      throw \"middleware should be a string or a function\";\n    }\n    app.use(middleware);\n  }\n\n  var api = new _index.ParseServer(options);\n  var sockets = {};\n  app.use(options.mountPath, api);\n\n  var server = app.listen(options.port, options.host, callback);\n  server.on('connection', initializeConnections);\n\n  if (options.startLiveQueryServer || options.liveQueryServerOptions) {\n    var liveQueryServer = server;\n    if (options.liveQueryPort) {\n      liveQueryServer = (0, _express2.default)().listen(options.liveQueryPort, function () {\n        console.log('ParseLiveQuery listening on ' + options.liveQueryPort);\n      });\n    }\n    _index.ParseServer.createLiveQueryServer(liveQueryServer, options.liveQueryServerOptions);\n  }\n\n  function initializeConnections(socket) {\n    /* Currently, express doesn't shut down immediately after receiving SIGINT/SIGTERM if it has client connections that haven't timed out. (This is a known issue with node - https://github.com/nodejs/node/issues/2642)\n       This function, along with `destroyAliveConnections()`, intend to fix this behavior such that parse server will close all open connections and initiate the shutdown process as soon as it receives a SIGINT/SIGTERM signal. */\n\n    var socketId = socket.remoteAddress + ':' + socket.remotePort;\n    sockets[socketId] = socket;\n\n    socket.on('close', function () {\n      delete sockets[socketId];\n    });\n  }\n\n  function destroyAliveConnections() {\n    for (var socketId in sockets) {\n      try {\n        sockets[socketId].destroy();\n      } catch (e) {/* */}\n    }\n  }\n\n  var handleShutdown = function handleShutdown() {\n    console.log('Termination signal received. Shutting down.');\n    destroyAliveConnections();\n    server.close();\n  };\n  process.on('SIGTERM', handleShutdown);\n  process.on('SIGINT', handleShutdown);\n}\n\n(0, _runner2.default)({\n  definitions: _parseServer2.default,\n  help: help,\n  usage: '[options] <path/to/configuration.json>',\n  start: function start(program, options, logOptions) {\n    if (!options.serverURL) {\n      options.serverURL = 'http://localhost:' + options.port + options.mountPath;\n    }\n\n    if (!options.appId || !options.masterKey || !options.serverURL) {\n      program.outputHelp();\n      console.error(\"\");\n      console.error('\\x1B[31mERROR: appId and masterKey are required\\x1B[0m');\n      console.error(\"\");\n      process.exit(1);\n    }\n\n    if (options[\"liveQuery.classNames\"]) {\n      options.liveQuery = options.liveQuery || {};\n      options.liveQuery.classNames = options[\"liveQuery.classNames\"];\n      delete options[\"liveQuery.classNames\"];\n    }\n    if (options[\"liveQuery.redisURL\"]) {\n      options.liveQuery = options.liveQuery || {};\n      options.liveQuery.redisURL = options[\"liveQuery.redisURL\"];\n      delete options[\"liveQuery.redisURL\"];\n    }\n\n    if (options.cluster) {\n      var numCPUs = typeof options.cluster === 'number' ? options.cluster : _os2.default.cpus().length;\n      if (_cluster2.default.isMaster) {\n        logOptions();\n        for (var i = 0; i < numCPUs; i++) {\n          _cluster2.default.fork();\n        }\n        _cluster2.default.on('exit', function (worker, code) {\n          console.log('worker ' + worker.process.pid + ' died (' + code + ')... Restarting');\n          _cluster2.default.fork();\n        });\n      } else {\n        startServer(options, function () {\n          console.log('[' + process.pid + '] parse-server running on ' + options.serverURL);\n        });\n      }\n    } else {\n      startServer(options, function () {\n        logOptions();\n        console.log('');\n        console.log('[' + process.pid + '] parse-server running on ' + options.serverURL);\n      });\n    }\n  }\n});\n\n/* eslint-enable no-console */","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/cli/definitions/parse-server.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _parsers = require(\"../utils/parsers\");\n\nexports.default = {\n  \"appId\": {\n    env: \"PARSE_SERVER_APPLICATION_ID\",\n    help: \"Your Parse Application ID\",\n    required: true\n  },\n  \"masterKey\": {\n    env: \"PARSE_SERVER_MASTER_KEY\",\n    help: \"Your Parse Master Key\",\n    required: true\n  },\n  \"port\": {\n    env: \"PORT\",\n    help: \"The port to run the ParseServer. defaults to 1337.\",\n    default: 1337,\n    action: (0, _parsers.numberParser)(\"port\")\n  },\n  \"host\": {\n    env: \"PARSE_SERVER_HOST\",\n    help: \"The host to serve ParseServer on. defaults to 0.0.0.0\",\n    default: '0.0.0.0'\n  },\n  \"databaseURI\": {\n    env: \"PARSE_SERVER_DATABASE_URI\",\n    help: \"The full URI to your mongodb database\"\n  },\n  \"databaseOptions\": {\n    env: \"PARSE_SERVER_DATABASE_OPTIONS\",\n    help: \"Options to pass to the mongodb client\",\n    action: _parsers.objectParser\n  },\n  \"collectionPrefix\": {\n    env: \"PARSE_SERVER_COLLECTION_PREFIX\",\n    help: 'A collection prefix for the classes'\n  },\n  \"serverURL\": {\n    env: \"PARSE_SERVER_URL\",\n    help: \"URL to your parse server with http:// or https://.\"\n  },\n  \"publicServerURL\": {\n    env: \"PARSE_PUBLIC_SERVER_URL\",\n    help: \"Public URL to your parse server with http:// or https://.\"\n  },\n  \"clientKey\": {\n    env: \"PARSE_SERVER_CLIENT_KEY\",\n    help: \"Key for iOS, MacOS, tvOS clients\"\n  },\n  \"javascriptKey\": {\n    env: \"PARSE_SERVER_JAVASCRIPT_KEY\",\n    help: \"Key for the Javascript SDK\"\n  },\n  \"restAPIKey\": {\n    env: \"PARSE_SERVER_REST_API_KEY\",\n    help: \"Key for REST calls\"\n  },\n  \"dotNetKey\": {\n    env: \"PARSE_SERVER_DOT_NET_KEY\",\n    help: \"Key for Unity and .Net SDK\"\n  },\n  \"webhookKey\": {\n    env: \"PARSE_SERVER_WEBHOOK_KEY\",\n    help: \"Key sent with outgoing webhook calls\"\n  },\n  \"cloud\": {\n    env: \"PARSE_SERVER_CLOUD_CODE_MAIN\",\n    help: \"Full path to your cloud code main.js\"\n  },\n  \"push\": {\n    env: \"PARSE_SERVER_PUSH\",\n    help: \"Configuration for push, as stringified JSON. See https://github.com/ParsePlatform/parse-server/wiki/Push\",\n    action: _parsers.objectParser\n  },\n  \"oauth\": {\n    env: \"PARSE_SERVER_OAUTH_PROVIDERS\",\n    help: \"[DEPRECATED (use auth option)] Configuration for your oAuth providers, as stringified JSON. See https://github.com/ParsePlatform/parse-server/wiki/Parse-Server-Guide#oauth\",\n    action: _parsers.objectParser\n  },\n  \"auth\": {\n    env: \"PARSE_SERVER_AUTH_PROVIDERS\",\n    help: \"Configuration for your authentication providers, as stringified JSON. See https://github.com/ParsePlatform/parse-server/wiki/Parse-Server-Guide#oauth\",\n    action: _parsers.objectParser\n  },\n  \"fileKey\": {\n    env: \"PARSE_SERVER_FILE_KEY\",\n    help: \"Key for your files\"\n  },\n  \"facebookAppIds\": {\n    env: \"PARSE_SERVER_FACEBOOK_APP_IDS\",\n    help: \"[DEPRECATED (use auth option)]\",\n    action: function action() {\n      throw 'facebookAppIds is deprecated, please use { auth: \\\n         {facebook: \\\n           { appIds: [] } \\\n          }\\\n        }\\\n      }';\n    }\n  },\n  \"enableAnonymousUsers\": {\n    env: \"PARSE_SERVER_ENABLE_ANON_USERS\",\n    help: \"Enable (or disable) anon users, defaults to true\",\n    action: _parsers.booleanParser\n  },\n  \"allowClientClassCreation\": {\n    env: \"PARSE_SERVER_ALLOW_CLIENT_CLASS_CREATION\",\n    help: \"Enable (or disable) client class creation, defaults to true\",\n    action: _parsers.booleanParser\n  },\n  \"mountPath\": {\n    env: \"PARSE_SERVER_MOUNT_PATH\",\n    help: \"Mount path for the server, defaults to /parse\",\n    default: \"/parse\"\n  },\n  \"filesAdapter\": {\n    env: \"PARSE_SERVER_FILES_ADAPTER\",\n    help: \"Adapter module for the files sub-system\",\n    action: _parsers.moduleOrObjectParser\n  },\n  \"emailAdapter\": {\n    env: \"PARSE_SERVER_EMAIL_ADAPTER\",\n    help: \"Adapter module for the email sending\",\n    action: _parsers.moduleOrObjectParser\n  },\n  \"verifyUserEmails\": {\n    env: \"PARSE_SERVER_VERIFY_USER_EMAILS\",\n    help: \"Enable (or disable) user email validation, defaults to false\",\n    action: _parsers.booleanParser\n  },\n  \"preventLoginWithUnverifiedEmail\": {\n    env: \"PARSE_SERVER_PREVENT_LOGIN_WITH_UNVERIFIED_EMAIL\",\n    help: \"Prevent user from login if email is not verified and PARSE_SERVER_VERIFY_USER_EMAILS is true, defaults to false\",\n    action: _parsers.booleanParser\n  },\n  \"emailVerifyTokenValidityDuration\": {\n    env: \"PARSE_SERVER_EMAIL_VERIFY_TOKEN_VALIDITY_DURATION\",\n    help: \"Email verification token validity duration\",\n    action: (0, _parsers.numberParser)(\"emailVerifyTokenValidityDuration\")\n  },\n  \"accountLockout\": {\n    env: \"PARSE_SERVER_ACCOUNT_LOCKOUT\",\n    help: \"account lockout policy for failed login attempts\",\n    action: _parsers.objectParser\n  },\n  \"passwordPolicy\": {\n    env: \"PARSE_SERVER_PASSWORD_POLICY\",\n    help: \"Password policy for enforcing password related rules\",\n    action: _parsers.objectParser\n  },\n  \"appName\": {\n    env: \"PARSE_SERVER_APP_NAME\",\n    help: \"Sets the app name\"\n  },\n  \"loggerAdapter\": {\n    env: \"PARSE_SERVER_LOGGER_ADAPTER\",\n    help: \"Adapter module for the logging sub-system\",\n    action: _parsers.moduleOrObjectParser\n  },\n  \"customPages\": {\n    env: \"PARSE_SERVER_CUSTOM_PAGES\",\n    help: \"custom pages for password validation and reset\",\n    action: _parsers.objectParser\n  },\n  \"maxUploadSize\": {\n    env: \"PARSE_SERVER_MAX_UPLOAD_SIZE\",\n    help: \"Max file size for uploads.\",\n    default: \"20mb\"\n  },\n  \"userSensitiveFields\": {\n    help: \"Personally identifiable information fields in the user table the should be removed for non-authorized users.\",\n    default: [\"email\"]\n  },\n  \"sessionLength\": {\n    env: \"PARSE_SERVER_SESSION_LENGTH\",\n    help: \"Session duration, defaults to 1 year\",\n    action: (0, _parsers.numberParser)(\"sessionLength\")\n  },\n  \"verbose\": {\n    env: \"VERBOSE\",\n    help: \"Set the logging to verbose\"\n  },\n  \"jsonLogs\": {\n    env: \"JSON_LOGS\",\n    help: \"Log as structured JSON objects\"\n  },\n  \"logLevel\": {\n    env: \"PARSE_SERVER_LOG_LEVEL\",\n    help: \"Sets the level for logs\"\n  },\n  \"logsFolder\": {\n    env: \"PARSE_SERVER_LOGS_FOLDER\",\n    help: \"Folder for the logs (defaults to './logs'); set to null to disable file based logging\",\n    action: _parsers.nullParser\n  },\n  \"silent\": {\n    help: \"Disables console output\"\n  },\n  \"revokeSessionOnPasswordReset\": {\n    env: \"PARSE_SERVER_REVOKE_SESSION_ON_PASSWORD_RESET\",\n    help: \"When a user changes their password, either through the reset password email or while logged in, all sessions are revoked if this is true. Set to false if you don't want to revoke sessions.\",\n    action: _parsers.booleanParser\n  },\n  \"schemaCacheTTL\": {\n    env: \"PARSE_SERVER_SCHEMA_CACHE_TTL\",\n    help: \"The TTL for caching the schema for optimizing read/write operations. You should put a long TTL when your DB is in production. default to 0; disabled.\",\n    action: (0, _parsers.numberParser)(\"schemaCacheTTL\")\n  },\n  \"enableSingleSchemaCache\": {\n    env: \"PARSE_SERVER_ENABLE_SINGLE_SCHEMA_CACHE\",\n    help: \"Use a single schema cache shared across requests. Reduces number of queries made to _SCHEMA. Defaults to false, i.e. unique schema cache per request.\",\n    action: _parsers.booleanParser\n  },\n  \"cluster\": {\n    env: \"PARSE_SERVER_CLUSTER\",\n    help: \"Run with cluster, optionally set the number of processes default to os.cpus().length\",\n    action: (0, _parsers.numberOrBoolParser)(\"cluster\")\n  },\n  \"liveQuery\": {\n    env: \"PARSE_SERVER_LIVE_QUERY_OPTIONS\",\n    help: \"parse-server's LiveQuery configuration object\",\n    action: _parsers.objectParser\n  },\n  \"liveQuery.classNames\": {\n    help: \"parse-server's LiveQuery classNames\",\n    action: _parsers.arrayParser\n  },\n  \"liveQuery.redisURL\": {\n    help: \"parse-server's LiveQuery redisURL\"\n  },\n  \"startLiveQueryServer\": {\n    help: \"Starts the liveQuery server\",\n    action: _parsers.booleanParser\n  },\n  \"liveQueryPort\": {\n    help: 'Specific port to start the live query server',\n    action: (0, _parsers.numberParser)(\"liveQueryPort\")\n  },\n  \"liveQueryServerOptions\": {\n    help: \"Live query server configuration options (will start the liveQuery server)\",\n    action: _parsers.objectParser\n  },\n  \"middleware\": {\n    help: \"middleware for express server, can be string or function\"\n  }\n};","/home/travis/build/npmtest/node-npmtest-parse-server/node_modules/parse-server/lib/Adapters/Auth/AuthAdapter.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*eslint no-unused-vars: \"off\"*/\nvar AuthAdapter = exports.AuthAdapter = function () {\n  function AuthAdapter() {\n    _classCallCheck(this, AuthAdapter);\n  }\n\n  _createClass(AuthAdapter, [{\n    key: \"validateAppId\",\n\n\n    /*\n    @param appIds: the specified app ids in the configuration\n    @param authData: the client provided authData\n    @returns a promise that resolves if the applicationId is valid\n     */\n    value: function validateAppId(appIds, authData) {\n      return Promise.resolve({});\n    }\n\n    /*\n    @param authData: the client provided authData\n    @param options: additional options\n     */\n\n  }, {\n    key: \"validateAuthData\",\n    value: function validateAuthData(authData, options) {\n      return Promise.resolve({});\n    }\n  }]);\n\n  return AuthAdapter;\n}();\n\nexports.default = AuthAdapter;"}